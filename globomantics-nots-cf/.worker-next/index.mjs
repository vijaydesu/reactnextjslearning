
				
				globalThis.__dirname ??= "";

// Do not crash on cache not supported
// https://github.com/cloudflare/workerd/pull/2434
// compatibility flag "cache_option_enabled" -> does not support "force-cache"
const curFetch = globalThis.fetch;
globalThis.fetch = (input, init) => {
  if (init) {
    delete init.cache;
  }
  return curFetch(input, init);
};
import { Readable } from 'node:stream';
fetch = globalThis.fetch;
const CustomRequest = class extends globalThis.Request {
  constructor(input, init) {
    if (init) {
      delete init.cache;
      if (init.body?.__node_stream__ === true) {
        // https://github.com/cloudflare/workerd/issues/2746
        init.body = Readable.toWeb(init.body);
      }
    }
    super(input, init);
  }
};
globalThis.Request = CustomRequest;
Request = globalThis.Request;

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export2 = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// .worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js
var require_reflect = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/adapters/reflect.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ReflectAdapter", {
      enumerable: true,
      get: function() {
        return ReflectAdapter;
      }
    });
    var ReflectAdapter = class {
      static get(target, prop, receiver) {
        const value = Reflect.get(target, prop, receiver);
        if (typeof value === "function") {
          return value.bind(target);
        }
        return value;
      }
      static set(target, prop, value, receiver) {
        return Reflect.set(target, prop, value, receiver);
      }
      static has(target, prop) {
        return Reflect.has(target, prop);
      }
      static deleteProperty(target, prop) {
        return Reflect.deleteProperty(target, prop);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/adapters/headers.js
var require_headers = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/adapters/headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      HeadersAdapter: function() {
        return HeadersAdapter;
      },
      ReadonlyHeadersError: function() {
        return ReadonlyHeadersError;
      }
    });
    var _reflect = require_reflect();
    var ReadonlyHeadersError = class extends Error {
      constructor() {
        super("Headers cannot be modified. Read more: https://nextjs.org/docs/app/api-reference/functions/headers");
      }
      static callable() {
        throw new ReadonlyHeadersError();
      }
    };
    var HeadersAdapter = class extends Headers {
      constructor(headers) {
        super();
        this.headers = new Proxy(headers, {
          get(target, prop, receiver) {
            if (typeof prop === "symbol") {
              return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
            const lowercased = prop.toLowerCase();
            const original = Object.keys(headers).find((o) => o.toLowerCase() === lowercased);
            if (typeof original === "undefined")
              return;
            return _reflect.ReflectAdapter.get(target, original, receiver);
          },
          set(target, prop, value, receiver) {
            if (typeof prop === "symbol") {
              return _reflect.ReflectAdapter.set(target, prop, value, receiver);
            }
            const lowercased = prop.toLowerCase();
            const original = Object.keys(headers).find((o) => o.toLowerCase() === lowercased);
            return _reflect.ReflectAdapter.set(target, original ?? prop, value, receiver);
          },
          has(target, prop) {
            if (typeof prop === "symbol")
              return _reflect.ReflectAdapter.has(target, prop);
            const lowercased = prop.toLowerCase();
            const original = Object.keys(headers).find((o) => o.toLowerCase() === lowercased);
            if (typeof original === "undefined")
              return false;
            return _reflect.ReflectAdapter.has(target, original);
          },
          deleteProperty(target, prop) {
            if (typeof prop === "symbol")
              return _reflect.ReflectAdapter.deleteProperty(target, prop);
            const lowercased = prop.toLowerCase();
            const original = Object.keys(headers).find((o) => o.toLowerCase() === lowercased);
            if (typeof original === "undefined")
              return true;
            return _reflect.ReflectAdapter.deleteProperty(target, original);
          }
        });
      }
      /**
      * Seals a Headers instance to prevent modification by throwing an error when
      * any mutating method is called.
      */
      static seal(headers) {
        return new Proxy(headers, {
          get(target, prop, receiver) {
            switch (prop) {
              case "append":
              case "delete":
              case "set":
                return ReadonlyHeadersError.callable;
              default:
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
          }
        });
      }
      /**
      * Merges a header value into a string. This stores multiple values as an
      * array, so we need to merge them into a string.
      *
      * @param value a header value
      * @returns a merged header value (a string)
      */
      merge(value) {
        if (Array.isArray(value))
          return value.join(", ");
        return value;
      }
      /**
      * Creates a Headers instance from a plain object or a Headers instance.
      *
      * @param headers a plain object or a Headers instance
      * @returns a headers instance
      */
      static from(headers) {
        if (headers instanceof Headers)
          return headers;
        return new HeadersAdapter(headers);
      }
      append(name, value) {
        const existing = this.headers[name];
        if (typeof existing === "string") {
          this.headers[name] = [
            existing,
            value
          ];
        } else if (Array.isArray(existing)) {
          existing.push(value);
        } else {
          this.headers[name] = value;
        }
      }
      delete(name) {
        delete this.headers[name];
      }
      get(name) {
        const value = this.headers[name];
        if (typeof value !== "undefined")
          return this.merge(value);
        return null;
      }
      has(name) {
        return typeof this.headers[name] !== "undefined";
      }
      set(name, value) {
        this.headers[name] = value;
      }
      forEach(callbackfn, thisArg) {
        for (const [name, value] of this.entries()) {
          callbackfn.call(thisArg, value, name, this);
        }
      }
      *entries() {
        for (const key of Object.keys(this.headers)) {
          const name = key.toLowerCase();
          const value = this.get(name);
          yield [
            name,
            value
          ];
        }
      }
      *keys() {
        for (const key of Object.keys(this.headers)) {
          const name = key.toLowerCase();
          yield name;
        }
      }
      *values() {
        for (const key of Object.keys(this.headers)) {
          const value = this.get(key);
          yield value;
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/constants.js
var require_constants = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      ACTION_SUFFIX: function() {
        return ACTION_SUFFIX;
      },
      APP_DIR_ALIAS: function() {
        return APP_DIR_ALIAS;
      },
      CACHE_ONE_YEAR: function() {
        return CACHE_ONE_YEAR;
      },
      DOT_NEXT_ALIAS: function() {
        return DOT_NEXT_ALIAS;
      },
      ESLINT_DEFAULT_DIRS: function() {
        return ESLINT_DEFAULT_DIRS;
      },
      GSP_NO_RETURNED_VALUE: function() {
        return GSP_NO_RETURNED_VALUE;
      },
      GSSP_COMPONENT_MEMBER_ERROR: function() {
        return GSSP_COMPONENT_MEMBER_ERROR;
      },
      GSSP_NO_RETURNED_VALUE: function() {
        return GSSP_NO_RETURNED_VALUE;
      },
      INFINITE_CACHE: function() {
        return INFINITE_CACHE;
      },
      INSTRUMENTATION_HOOK_FILENAME: function() {
        return INSTRUMENTATION_HOOK_FILENAME;
      },
      MIDDLEWARE_FILENAME: function() {
        return MIDDLEWARE_FILENAME;
      },
      MIDDLEWARE_LOCATION_REGEXP: function() {
        return MIDDLEWARE_LOCATION_REGEXP;
      },
      NEXT_BODY_SUFFIX: function() {
        return NEXT_BODY_SUFFIX;
      },
      NEXT_CACHE_IMPLICIT_TAG_ID: function() {
        return NEXT_CACHE_IMPLICIT_TAG_ID;
      },
      NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {
        return NEXT_CACHE_REVALIDATED_TAGS_HEADER;
      },
      NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {
        return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;
      },
      NEXT_CACHE_SOFT_TAGS_HEADER: function() {
        return NEXT_CACHE_SOFT_TAGS_HEADER;
      },
      NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {
        return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;
      },
      NEXT_CACHE_TAGS_HEADER: function() {
        return NEXT_CACHE_TAGS_HEADER;
      },
      NEXT_CACHE_TAG_MAX_ITEMS: function() {
        return NEXT_CACHE_TAG_MAX_ITEMS;
      },
      NEXT_CACHE_TAG_MAX_LENGTH: function() {
        return NEXT_CACHE_TAG_MAX_LENGTH;
      },
      NEXT_DATA_SUFFIX: function() {
        return NEXT_DATA_SUFFIX;
      },
      NEXT_INTERCEPTION_MARKER_PREFIX: function() {
        return NEXT_INTERCEPTION_MARKER_PREFIX;
      },
      NEXT_META_SUFFIX: function() {
        return NEXT_META_SUFFIX;
      },
      NEXT_QUERY_PARAM_PREFIX: function() {
        return NEXT_QUERY_PARAM_PREFIX;
      },
      NEXT_RESUME_HEADER: function() {
        return NEXT_RESUME_HEADER;
      },
      NON_STANDARD_NODE_ENV: function() {
        return NON_STANDARD_NODE_ENV;
      },
      PAGES_DIR_ALIAS: function() {
        return PAGES_DIR_ALIAS;
      },
      PRERENDER_REVALIDATE_HEADER: function() {
        return PRERENDER_REVALIDATE_HEADER;
      },
      PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {
        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
      },
      PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {
        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;
      },
      ROOT_DIR_ALIAS: function() {
        return ROOT_DIR_ALIAS;
      },
      RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {
        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;
      },
      RSC_ACTION_ENCRYPTION_ALIAS: function() {
        return RSC_ACTION_ENCRYPTION_ALIAS;
      },
      RSC_ACTION_PROXY_ALIAS: function() {
        return RSC_ACTION_PROXY_ALIAS;
      },
      RSC_ACTION_VALIDATE_ALIAS: function() {
        return RSC_ACTION_VALIDATE_ALIAS;
      },
      RSC_CACHE_WRAPPER_ALIAS: function() {
        return RSC_CACHE_WRAPPER_ALIAS;
      },
      RSC_MOD_REF_PROXY_ALIAS: function() {
        return RSC_MOD_REF_PROXY_ALIAS;
      },
      RSC_PREFETCH_SUFFIX: function() {
        return RSC_PREFETCH_SUFFIX;
      },
      RSC_SEGMENTS_DIR_SUFFIX: function() {
        return RSC_SEGMENTS_DIR_SUFFIX;
      },
      RSC_SEGMENT_SUFFIX: function() {
        return RSC_SEGMENT_SUFFIX;
      },
      RSC_SUFFIX: function() {
        return RSC_SUFFIX;
      },
      SERVER_PROPS_EXPORT_ERROR: function() {
        return SERVER_PROPS_EXPORT_ERROR;
      },
      SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {
        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;
      },
      SERVER_PROPS_SSG_CONFLICT: function() {
        return SERVER_PROPS_SSG_CONFLICT;
      },
      SERVER_RUNTIME: function() {
        return SERVER_RUNTIME;
      },
      SSG_FALLBACK_EXPORT_ERROR: function() {
        return SSG_FALLBACK_EXPORT_ERROR;
      },
      SSG_GET_INITIAL_PROPS_CONFLICT: function() {
        return SSG_GET_INITIAL_PROPS_CONFLICT;
      },
      STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {
        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;
      },
      UNSTABLE_REVALIDATE_RENAME_ERROR: function() {
        return UNSTABLE_REVALIDATE_RENAME_ERROR;
      },
      WEBPACK_LAYERS: function() {
        return WEBPACK_LAYERS;
      },
      WEBPACK_RESOURCE_QUERIES: function() {
        return WEBPACK_RESOURCE_QUERIES;
      }
    });
    var NEXT_QUERY_PARAM_PREFIX = "nxtP";
    var NEXT_INTERCEPTION_MARKER_PREFIX = "nxtI";
    var PRERENDER_REVALIDATE_HEADER = "x-prerender-revalidate";
    var PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = "x-prerender-revalidate-if-generated";
    var RSC_PREFETCH_SUFFIX = ".prefetch.rsc";
    var RSC_SEGMENTS_DIR_SUFFIX = ".segments";
    var RSC_SEGMENT_SUFFIX = ".segment.rsc";
    var RSC_SUFFIX = ".rsc";
    var ACTION_SUFFIX = ".action";
    var NEXT_DATA_SUFFIX = ".json";
    var NEXT_META_SUFFIX = ".meta";
    var NEXT_BODY_SUFFIX = ".body";
    var NEXT_CACHE_TAGS_HEADER = "x-next-cache-tags";
    var NEXT_CACHE_SOFT_TAGS_HEADER = "x-next-cache-soft-tags";
    var NEXT_CACHE_REVALIDATED_TAGS_HEADER = "x-next-revalidated-tags";
    var NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = "x-next-revalidate-tag-token";
    var NEXT_RESUME_HEADER = "next-resume";
    var NEXT_CACHE_TAG_MAX_ITEMS = 64;
    var NEXT_CACHE_TAG_MAX_LENGTH = 256;
    var NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
    var NEXT_CACHE_IMPLICIT_TAG_ID = "_N_T_";
    var CACHE_ONE_YEAR = 31536e3;
    var INFINITE_CACHE = 4294967294;
    var MIDDLEWARE_FILENAME = "middleware";
    var MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
    var INSTRUMENTATION_HOOK_FILENAME = "instrumentation";
    var PAGES_DIR_ALIAS = "private-next-pages";
    var DOT_NEXT_ALIAS = "private-dot-next";
    var ROOT_DIR_ALIAS = "private-next-root-dir";
    var APP_DIR_ALIAS = "private-next-app-dir";
    var RSC_MOD_REF_PROXY_ALIAS = "private-next-rsc-mod-ref-proxy";
    var RSC_ACTION_VALIDATE_ALIAS = "private-next-rsc-action-validate";
    var RSC_ACTION_PROXY_ALIAS = "private-next-rsc-server-reference";
    var RSC_CACHE_WRAPPER_ALIAS = "private-next-rsc-cache-wrapper";
    var RSC_ACTION_ENCRYPTION_ALIAS = "private-next-rsc-action-encryption";
    var RSC_ACTION_CLIENT_WRAPPER_ALIAS = "private-next-rsc-action-client-wrapper";
    var PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
    var SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
    var SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
    var SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
    var STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
    var SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
    var GSP_NO_RETURNED_VALUE = "Your `getStaticProps` function did not return an object. Did you forget to add a `return`?";
    var GSSP_NO_RETURNED_VALUE = "Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?";
    var UNSTABLE_REVALIDATE_RENAME_ERROR = "The `unstable_revalidate` property is available for general use.\nPlease use `revalidate` instead.";
    var GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
    var NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
    var SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
    var ESLINT_DEFAULT_DIRS = [
      "app",
      "pages",
      "components",
      "lib",
      "src"
    ];
    var SERVER_RUNTIME = {
      edge: "edge",
      experimentalEdge: "experimental-edge",
      nodejs: "nodejs"
    };
    var WEBPACK_LAYERS_NAMES = {
      /**
      * The layer for the shared code between the client and server bundles.
      */
      shared: "shared",
      /**
      * The layer for server-only runtime and picking up `react-server` export conditions.
      * Including app router RSC pages and app router custom routes.
      */
      reactServerComponents: "rsc",
      /**
      * Server Side Rendering layer for app (ssr).
      */
      serverSideRendering: "ssr",
      /**
      * The browser client bundle layer for actions.
      */
      actionBrowser: "action-browser",
      /**
      * The layer for the API routes.
      */
      api: "api",
      /**
      * The layer for the middleware code.
      */
      middleware: "middleware",
      /**
      * The layer for the instrumentation hooks.
      */
      instrument: "instrument",
      /**
      * The layer for assets on the edge.
      */
      edgeAsset: "edge-asset",
      /**
      * The browser client bundle layer for App directory.
      */
      appPagesBrowser: "app-pages-browser",
      /**
      * The server bundle layer for metadata routes.
      */
      appMetadataRoute: "app-metadata-route"
    };
    var WEBPACK_LAYERS = {
      ...WEBPACK_LAYERS_NAMES,
      GROUP: {
        builtinReact: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser,
          WEBPACK_LAYERS_NAMES.appMetadataRoute
        ],
        serverOnly: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser,
          WEBPACK_LAYERS_NAMES.appMetadataRoute,
          WEBPACK_LAYERS_NAMES.instrument,
          WEBPACK_LAYERS_NAMES.middleware
        ],
        neutralTarget: [
          // pages api
          WEBPACK_LAYERS_NAMES.api
        ],
        clientOnly: [
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser
        ],
        bundled: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser,
          WEBPACK_LAYERS_NAMES.appMetadataRoute,
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser,
          WEBPACK_LAYERS_NAMES.shared,
          WEBPACK_LAYERS_NAMES.instrument
        ],
        appPages: [
          // app router pages and layouts
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser,
          WEBPACK_LAYERS_NAMES.actionBrowser
        ]
      }
    };
    var WEBPACK_RESOURCE_QUERIES = {
      edgeSSREntry: "__next_edge_ssr_entry__",
      metadata: "__next_metadata__",
      metadataRoute: "__next_metadata_route__",
      metadataImageMeta: "__next_metadata_image_meta__"
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/trace/constants.js
var require_constants2 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/trace/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      AppRenderSpan: function() {
        return AppRenderSpan;
      },
      AppRouteRouteHandlersSpan: function() {
        return AppRouteRouteHandlersSpan;
      },
      BaseServerSpan: function() {
        return BaseServerSpan;
      },
      LoadComponentsSpan: function() {
        return LoadComponentsSpan;
      },
      LogSpanAllowList: function() {
        return LogSpanAllowList;
      },
      MiddlewareSpan: function() {
        return MiddlewareSpan;
      },
      NextNodeServerSpan: function() {
        return NextNodeServerSpan;
      },
      NextServerSpan: function() {
        return NextServerSpan;
      },
      NextVanillaSpanAllowlist: function() {
        return NextVanillaSpanAllowlist;
      },
      NodeSpan: function() {
        return NodeSpan;
      },
      RenderSpan: function() {
        return RenderSpan;
      },
      ResolveMetadataSpan: function() {
        return ResolveMetadataSpan;
      },
      RouterSpan: function() {
        return RouterSpan;
      },
      StartServerSpan: function() {
        return StartServerSpan;
      }
    });
    var BaseServerSpan;
    (function(BaseServerSpan2) {
      BaseServerSpan2["handleRequest"] = "BaseServer.handleRequest";
      BaseServerSpan2["run"] = "BaseServer.run";
      BaseServerSpan2["pipe"] = "BaseServer.pipe";
      BaseServerSpan2["getStaticHTML"] = "BaseServer.getStaticHTML";
      BaseServerSpan2["render"] = "BaseServer.render";
      BaseServerSpan2["renderToResponseWithComponents"] = "BaseServer.renderToResponseWithComponents";
      BaseServerSpan2["renderToResponse"] = "BaseServer.renderToResponse";
      BaseServerSpan2["renderToHTML"] = "BaseServer.renderToHTML";
      BaseServerSpan2["renderError"] = "BaseServer.renderError";
      BaseServerSpan2["renderErrorToResponse"] = "BaseServer.renderErrorToResponse";
      BaseServerSpan2["renderErrorToHTML"] = "BaseServer.renderErrorToHTML";
      BaseServerSpan2["render404"] = "BaseServer.render404";
    })(BaseServerSpan || (BaseServerSpan = {}));
    var LoadComponentsSpan;
    (function(LoadComponentsSpan2) {
      LoadComponentsSpan2["loadDefaultErrorComponents"] = "LoadComponents.loadDefaultErrorComponents";
      LoadComponentsSpan2["loadComponents"] = "LoadComponents.loadComponents";
    })(LoadComponentsSpan || (LoadComponentsSpan = {}));
    var NextServerSpan;
    (function(NextServerSpan2) {
      NextServerSpan2["getRequestHandler"] = "NextServer.getRequestHandler";
      NextServerSpan2["getServer"] = "NextServer.getServer";
      NextServerSpan2["getServerRequestHandler"] = "NextServer.getServerRequestHandler";
      NextServerSpan2["createServer"] = "createServer.createServer";
    })(NextServerSpan || (NextServerSpan = {}));
    var NextNodeServerSpan;
    (function(NextNodeServerSpan2) {
      NextNodeServerSpan2["compression"] = "NextNodeServer.compression";
      NextNodeServerSpan2["getBuildId"] = "NextNodeServer.getBuildId";
      NextNodeServerSpan2["createComponentTree"] = "NextNodeServer.createComponentTree";
      NextNodeServerSpan2["clientComponentLoading"] = "NextNodeServer.clientComponentLoading";
      NextNodeServerSpan2["getLayoutOrPageModule"] = "NextNodeServer.getLayoutOrPageModule";
      NextNodeServerSpan2["generateStaticRoutes"] = "NextNodeServer.generateStaticRoutes";
      NextNodeServerSpan2["generateFsStaticRoutes"] = "NextNodeServer.generateFsStaticRoutes";
      NextNodeServerSpan2["generatePublicRoutes"] = "NextNodeServer.generatePublicRoutes";
      NextNodeServerSpan2["generateImageRoutes"] = "NextNodeServer.generateImageRoutes.route";
      NextNodeServerSpan2["sendRenderResult"] = "NextNodeServer.sendRenderResult";
      NextNodeServerSpan2["proxyRequest"] = "NextNodeServer.proxyRequest";
      NextNodeServerSpan2["runApi"] = "NextNodeServer.runApi";
      NextNodeServerSpan2["render"] = "NextNodeServer.render";
      NextNodeServerSpan2["renderHTML"] = "NextNodeServer.renderHTML";
      NextNodeServerSpan2["imageOptimizer"] = "NextNodeServer.imageOptimizer";
      NextNodeServerSpan2["getPagePath"] = "NextNodeServer.getPagePath";
      NextNodeServerSpan2["getRoutesManifest"] = "NextNodeServer.getRoutesManifest";
      NextNodeServerSpan2["findPageComponents"] = "NextNodeServer.findPageComponents";
      NextNodeServerSpan2["getFontManifest"] = "NextNodeServer.getFontManifest";
      NextNodeServerSpan2["getServerComponentManifest"] = "NextNodeServer.getServerComponentManifest";
      NextNodeServerSpan2["getRequestHandler"] = "NextNodeServer.getRequestHandler";
      NextNodeServerSpan2["renderToHTML"] = "NextNodeServer.renderToHTML";
      NextNodeServerSpan2["renderError"] = "NextNodeServer.renderError";
      NextNodeServerSpan2["renderErrorToHTML"] = "NextNodeServer.renderErrorToHTML";
      NextNodeServerSpan2["render404"] = "NextNodeServer.render404";
      NextNodeServerSpan2["startResponse"] = "NextNodeServer.startResponse";
      NextNodeServerSpan2["route"] = "route";
      NextNodeServerSpan2["onProxyReq"] = "onProxyReq";
      NextNodeServerSpan2["apiResolver"] = "apiResolver";
      NextNodeServerSpan2["internalFetch"] = "internalFetch";
    })(NextNodeServerSpan || (NextNodeServerSpan = {}));
    var StartServerSpan;
    (function(StartServerSpan2) {
      StartServerSpan2["startServer"] = "startServer.startServer";
    })(StartServerSpan || (StartServerSpan = {}));
    var RenderSpan;
    (function(RenderSpan2) {
      RenderSpan2["getServerSideProps"] = "Render.getServerSideProps";
      RenderSpan2["getStaticProps"] = "Render.getStaticProps";
      RenderSpan2["renderToString"] = "Render.renderToString";
      RenderSpan2["renderDocument"] = "Render.renderDocument";
      RenderSpan2["createBodyResult"] = "Render.createBodyResult";
    })(RenderSpan || (RenderSpan = {}));
    var AppRenderSpan;
    (function(AppRenderSpan2) {
      AppRenderSpan2["renderToString"] = "AppRender.renderToString";
      AppRenderSpan2["renderToReadableStream"] = "AppRender.renderToReadableStream";
      AppRenderSpan2["getBodyResult"] = "AppRender.getBodyResult";
      AppRenderSpan2["fetch"] = "AppRender.fetch";
    })(AppRenderSpan || (AppRenderSpan = {}));
    var RouterSpan;
    (function(RouterSpan2) {
      RouterSpan2["executeRoute"] = "Router.executeRoute";
    })(RouterSpan || (RouterSpan = {}));
    var NodeSpan;
    (function(NodeSpan2) {
      NodeSpan2["runHandler"] = "Node.runHandler";
    })(NodeSpan || (NodeSpan = {}));
    var AppRouteRouteHandlersSpan;
    (function(AppRouteRouteHandlersSpan2) {
      AppRouteRouteHandlersSpan2["runHandler"] = "AppRouteRouteHandlers.runHandler";
    })(AppRouteRouteHandlersSpan || (AppRouteRouteHandlersSpan = {}));
    var ResolveMetadataSpan;
    (function(ResolveMetadataSpan2) {
      ResolveMetadataSpan2["generateMetadata"] = "ResolveMetadata.generateMetadata";
      ResolveMetadataSpan2["generateViewport"] = "ResolveMetadata.generateViewport";
    })(ResolveMetadataSpan || (ResolveMetadataSpan = {}));
    var MiddlewareSpan;
    (function(MiddlewareSpan2) {
      MiddlewareSpan2["execute"] = "Middleware.execute";
    })(MiddlewareSpan || (MiddlewareSpan = {}));
    var NextVanillaSpanAllowlist = [
      "Middleware.execute",
      "BaseServer.handleRequest",
      "Render.getServerSideProps",
      "Render.getStaticProps",
      "AppRender.fetch",
      "AppRender.getBodyResult",
      "Render.renderDocument",
      "Node.runHandler",
      "AppRouteRouteHandlers.runHandler",
      "ResolveMetadata.generateMetadata",
      "ResolveMetadata.generateViewport",
      "NextNodeServer.createComponentTree",
      "NextNodeServer.findPageComponents",
      "NextNodeServer.getLayoutOrPageModule",
      "NextNodeServer.startResponse",
      "NextNodeServer.clientComponentLoading"
    ];
    var LogSpanAllowList = [
      "NextNodeServer.findPageComponents",
      "NextNodeServer.createComponentTree",
      "NextNodeServer.clientComponentLoading"
    ];
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/is-thenable.js
var require_is_thenable = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/is-thenable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isThenable", {
      enumerable: true,
      get: function() {
        return isThenable;
      }
    });
    function isThenable(promise) {
      return promise !== null && typeof promise === "object" && "then" in promise && typeof promise.then === "function";
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/compiled/@opentelemetry/api/index.js
var require_api = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/compiled/@opentelemetry/api/index.js"(exports, module) {
    (() => {
      "use strict";
      var e = { 491: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ContextAPI = void 0;
        const n = r2(223);
        const a = r2(172);
        const o = r2(930);
        const i = "context";
        const c = new n.NoopContextManager();
        class ContextAPI {
          constructor() {
          }
          static getInstance() {
            if (!this._instance) {
              this._instance = new ContextAPI();
            }
            return this._instance;
          }
          setGlobalContextManager(e3) {
            return (0, a.registerGlobal)(i, e3, o.DiagAPI.instance());
          }
          active() {
            return this._getContextManager().active();
          }
          with(e3, t3, r3, ...n2) {
            return this._getContextManager().with(e3, t3, r3, ...n2);
          }
          bind(e3, t3) {
            return this._getContextManager().bind(e3, t3);
          }
          _getContextManager() {
            return (0, a.getGlobal)(i) || c;
          }
          disable() {
            this._getContextManager().disable();
            (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
          }
        }
        t2.ContextAPI = ContextAPI;
      }, 930: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DiagAPI = void 0;
        const n = r2(56);
        const a = r2(912);
        const o = r2(957);
        const i = r2(172);
        const c = "diag";
        class DiagAPI {
          constructor() {
            function _logProxy(e4) {
              return function(...t3) {
                const r3 = (0, i.getGlobal)("diag");
                if (!r3)
                  return;
                return r3[e4](...t3);
              };
            }
            const e3 = this;
            const setLogger = (t3, r3 = { logLevel: o.DiagLogLevel.INFO }) => {
              var n2, c2, s;
              if (t3 === e3) {
                const t4 = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
                e3.error((n2 = t4.stack) !== null && n2 !== void 0 ? n2 : t4.message);
                return false;
              }
              if (typeof r3 === "number") {
                r3 = { logLevel: r3 };
              }
              const u = (0, i.getGlobal)("diag");
              const l = (0, a.createLogLevelDiagLogger)((c2 = r3.logLevel) !== null && c2 !== void 0 ? c2 : o.DiagLogLevel.INFO, t3);
              if (u && !r3.suppressOverrideMessage) {
                const e4 = (s = new Error().stack) !== null && s !== void 0 ? s : "<failed to generate stacktrace>";
                u.warn(`Current logger will be overwritten from ${e4}`);
                l.warn(`Current logger will overwrite one already registered from ${e4}`);
              }
              return (0, i.registerGlobal)("diag", l, e3, true);
            };
            e3.setLogger = setLogger;
            e3.disable = () => {
              (0, i.unregisterGlobal)(c, e3);
            };
            e3.createComponentLogger = (e4) => new n.DiagComponentLogger(e4);
            e3.verbose = _logProxy("verbose");
            e3.debug = _logProxy("debug");
            e3.info = _logProxy("info");
            e3.warn = _logProxy("warn");
            e3.error = _logProxy("error");
          }
          static instance() {
            if (!this._instance) {
              this._instance = new DiagAPI();
            }
            return this._instance;
          }
        }
        t2.DiagAPI = DiagAPI;
      }, 653: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.MetricsAPI = void 0;
        const n = r2(660);
        const a = r2(172);
        const o = r2(930);
        const i = "metrics";
        class MetricsAPI {
          constructor() {
          }
          static getInstance() {
            if (!this._instance) {
              this._instance = new MetricsAPI();
            }
            return this._instance;
          }
          setGlobalMeterProvider(e3) {
            return (0, a.registerGlobal)(i, e3, o.DiagAPI.instance());
          }
          getMeterProvider() {
            return (0, a.getGlobal)(i) || n.NOOP_METER_PROVIDER;
          }
          getMeter(e3, t3, r3) {
            return this.getMeterProvider().getMeter(e3, t3, r3);
          }
          disable() {
            (0, a.unregisterGlobal)(i, o.DiagAPI.instance());
          }
        }
        t2.MetricsAPI = MetricsAPI;
      }, 181: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.PropagationAPI = void 0;
        const n = r2(172);
        const a = r2(874);
        const o = r2(194);
        const i = r2(277);
        const c = r2(369);
        const s = r2(930);
        const u = "propagation";
        const l = new a.NoopTextMapPropagator();
        class PropagationAPI {
          constructor() {
            this.createBaggage = c.createBaggage;
            this.getBaggage = i.getBaggage;
            this.getActiveBaggage = i.getActiveBaggage;
            this.setBaggage = i.setBaggage;
            this.deleteBaggage = i.deleteBaggage;
          }
          static getInstance() {
            if (!this._instance) {
              this._instance = new PropagationAPI();
            }
            return this._instance;
          }
          setGlobalPropagator(e3) {
            return (0, n.registerGlobal)(u, e3, s.DiagAPI.instance());
          }
          inject(e3, t3, r3 = o.defaultTextMapSetter) {
            return this._getGlobalPropagator().inject(e3, t3, r3);
          }
          extract(e3, t3, r3 = o.defaultTextMapGetter) {
            return this._getGlobalPropagator().extract(e3, t3, r3);
          }
          fields() {
            return this._getGlobalPropagator().fields();
          }
          disable() {
            (0, n.unregisterGlobal)(u, s.DiagAPI.instance());
          }
          _getGlobalPropagator() {
            return (0, n.getGlobal)(u) || l;
          }
        }
        t2.PropagationAPI = PropagationAPI;
      }, 997: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.TraceAPI = void 0;
        const n = r2(172);
        const a = r2(846);
        const o = r2(139);
        const i = r2(607);
        const c = r2(930);
        const s = "trace";
        class TraceAPI {
          constructor() {
            this._proxyTracerProvider = new a.ProxyTracerProvider();
            this.wrapSpanContext = o.wrapSpanContext;
            this.isSpanContextValid = o.isSpanContextValid;
            this.deleteSpan = i.deleteSpan;
            this.getSpan = i.getSpan;
            this.getActiveSpan = i.getActiveSpan;
            this.getSpanContext = i.getSpanContext;
            this.setSpan = i.setSpan;
            this.setSpanContext = i.setSpanContext;
          }
          static getInstance() {
            if (!this._instance) {
              this._instance = new TraceAPI();
            }
            return this._instance;
          }
          setGlobalTracerProvider(e3) {
            const t3 = (0, n.registerGlobal)(s, this._proxyTracerProvider, c.DiagAPI.instance());
            if (t3) {
              this._proxyTracerProvider.setDelegate(e3);
            }
            return t3;
          }
          getTracerProvider() {
            return (0, n.getGlobal)(s) || this._proxyTracerProvider;
          }
          getTracer(e3, t3) {
            return this.getTracerProvider().getTracer(e3, t3);
          }
          disable() {
            (0, n.unregisterGlobal)(s, c.DiagAPI.instance());
            this._proxyTracerProvider = new a.ProxyTracerProvider();
          }
        }
        t2.TraceAPI = TraceAPI;
      }, 277: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.deleteBaggage = t2.setBaggage = t2.getActiveBaggage = t2.getBaggage = void 0;
        const n = r2(491);
        const a = r2(780);
        const o = (0, a.createContextKey)("OpenTelemetry Baggage Key");
        function getBaggage(e3) {
          return e3.getValue(o) || void 0;
        }
        t2.getBaggage = getBaggage;
        function getActiveBaggage() {
          return getBaggage(n.ContextAPI.getInstance().active());
        }
        t2.getActiveBaggage = getActiveBaggage;
        function setBaggage(e3, t3) {
          return e3.setValue(o, t3);
        }
        t2.setBaggage = setBaggage;
        function deleteBaggage(e3) {
          return e3.deleteValue(o);
        }
        t2.deleteBaggage = deleteBaggage;
      }, 993: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.BaggageImpl = void 0;
        class BaggageImpl {
          constructor(e3) {
            this._entries = e3 ? new Map(e3) : /* @__PURE__ */ new Map();
          }
          getEntry(e3) {
            const t3 = this._entries.get(e3);
            if (!t3) {
              return void 0;
            }
            return Object.assign({}, t3);
          }
          getAllEntries() {
            return Array.from(this._entries.entries()).map(([e3, t3]) => [e3, t3]);
          }
          setEntry(e3, t3) {
            const r2 = new BaggageImpl(this._entries);
            r2._entries.set(e3, t3);
            return r2;
          }
          removeEntry(e3) {
            const t3 = new BaggageImpl(this._entries);
            t3._entries.delete(e3);
            return t3;
          }
          removeEntries(...e3) {
            const t3 = new BaggageImpl(this._entries);
            for (const r2 of e3) {
              t3._entries.delete(r2);
            }
            return t3;
          }
          clear() {
            return new BaggageImpl();
          }
        }
        t2.BaggageImpl = BaggageImpl;
      }, 830: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.baggageEntryMetadataSymbol = void 0;
        t2.baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
      }, 369: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.baggageEntryMetadataFromString = t2.createBaggage = void 0;
        const n = r2(930);
        const a = r2(993);
        const o = r2(830);
        const i = n.DiagAPI.instance();
        function createBaggage(e3 = {}) {
          return new a.BaggageImpl(new Map(Object.entries(e3)));
        }
        t2.createBaggage = createBaggage;
        function baggageEntryMetadataFromString(e3) {
          if (typeof e3 !== "string") {
            i.error(`Cannot create baggage metadata from unknown type: ${typeof e3}`);
            e3 = "";
          }
          return { __TYPE__: o.baggageEntryMetadataSymbol, toString() {
            return e3;
          } };
        }
        t2.baggageEntryMetadataFromString = baggageEntryMetadataFromString;
      }, 67: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.context = void 0;
        const n = r2(491);
        t2.context = n.ContextAPI.getInstance();
      }, 223: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NoopContextManager = void 0;
        const n = r2(780);
        class NoopContextManager {
          active() {
            return n.ROOT_CONTEXT;
          }
          with(e3, t3, r3, ...n2) {
            return t3.call(r3, ...n2);
          }
          bind(e3, t3) {
            return t3;
          }
          enable() {
            return this;
          }
          disable() {
            return this;
          }
        }
        t2.NoopContextManager = NoopContextManager;
      }, 780: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ROOT_CONTEXT = t2.createContextKey = void 0;
        function createContextKey(e3) {
          return Symbol.for(e3);
        }
        t2.createContextKey = createContextKey;
        class BaseContext {
          constructor(e3) {
            const t3 = this;
            t3._currentContext = e3 ? new Map(e3) : /* @__PURE__ */ new Map();
            t3.getValue = (e4) => t3._currentContext.get(e4);
            t3.setValue = (e4, r2) => {
              const n = new BaseContext(t3._currentContext);
              n._currentContext.set(e4, r2);
              return n;
            };
            t3.deleteValue = (e4) => {
              const r2 = new BaseContext(t3._currentContext);
              r2._currentContext.delete(e4);
              return r2;
            };
          }
        }
        t2.ROOT_CONTEXT = new BaseContext();
      }, 506: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.diag = void 0;
        const n = r2(930);
        t2.diag = n.DiagAPI.instance();
      }, 56: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DiagComponentLogger = void 0;
        const n = r2(172);
        class DiagComponentLogger {
          constructor(e3) {
            this._namespace = e3.namespace || "DiagComponentLogger";
          }
          debug(...e3) {
            return logProxy("debug", this._namespace, e3);
          }
          error(...e3) {
            return logProxy("error", this._namespace, e3);
          }
          info(...e3) {
            return logProxy("info", this._namespace, e3);
          }
          warn(...e3) {
            return logProxy("warn", this._namespace, e3);
          }
          verbose(...e3) {
            return logProxy("verbose", this._namespace, e3);
          }
        }
        t2.DiagComponentLogger = DiagComponentLogger;
        function logProxy(e3, t3, r3) {
          const a = (0, n.getGlobal)("diag");
          if (!a) {
            return;
          }
          r3.unshift(t3);
          return a[e3](...r3);
        }
      }, 972: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DiagConsoleLogger = void 0;
        const r2 = [{ n: "error", c: "error" }, { n: "warn", c: "warn" }, { n: "info", c: "info" }, { n: "debug", c: "debug" }, { n: "verbose", c: "trace" }];
        class DiagConsoleLogger {
          constructor() {
            function _consoleFunc(e3) {
              return function(...t3) {
                if (console) {
                  let r3 = console[e3];
                  if (typeof r3 !== "function") {
                    r3 = console.log;
                  }
                  if (typeof r3 === "function") {
                    return r3.apply(console, t3);
                  }
                }
              };
            }
            for (let e3 = 0; e3 < r2.length; e3++) {
              this[r2[e3].n] = _consoleFunc(r2[e3].c);
            }
          }
        }
        t2.DiagConsoleLogger = DiagConsoleLogger;
      }, 912: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.createLogLevelDiagLogger = void 0;
        const n = r2(957);
        function createLogLevelDiagLogger(e3, t3) {
          if (e3 < n.DiagLogLevel.NONE) {
            e3 = n.DiagLogLevel.NONE;
          } else if (e3 > n.DiagLogLevel.ALL) {
            e3 = n.DiagLogLevel.ALL;
          }
          t3 = t3 || {};
          function _filterFunc(r3, n2) {
            const a = t3[r3];
            if (typeof a === "function" && e3 >= n2) {
              return a.bind(t3);
            }
            return function() {
            };
          }
          return { error: _filterFunc("error", n.DiagLogLevel.ERROR), warn: _filterFunc("warn", n.DiagLogLevel.WARN), info: _filterFunc("info", n.DiagLogLevel.INFO), debug: _filterFunc("debug", n.DiagLogLevel.DEBUG), verbose: _filterFunc("verbose", n.DiagLogLevel.VERBOSE) };
        }
        t2.createLogLevelDiagLogger = createLogLevelDiagLogger;
      }, 957: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DiagLogLevel = void 0;
        var r2;
        (function(e3) {
          e3[e3["NONE"] = 0] = "NONE";
          e3[e3["ERROR"] = 30] = "ERROR";
          e3[e3["WARN"] = 50] = "WARN";
          e3[e3["INFO"] = 60] = "INFO";
          e3[e3["DEBUG"] = 70] = "DEBUG";
          e3[e3["VERBOSE"] = 80] = "VERBOSE";
          e3[e3["ALL"] = 9999] = "ALL";
        })(r2 = t2.DiagLogLevel || (t2.DiagLogLevel = {}));
      }, 172: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.unregisterGlobal = t2.getGlobal = t2.registerGlobal = void 0;
        const n = r2(200);
        const a = r2(521);
        const o = r2(130);
        const i = a.VERSION.split(".")[0];
        const c = Symbol.for(`opentelemetry.js.api.${i}`);
        const s = n._globalThis;
        function registerGlobal(e3, t3, r3, n2 = false) {
          var o2;
          const i2 = s[c] = (o2 = s[c]) !== null && o2 !== void 0 ? o2 : { version: a.VERSION };
          if (!n2 && i2[e3]) {
            const t4 = new Error(`@opentelemetry/api: Attempted duplicate registration of API: ${e3}`);
            r3.error(t4.stack || t4.message);
            return false;
          }
          if (i2.version !== a.VERSION) {
            const t4 = new Error(`@opentelemetry/api: Registration of version v${i2.version} for ${e3} does not match previously registered API v${a.VERSION}`);
            r3.error(t4.stack || t4.message);
            return false;
          }
          i2[e3] = t3;
          r3.debug(`@opentelemetry/api: Registered a global for ${e3} v${a.VERSION}.`);
          return true;
        }
        t2.registerGlobal = registerGlobal;
        function getGlobal(e3) {
          var t3, r3;
          const n2 = (t3 = s[c]) === null || t3 === void 0 ? void 0 : t3.version;
          if (!n2 || !(0, o.isCompatible)(n2)) {
            return;
          }
          return (r3 = s[c]) === null || r3 === void 0 ? void 0 : r3[e3];
        }
        t2.getGlobal = getGlobal;
        function unregisterGlobal(e3, t3) {
          t3.debug(`@opentelemetry/api: Unregistering a global for ${e3} v${a.VERSION}.`);
          const r3 = s[c];
          if (r3) {
            delete r3[e3];
          }
        }
        t2.unregisterGlobal = unregisterGlobal;
      }, 130: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.isCompatible = t2._makeCompatibilityCheck = void 0;
        const n = r2(521);
        const a = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
        function _makeCompatibilityCheck(e3) {
          const t3 = /* @__PURE__ */ new Set([e3]);
          const r3 = /* @__PURE__ */ new Set();
          const n2 = e3.match(a);
          if (!n2) {
            return () => false;
          }
          const o = { major: +n2[1], minor: +n2[2], patch: +n2[3], prerelease: n2[4] };
          if (o.prerelease != null) {
            return function isExactmatch(t4) {
              return t4 === e3;
            };
          }
          function _reject(e4) {
            r3.add(e4);
            return false;
          }
          function _accept(e4) {
            t3.add(e4);
            return true;
          }
          return function isCompatible(e4) {
            if (t3.has(e4)) {
              return true;
            }
            if (r3.has(e4)) {
              return false;
            }
            const n3 = e4.match(a);
            if (!n3) {
              return _reject(e4);
            }
            const i = { major: +n3[1], minor: +n3[2], patch: +n3[3], prerelease: n3[4] };
            if (i.prerelease != null) {
              return _reject(e4);
            }
            if (o.major !== i.major) {
              return _reject(e4);
            }
            if (o.major === 0) {
              if (o.minor === i.minor && o.patch <= i.patch) {
                return _accept(e4);
              }
              return _reject(e4);
            }
            if (o.minor <= i.minor) {
              return _accept(e4);
            }
            return _reject(e4);
          };
        }
        t2._makeCompatibilityCheck = _makeCompatibilityCheck;
        t2.isCompatible = _makeCompatibilityCheck(n.VERSION);
      }, 886: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.metrics = void 0;
        const n = r2(653);
        t2.metrics = n.MetricsAPI.getInstance();
      }, 901: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ValueType = void 0;
        var r2;
        (function(e3) {
          e3[e3["INT"] = 0] = "INT";
          e3[e3["DOUBLE"] = 1] = "DOUBLE";
        })(r2 = t2.ValueType || (t2.ValueType = {}));
      }, 102: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.createNoopMeter = t2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = t2.NOOP_OBSERVABLE_GAUGE_METRIC = t2.NOOP_OBSERVABLE_COUNTER_METRIC = t2.NOOP_UP_DOWN_COUNTER_METRIC = t2.NOOP_HISTOGRAM_METRIC = t2.NOOP_COUNTER_METRIC = t2.NOOP_METER = t2.NoopObservableUpDownCounterMetric = t2.NoopObservableGaugeMetric = t2.NoopObservableCounterMetric = t2.NoopObservableMetric = t2.NoopHistogramMetric = t2.NoopUpDownCounterMetric = t2.NoopCounterMetric = t2.NoopMetric = t2.NoopMeter = void 0;
        class NoopMeter {
          constructor() {
          }
          createHistogram(e3, r2) {
            return t2.NOOP_HISTOGRAM_METRIC;
          }
          createCounter(e3, r2) {
            return t2.NOOP_COUNTER_METRIC;
          }
          createUpDownCounter(e3, r2) {
            return t2.NOOP_UP_DOWN_COUNTER_METRIC;
          }
          createObservableGauge(e3, r2) {
            return t2.NOOP_OBSERVABLE_GAUGE_METRIC;
          }
          createObservableCounter(e3, r2) {
            return t2.NOOP_OBSERVABLE_COUNTER_METRIC;
          }
          createObservableUpDownCounter(e3, r2) {
            return t2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
          }
          addBatchObservableCallback(e3, t3) {
          }
          removeBatchObservableCallback(e3) {
          }
        }
        t2.NoopMeter = NoopMeter;
        class NoopMetric {
        }
        t2.NoopMetric = NoopMetric;
        class NoopCounterMetric extends NoopMetric {
          add(e3, t3) {
          }
        }
        t2.NoopCounterMetric = NoopCounterMetric;
        class NoopUpDownCounterMetric extends NoopMetric {
          add(e3, t3) {
          }
        }
        t2.NoopUpDownCounterMetric = NoopUpDownCounterMetric;
        class NoopHistogramMetric extends NoopMetric {
          record(e3, t3) {
          }
        }
        t2.NoopHistogramMetric = NoopHistogramMetric;
        class NoopObservableMetric {
          addCallback(e3) {
          }
          removeCallback(e3) {
          }
        }
        t2.NoopObservableMetric = NoopObservableMetric;
        class NoopObservableCounterMetric extends NoopObservableMetric {
        }
        t2.NoopObservableCounterMetric = NoopObservableCounterMetric;
        class NoopObservableGaugeMetric extends NoopObservableMetric {
        }
        t2.NoopObservableGaugeMetric = NoopObservableGaugeMetric;
        class NoopObservableUpDownCounterMetric extends NoopObservableMetric {
        }
        t2.NoopObservableUpDownCounterMetric = NoopObservableUpDownCounterMetric;
        t2.NOOP_METER = new NoopMeter();
        t2.NOOP_COUNTER_METRIC = new NoopCounterMetric();
        t2.NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
        t2.NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
        t2.NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
        t2.NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
        t2.NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
        function createNoopMeter() {
          return t2.NOOP_METER;
        }
        t2.createNoopMeter = createNoopMeter;
      }, 660: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NOOP_METER_PROVIDER = t2.NoopMeterProvider = void 0;
        const n = r2(102);
        class NoopMeterProvider {
          getMeter(e3, t3, r3) {
            return n.NOOP_METER;
          }
        }
        t2.NoopMeterProvider = NoopMeterProvider;
        t2.NOOP_METER_PROVIDER = new NoopMeterProvider();
      }, 200: function(e2, t2, r2) {
        var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
          if (n2 === void 0)
            n2 = r3;
          Object.defineProperty(e3, n2, { enumerable: true, get: function() {
            return t3[r3];
          } });
        } : function(e3, t3, r3, n2) {
          if (n2 === void 0)
            n2 = r3;
          e3[n2] = t3[r3];
        });
        var a = this && this.__exportStar || function(e3, t3) {
          for (var r3 in e3)
            if (r3 !== "default" && !Object.prototype.hasOwnProperty.call(t3, r3))
              n(t3, e3, r3);
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        a(r2(46), t2);
      }, 651: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2._globalThis = void 0;
        t2._globalThis = typeof globalThis === "object" ? globalThis : global;
      }, 46: function(e2, t2, r2) {
        var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
          if (n2 === void 0)
            n2 = r3;
          Object.defineProperty(e3, n2, { enumerable: true, get: function() {
            return t3[r3];
          } });
        } : function(e3, t3, r3, n2) {
          if (n2 === void 0)
            n2 = r3;
          e3[n2] = t3[r3];
        });
        var a = this && this.__exportStar || function(e3, t3) {
          for (var r3 in e3)
            if (r3 !== "default" && !Object.prototype.hasOwnProperty.call(t3, r3))
              n(t3, e3, r3);
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        a(r2(651), t2);
      }, 939: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.propagation = void 0;
        const n = r2(181);
        t2.propagation = n.PropagationAPI.getInstance();
      }, 874: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NoopTextMapPropagator = void 0;
        class NoopTextMapPropagator {
          inject(e3, t3) {
          }
          extract(e3, t3) {
            return e3;
          }
          fields() {
            return [];
          }
        }
        t2.NoopTextMapPropagator = NoopTextMapPropagator;
      }, 194: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.defaultTextMapSetter = t2.defaultTextMapGetter = void 0;
        t2.defaultTextMapGetter = { get(e3, t3) {
          if (e3 == null) {
            return void 0;
          }
          return e3[t3];
        }, keys(e3) {
          if (e3 == null) {
            return [];
          }
          return Object.keys(e3);
        } };
        t2.defaultTextMapSetter = { set(e3, t3, r2) {
          if (e3 == null) {
            return;
          }
          e3[t3] = r2;
        } };
      }, 845: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.trace = void 0;
        const n = r2(997);
        t2.trace = n.TraceAPI.getInstance();
      }, 403: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NonRecordingSpan = void 0;
        const n = r2(476);
        class NonRecordingSpan {
          constructor(e3 = n.INVALID_SPAN_CONTEXT) {
            this._spanContext = e3;
          }
          spanContext() {
            return this._spanContext;
          }
          setAttribute(e3, t3) {
            return this;
          }
          setAttributes(e3) {
            return this;
          }
          addEvent(e3, t3) {
            return this;
          }
          setStatus(e3) {
            return this;
          }
          updateName(e3) {
            return this;
          }
          end(e3) {
          }
          isRecording() {
            return false;
          }
          recordException(e3, t3) {
          }
        }
        t2.NonRecordingSpan = NonRecordingSpan;
      }, 614: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NoopTracer = void 0;
        const n = r2(491);
        const a = r2(607);
        const o = r2(403);
        const i = r2(139);
        const c = n.ContextAPI.getInstance();
        class NoopTracer {
          startSpan(e3, t3, r3 = c.active()) {
            const n2 = Boolean(t3 === null || t3 === void 0 ? void 0 : t3.root);
            if (n2) {
              return new o.NonRecordingSpan();
            }
            const s = r3 && (0, a.getSpanContext)(r3);
            if (isSpanContext(s) && (0, i.isSpanContextValid)(s)) {
              return new o.NonRecordingSpan(s);
            } else {
              return new o.NonRecordingSpan();
            }
          }
          startActiveSpan(e3, t3, r3, n2) {
            let o2;
            let i2;
            let s;
            if (arguments.length < 2) {
              return;
            } else if (arguments.length === 2) {
              s = t3;
            } else if (arguments.length === 3) {
              o2 = t3;
              s = r3;
            } else {
              o2 = t3;
              i2 = r3;
              s = n2;
            }
            const u = i2 !== null && i2 !== void 0 ? i2 : c.active();
            const l = this.startSpan(e3, o2, u);
            const g = (0, a.setSpan)(u, l);
            return c.with(g, s, void 0, l);
          }
        }
        t2.NoopTracer = NoopTracer;
        function isSpanContext(e3) {
          return typeof e3 === "object" && typeof e3["spanId"] === "string" && typeof e3["traceId"] === "string" && typeof e3["traceFlags"] === "number";
        }
      }, 124: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.NoopTracerProvider = void 0;
        const n = r2(614);
        class NoopTracerProvider {
          getTracer(e3, t3, r3) {
            return new n.NoopTracer();
          }
        }
        t2.NoopTracerProvider = NoopTracerProvider;
      }, 125: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ProxyTracer = void 0;
        const n = r2(614);
        const a = new n.NoopTracer();
        class ProxyTracer {
          constructor(e3, t3, r3, n2) {
            this._provider = e3;
            this.name = t3;
            this.version = r3;
            this.options = n2;
          }
          startSpan(e3, t3, r3) {
            return this._getTracer().startSpan(e3, t3, r3);
          }
          startActiveSpan(e3, t3, r3, n2) {
            const a2 = this._getTracer();
            return Reflect.apply(a2.startActiveSpan, a2, arguments);
          }
          _getTracer() {
            if (this._delegate) {
              return this._delegate;
            }
            const e3 = this._provider.getDelegateTracer(this.name, this.version, this.options);
            if (!e3) {
              return a;
            }
            this._delegate = e3;
            return this._delegate;
          }
        }
        t2.ProxyTracer = ProxyTracer;
      }, 846: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.ProxyTracerProvider = void 0;
        const n = r2(125);
        const a = r2(124);
        const o = new a.NoopTracerProvider();
        class ProxyTracerProvider {
          getTracer(e3, t3, r3) {
            var a2;
            return (a2 = this.getDelegateTracer(e3, t3, r3)) !== null && a2 !== void 0 ? a2 : new n.ProxyTracer(this, e3, t3, r3);
          }
          getDelegate() {
            var e3;
            return (e3 = this._delegate) !== null && e3 !== void 0 ? e3 : o;
          }
          setDelegate(e3) {
            this._delegate = e3;
          }
          getDelegateTracer(e3, t3, r3) {
            var n2;
            return (n2 = this._delegate) === null || n2 === void 0 ? void 0 : n2.getTracer(e3, t3, r3);
          }
        }
        t2.ProxyTracerProvider = ProxyTracerProvider;
      }, 996: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.SamplingDecision = void 0;
        var r2;
        (function(e3) {
          e3[e3["NOT_RECORD"] = 0] = "NOT_RECORD";
          e3[e3["RECORD"] = 1] = "RECORD";
          e3[e3["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
        })(r2 = t2.SamplingDecision || (t2.SamplingDecision = {}));
      }, 607: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.getSpanContext = t2.setSpanContext = t2.deleteSpan = t2.setSpan = t2.getActiveSpan = t2.getSpan = void 0;
        const n = r2(780);
        const a = r2(403);
        const o = r2(491);
        const i = (0, n.createContextKey)("OpenTelemetry Context Key SPAN");
        function getSpan(e3) {
          return e3.getValue(i) || void 0;
        }
        t2.getSpan = getSpan;
        function getActiveSpan() {
          return getSpan(o.ContextAPI.getInstance().active());
        }
        t2.getActiveSpan = getActiveSpan;
        function setSpan(e3, t3) {
          return e3.setValue(i, t3);
        }
        t2.setSpan = setSpan;
        function deleteSpan(e3) {
          return e3.deleteValue(i);
        }
        t2.deleteSpan = deleteSpan;
        function setSpanContext(e3, t3) {
          return setSpan(e3, new a.NonRecordingSpan(t3));
        }
        t2.setSpanContext = setSpanContext;
        function getSpanContext(e3) {
          var t3;
          return (t3 = getSpan(e3)) === null || t3 === void 0 ? void 0 : t3.spanContext();
        }
        t2.getSpanContext = getSpanContext;
      }, 325: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.TraceStateImpl = void 0;
        const n = r2(564);
        const a = 32;
        const o = 512;
        const i = ",";
        const c = "=";
        class TraceStateImpl {
          constructor(e3) {
            this._internalState = /* @__PURE__ */ new Map();
            if (e3)
              this._parse(e3);
          }
          set(e3, t3) {
            const r3 = this._clone();
            if (r3._internalState.has(e3)) {
              r3._internalState.delete(e3);
            }
            r3._internalState.set(e3, t3);
            return r3;
          }
          unset(e3) {
            const t3 = this._clone();
            t3._internalState.delete(e3);
            return t3;
          }
          get(e3) {
            return this._internalState.get(e3);
          }
          serialize() {
            return this._keys().reduce((e3, t3) => {
              e3.push(t3 + c + this.get(t3));
              return e3;
            }, []).join(i);
          }
          _parse(e3) {
            if (e3.length > o)
              return;
            this._internalState = e3.split(i).reverse().reduce((e4, t3) => {
              const r3 = t3.trim();
              const a2 = r3.indexOf(c);
              if (a2 !== -1) {
                const o2 = r3.slice(0, a2);
                const i2 = r3.slice(a2 + 1, t3.length);
                if ((0, n.validateKey)(o2) && (0, n.validateValue)(i2)) {
                  e4.set(o2, i2);
                } else {
                }
              }
              return e4;
            }, /* @__PURE__ */ new Map());
            if (this._internalState.size > a) {
              this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, a));
            }
          }
          _keys() {
            return Array.from(this._internalState.keys()).reverse();
          }
          _clone() {
            const e3 = new TraceStateImpl();
            e3._internalState = new Map(this._internalState);
            return e3;
          }
        }
        t2.TraceStateImpl = TraceStateImpl;
      }, 564: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.validateValue = t2.validateKey = void 0;
        const r2 = "[_0-9a-z-*/]";
        const n = `[a-z]${r2}{0,255}`;
        const a = `[a-z0-9]${r2}{0,240}@[a-z]${r2}{0,13}`;
        const o = new RegExp(`^(?:${n}|${a})$`);
        const i = /^[ -~]{0,255}[!-~]$/;
        const c = /,|=/;
        function validateKey(e3) {
          return o.test(e3);
        }
        t2.validateKey = validateKey;
        function validateValue(e3) {
          return i.test(e3) && !c.test(e3);
        }
        t2.validateValue = validateValue;
      }, 98: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.createTraceState = void 0;
        const n = r2(325);
        function createTraceState(e3) {
          return new n.TraceStateImpl(e3);
        }
        t2.createTraceState = createTraceState;
      }, 476: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.INVALID_SPAN_CONTEXT = t2.INVALID_TRACEID = t2.INVALID_SPANID = void 0;
        const n = r2(475);
        t2.INVALID_SPANID = "0000000000000000";
        t2.INVALID_TRACEID = "00000000000000000000000000000000";
        t2.INVALID_SPAN_CONTEXT = { traceId: t2.INVALID_TRACEID, spanId: t2.INVALID_SPANID, traceFlags: n.TraceFlags.NONE };
      }, 357: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.SpanKind = void 0;
        var r2;
        (function(e3) {
          e3[e3["INTERNAL"] = 0] = "INTERNAL";
          e3[e3["SERVER"] = 1] = "SERVER";
          e3[e3["CLIENT"] = 2] = "CLIENT";
          e3[e3["PRODUCER"] = 3] = "PRODUCER";
          e3[e3["CONSUMER"] = 4] = "CONSUMER";
        })(r2 = t2.SpanKind || (t2.SpanKind = {}));
      }, 139: (e2, t2, r2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.wrapSpanContext = t2.isSpanContextValid = t2.isValidSpanId = t2.isValidTraceId = void 0;
        const n = r2(476);
        const a = r2(403);
        const o = /^([0-9a-f]{32})$/i;
        const i = /^[0-9a-f]{16}$/i;
        function isValidTraceId(e3) {
          return o.test(e3) && e3 !== n.INVALID_TRACEID;
        }
        t2.isValidTraceId = isValidTraceId;
        function isValidSpanId(e3) {
          return i.test(e3) && e3 !== n.INVALID_SPANID;
        }
        t2.isValidSpanId = isValidSpanId;
        function isSpanContextValid(e3) {
          return isValidTraceId(e3.traceId) && isValidSpanId(e3.spanId);
        }
        t2.isSpanContextValid = isSpanContextValid;
        function wrapSpanContext(e3) {
          return new a.NonRecordingSpan(e3);
        }
        t2.wrapSpanContext = wrapSpanContext;
      }, 847: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.SpanStatusCode = void 0;
        var r2;
        (function(e3) {
          e3[e3["UNSET"] = 0] = "UNSET";
          e3[e3["OK"] = 1] = "OK";
          e3[e3["ERROR"] = 2] = "ERROR";
        })(r2 = t2.SpanStatusCode || (t2.SpanStatusCode = {}));
      }, 475: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.TraceFlags = void 0;
        var r2;
        (function(e3) {
          e3[e3["NONE"] = 0] = "NONE";
          e3[e3["SAMPLED"] = 1] = "SAMPLED";
        })(r2 = t2.TraceFlags || (t2.TraceFlags = {}));
      }, 521: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.VERSION = void 0;
        t2.VERSION = "1.6.0";
      } };
      var t = {};
      function __nccwpck_require__2(r2) {
        var n = t[r2];
        if (n !== void 0) {
          return n.exports;
        }
        var a = t[r2] = { exports: {} };
        var o = true;
        try {
          e[r2].call(a.exports, a, a.exports, __nccwpck_require__2);
          o = false;
        } finally {
          if (o)
            delete t[r2];
        }
        return a.exports;
      }
      if (typeof __nccwpck_require__2 !== "undefined")
        __nccwpck_require__2.ab = "/";
      var r = {};
      (() => {
        var e2 = r;
        Object.defineProperty(e2, "__esModule", { value: true });
        e2.trace = e2.propagation = e2.metrics = e2.diag = e2.context = e2.INVALID_SPAN_CONTEXT = e2.INVALID_TRACEID = e2.INVALID_SPANID = e2.isValidSpanId = e2.isValidTraceId = e2.isSpanContextValid = e2.createTraceState = e2.TraceFlags = e2.SpanStatusCode = e2.SpanKind = e2.SamplingDecision = e2.ProxyTracerProvider = e2.ProxyTracer = e2.defaultTextMapSetter = e2.defaultTextMapGetter = e2.ValueType = e2.createNoopMeter = e2.DiagLogLevel = e2.DiagConsoleLogger = e2.ROOT_CONTEXT = e2.createContextKey = e2.baggageEntryMetadataFromString = void 0;
        var t2 = __nccwpck_require__2(369);
        Object.defineProperty(e2, "baggageEntryMetadataFromString", { enumerable: true, get: function() {
          return t2.baggageEntryMetadataFromString;
        } });
        var n = __nccwpck_require__2(780);
        Object.defineProperty(e2, "createContextKey", { enumerable: true, get: function() {
          return n.createContextKey;
        } });
        Object.defineProperty(e2, "ROOT_CONTEXT", { enumerable: true, get: function() {
          return n.ROOT_CONTEXT;
        } });
        var a = __nccwpck_require__2(972);
        Object.defineProperty(e2, "DiagConsoleLogger", { enumerable: true, get: function() {
          return a.DiagConsoleLogger;
        } });
        var o = __nccwpck_require__2(957);
        Object.defineProperty(e2, "DiagLogLevel", { enumerable: true, get: function() {
          return o.DiagLogLevel;
        } });
        var i = __nccwpck_require__2(102);
        Object.defineProperty(e2, "createNoopMeter", { enumerable: true, get: function() {
          return i.createNoopMeter;
        } });
        var c = __nccwpck_require__2(901);
        Object.defineProperty(e2, "ValueType", { enumerable: true, get: function() {
          return c.ValueType;
        } });
        var s = __nccwpck_require__2(194);
        Object.defineProperty(e2, "defaultTextMapGetter", { enumerable: true, get: function() {
          return s.defaultTextMapGetter;
        } });
        Object.defineProperty(e2, "defaultTextMapSetter", { enumerable: true, get: function() {
          return s.defaultTextMapSetter;
        } });
        var u = __nccwpck_require__2(125);
        Object.defineProperty(e2, "ProxyTracer", { enumerable: true, get: function() {
          return u.ProxyTracer;
        } });
        var l = __nccwpck_require__2(846);
        Object.defineProperty(e2, "ProxyTracerProvider", { enumerable: true, get: function() {
          return l.ProxyTracerProvider;
        } });
        var g = __nccwpck_require__2(996);
        Object.defineProperty(e2, "SamplingDecision", { enumerable: true, get: function() {
          return g.SamplingDecision;
        } });
        var p = __nccwpck_require__2(357);
        Object.defineProperty(e2, "SpanKind", { enumerable: true, get: function() {
          return p.SpanKind;
        } });
        var d = __nccwpck_require__2(847);
        Object.defineProperty(e2, "SpanStatusCode", { enumerable: true, get: function() {
          return d.SpanStatusCode;
        } });
        var _ = __nccwpck_require__2(475);
        Object.defineProperty(e2, "TraceFlags", { enumerable: true, get: function() {
          return _.TraceFlags;
        } });
        var f = __nccwpck_require__2(98);
        Object.defineProperty(e2, "createTraceState", { enumerable: true, get: function() {
          return f.createTraceState;
        } });
        var b = __nccwpck_require__2(139);
        Object.defineProperty(e2, "isSpanContextValid", { enumerable: true, get: function() {
          return b.isSpanContextValid;
        } });
        Object.defineProperty(e2, "isValidTraceId", { enumerable: true, get: function() {
          return b.isValidTraceId;
        } });
        Object.defineProperty(e2, "isValidSpanId", { enumerable: true, get: function() {
          return b.isValidSpanId;
        } });
        var v = __nccwpck_require__2(476);
        Object.defineProperty(e2, "INVALID_SPANID", { enumerable: true, get: function() {
          return v.INVALID_SPANID;
        } });
        Object.defineProperty(e2, "INVALID_TRACEID", { enumerable: true, get: function() {
          return v.INVALID_TRACEID;
        } });
        Object.defineProperty(e2, "INVALID_SPAN_CONTEXT", { enumerable: true, get: function() {
          return v.INVALID_SPAN_CONTEXT;
        } });
        const O = __nccwpck_require__2(67);
        Object.defineProperty(e2, "context", { enumerable: true, get: function() {
          return O.context;
        } });
        const P = __nccwpck_require__2(506);
        Object.defineProperty(e2, "diag", { enumerable: true, get: function() {
          return P.diag;
        } });
        const N = __nccwpck_require__2(886);
        Object.defineProperty(e2, "metrics", { enumerable: true, get: function() {
          return N.metrics;
        } });
        const S = __nccwpck_require__2(939);
        Object.defineProperty(e2, "propagation", { enumerable: true, get: function() {
          return S.propagation;
        } });
        const C = __nccwpck_require__2(845);
        Object.defineProperty(e2, "trace", { enumerable: true, get: function() {
          return C.trace;
        } });
        e2["default"] = { context: O.context, diag: P.diag, metrics: N.metrics, propagation: S.propagation, trace: C.trace };
      })();
      module.exports = r;
    })();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/trace/tracer.js
var require_tracer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/trace/tracer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      BubbledError: function() {
        return BubbledError;
      },
      SpanKind: function() {
        return SpanKind;
      },
      SpanStatusCode: function() {
        return SpanStatusCode;
      },
      getTracer: function() {
        return getTracer;
      },
      isBubbledError: function() {
        return isBubbledError;
      }
    });
    var _constants = require_constants2();
    var _isthenable = require_is_thenable();
    var api;
    if (false) {
      throw new Error("@opentelemetry/api");
    } else {
      try {
        throw new Error("@opentelemetry/api");
      } catch (err) {
        api = require_api();
      }
    }
    var { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } = api;
    var BubbledError = class extends Error {
      constructor(bubble, result) {
        super();
        this.bubble = bubble;
        this.result = result;
      }
    };
    function isBubbledError(error) {
      if (typeof error !== "object" || error === null)
        return false;
      return error instanceof BubbledError;
    }
    var closeSpanWithError = (span, error) => {
      if (isBubbledError(error) && error.bubble) {
        span.setAttribute("next.bubble", true);
      } else {
        if (error) {
          span.recordException(error);
        }
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error == null ? void 0 : error.message
        });
      }
      span.end();
    };
    var rootSpanAttributesStore = /* @__PURE__ */ new Map();
    var rootSpanIdKey = api.createContextKey("next.rootSpanId");
    var lastSpanId = 0;
    var getSpanId = () => lastSpanId++;
    var clientTraceDataSetter = {
      set(carrier, key, value) {
        carrier.push({
          key,
          value
        });
      }
    };
    var NextTracerImpl = class {
      /**
      * Returns an instance to the trace with configured name.
      * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,
      * This should be lazily evaluated.
      */
      getTracerInstance() {
        return trace.getTracer("next.js", "0.0.1");
      }
      getContext() {
        return context;
      }
      getTracePropagationData() {
        const activeContext = context.active();
        const entries = [];
        propagation.inject(activeContext, entries, clientTraceDataSetter);
        return entries;
      }
      getActiveScopeSpan() {
        return trace.getSpan(context == null ? void 0 : context.active());
      }
      withPropagatedContext(carrier, fn, getter) {
        const activeContext = context.active();
        if (trace.getSpanContext(activeContext)) {
          return fn();
        }
        const remoteContext = propagation.extract(activeContext, carrier, getter);
        return context.with(remoteContext, fn);
      }
      trace(...args) {
        var _trace_getSpanContext;
        const [type, fnOrOptions, fnOrEmpty] = args;
        const { fn, options } = typeof fnOrOptions === "function" ? {
          fn: fnOrOptions,
          options: {}
        } : {
          fn: fnOrEmpty,
          options: {
            ...fnOrOptions
          }
        };
        const spanName = options.spanName ?? type;
        if (!_constants.NextVanillaSpanAllowlist.includes(type) && process.env.NEXT_OTEL_VERBOSE !== "1" || options.hideSpan) {
          return fn();
        }
        let spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        let isRootSpan = false;
        if (!spanContext) {
          spanContext = (context == null ? void 0 : context.active()) ?? ROOT_CONTEXT;
          isRootSpan = true;
        } else if ((_trace_getSpanContext = trace.getSpanContext(spanContext)) == null ? void 0 : _trace_getSpanContext.isRemote) {
          isRootSpan = true;
        }
        const spanId = getSpanId();
        options.attributes = {
          "next.span_name": spanName,
          "next.span_type": type,
          ...options.attributes
        };
        return context.with(spanContext.setValue(rootSpanIdKey, spanId), () => this.getTracerInstance().startActiveSpan(spanName, options, (span) => {
          const startTime = "performance" in globalThis && "measure" in performance ? globalThis.performance.now() : void 0;
          const onCleanup = () => {
            rootSpanAttributesStore.delete(spanId);
            if (startTime && process.env.NEXT_OTEL_PERFORMANCE_PREFIX && _constants.LogSpanAllowList.includes(type || "")) {
              performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(type.split(".").pop() || "").replace(/[A-Z]/g, (match) => "-" + match.toLowerCase())}`, {
                start: startTime,
                end: performance.now()
              });
            }
          };
          if (isRootSpan) {
            rootSpanAttributesStore.set(spanId, new Map(Object.entries(options.attributes ?? {})));
          }
          try {
            if (fn.length > 1) {
              return fn(span, (err) => closeSpanWithError(span, err));
            }
            const result = fn(span);
            if ((0, _isthenable.isThenable)(result)) {
              return result.then((res) => {
                span.end();
                return res;
              }).catch((err) => {
                closeSpanWithError(span, err);
                throw err;
              }).finally(onCleanup);
            } else {
              span.end();
              onCleanup();
            }
            return result;
          } catch (err) {
            closeSpanWithError(span, err);
            onCleanup();
            throw err;
          }
        }));
      }
      wrap(...args) {
        const tracer = this;
        const [name, options, fn] = args.length === 3 ? args : [
          args[0],
          {},
          args[1]
        ];
        if (!_constants.NextVanillaSpanAllowlist.includes(name) && process.env.NEXT_OTEL_VERBOSE !== "1") {
          return fn;
        }
        return function() {
          let optionsObj = options;
          if (typeof optionsObj === "function" && typeof fn === "function") {
            optionsObj = optionsObj.apply(this, arguments);
          }
          const lastArgId = arguments.length - 1;
          const cb = arguments[lastArgId];
          if (typeof cb === "function") {
            const scopeBoundCb = tracer.getContext().bind(context.active(), cb);
            return tracer.trace(name, optionsObj, (_span, done) => {
              arguments[lastArgId] = function(err) {
                done == null ? void 0 : done(err);
                return scopeBoundCb.apply(this, arguments);
              };
              return fn.apply(this, arguments);
            });
          } else {
            return tracer.trace(name, optionsObj, () => fn.apply(this, arguments));
          }
        };
      }
      startSpan(...args) {
        const [type, options] = args;
        const spanContext = this.getSpanContext((options == null ? void 0 : options.parentSpan) ?? this.getActiveScopeSpan());
        return this.getTracerInstance().startSpan(type, options, spanContext);
      }
      getSpanContext(parentSpan) {
        const spanContext = parentSpan ? trace.setSpan(context.active(), parentSpan) : void 0;
        return spanContext;
      }
      getRootSpanAttributes() {
        const spanId = context.active().getValue(rootSpanIdKey);
        return rootSpanAttributesStore.get(spanId);
      }
      setRootSpanAttribute(key, value) {
        const spanId = context.active().getValue(rootSpanIdKey);
        const attributes = rootSpanAttributesStore.get(spanId);
        if (attributes) {
          attributes.set(key, value);
        }
      }
    };
    var getTracer = (() => {
      const tracer = new NextTracerImpl();
      return () => tracer;
    })();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/compiled/cookie/index.js
var require_cookie = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/compiled/cookie/index.js"(exports, module) {
    (() => {
      "use strict";
      if (typeof __nccwpck_require__ !== "undefined")
        __nccwpck_require__.ab = "/";
      var e = {};
      (() => {
        var r = e;
        r.parse = parse;
        r.serialize = serialize;
        var i = decodeURIComponent;
        var t = encodeURIComponent;
        var a = /; */;
        var n = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
        function parse(e2, r2) {
          if (typeof e2 !== "string") {
            throw new TypeError("argument str must be a string");
          }
          var t2 = {};
          var n2 = r2 || {};
          var o = e2.split(a);
          var s = n2.decode || i;
          for (var p = 0; p < o.length; p++) {
            var f = o[p];
            var u = f.indexOf("=");
            if (u < 0) {
              continue;
            }
            var v = f.substr(0, u).trim();
            var c = f.substr(++u, f.length).trim();
            if ('"' == c[0]) {
              c = c.slice(1, -1);
            }
            if (void 0 == t2[v]) {
              t2[v] = tryDecode(c, s);
            }
          }
          return t2;
        }
        function serialize(e2, r2, i2) {
          var a2 = i2 || {};
          var o = a2.encode || t;
          if (typeof o !== "function") {
            throw new TypeError("option encode is invalid");
          }
          if (!n.test(e2)) {
            throw new TypeError("argument name is invalid");
          }
          var s = o(r2);
          if (s && !n.test(s)) {
            throw new TypeError("argument val is invalid");
          }
          var p = e2 + "=" + s;
          if (null != a2.maxAge) {
            var f = a2.maxAge - 0;
            if (isNaN(f) || !isFinite(f)) {
              throw new TypeError("option maxAge is invalid");
            }
            p += "; Max-Age=" + Math.floor(f);
          }
          if (a2.domain) {
            if (!n.test(a2.domain)) {
              throw new TypeError("option domain is invalid");
            }
            p += "; Domain=" + a2.domain;
          }
          if (a2.path) {
            if (!n.test(a2.path)) {
              throw new TypeError("option path is invalid");
            }
            p += "; Path=" + a2.path;
          }
          if (a2.expires) {
            if (typeof a2.expires.toUTCString !== "function") {
              throw new TypeError("option expires is invalid");
            }
            p += "; Expires=" + a2.expires.toUTCString();
          }
          if (a2.httpOnly) {
            p += "; HttpOnly";
          }
          if (a2.secure) {
            p += "; Secure";
          }
          if (a2.sameSite) {
            var u = typeof a2.sameSite === "string" ? a2.sameSite.toLowerCase() : a2.sameSite;
            switch (u) {
              case true:
                p += "; SameSite=Strict";
                break;
              case "lax":
                p += "; SameSite=Lax";
                break;
              case "strict":
                p += "; SameSite=Strict";
                break;
              case "none":
                p += "; SameSite=None";
                break;
              default:
                throw new TypeError("option sameSite is invalid");
            }
          }
          return p;
        }
        function tryDecode(e2, r2) {
          try {
            return r2(e2);
          } catch (r3) {
            return e2;
          }
        }
      })();
      module.exports = e;
    })();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/api-utils/index.js
var require_api_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/api-utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      ApiError: function() {
        return ApiError;
      },
      COOKIE_NAME_PRERENDER_BYPASS: function() {
        return COOKIE_NAME_PRERENDER_BYPASS;
      },
      COOKIE_NAME_PRERENDER_DATA: function() {
        return COOKIE_NAME_PRERENDER_DATA;
      },
      RESPONSE_LIMIT_DEFAULT: function() {
        return RESPONSE_LIMIT_DEFAULT;
      },
      SYMBOL_CLEARED_COOKIES: function() {
        return SYMBOL_CLEARED_COOKIES;
      },
      SYMBOL_PREVIEW_DATA: function() {
        return SYMBOL_PREVIEW_DATA;
      },
      checkIsOnDemandRevalidate: function() {
        return checkIsOnDemandRevalidate;
      },
      clearPreviewData: function() {
        return clearPreviewData;
      },
      redirect: function() {
        return redirect;
      },
      sendError: function() {
        return sendError;
      },
      sendStatusCode: function() {
        return sendStatusCode;
      },
      setLazyProp: function() {
        return setLazyProp;
      },
      wrapApiHandler: function() {
        return wrapApiHandler;
      }
    });
    var _headers = require_headers();
    var _constants = require_constants();
    var _tracer = require_tracer();
    var _constants1 = require_constants2();
    function wrapApiHandler(page, handler) {
      return (...args) => {
        (0, _tracer.getTracer)().setRootSpanAttribute("next.route", page);
        return (0, _tracer.getTracer)().trace(_constants1.NodeSpan.runHandler, {
          spanName: `executing api route (pages) ${page}`
        }, () => handler(...args));
      };
    }
    function sendStatusCode(res, statusCode) {
      res.statusCode = statusCode;
      return res;
    }
    function redirect(res, statusOrUrl, url) {
      if (typeof statusOrUrl === "string") {
        url = statusOrUrl;
        statusOrUrl = 307;
      }
      if (typeof statusOrUrl !== "number" || typeof url !== "string") {
        throw new Error(`Invalid redirect arguments. Please use a single argument URL, e.g. res.redirect('/destination') or use a status code and URL, e.g. res.redirect(307, '/destination').`);
      }
      res.writeHead(statusOrUrl, {
        Location: url
      });
      res.write(url);
      res.end();
      return res;
    }
    function checkIsOnDemandRevalidate(req, previewProps) {
      const headers = _headers.HeadersAdapter.from(req.headers);
      const previewModeId = headers.get(_constants.PRERENDER_REVALIDATE_HEADER);
      const isOnDemandRevalidate = previewModeId === previewProps.previewModeId;
      const revalidateOnlyGenerated = headers.has(_constants.PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER);
      return {
        isOnDemandRevalidate,
        revalidateOnlyGenerated
      };
    }
    var COOKIE_NAME_PRERENDER_BYPASS = `__prerender_bypass`;
    var COOKIE_NAME_PRERENDER_DATA = `__next_preview_data`;
    var RESPONSE_LIMIT_DEFAULT = 4 * 1024 * 1024;
    var SYMBOL_PREVIEW_DATA = Symbol(COOKIE_NAME_PRERENDER_DATA);
    var SYMBOL_CLEARED_COOKIES = Symbol(COOKIE_NAME_PRERENDER_BYPASS);
    function clearPreviewData(res, options = {}) {
      if (SYMBOL_CLEARED_COOKIES in res) {
        return res;
      }
      const { serialize } = require_cookie();
      const previous = res.getHeader("Set-Cookie");
      res.setHeader(`Set-Cookie`, [
        ...typeof previous === "string" ? [
          previous
        ] : Array.isArray(previous) ? previous : [],
        serialize(COOKIE_NAME_PRERENDER_BYPASS, "", {
          // To delete a cookie, set `expires` to a date in the past:
          // https://tools.ietf.org/html/rfc6265#section-4.1.1
          // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
          expires: /* @__PURE__ */ new Date(0),
          httpOnly: true,
          sameSite: true ? "none" : "lax",
          secure: true,
          path: "/",
          ...options.path !== void 0 ? {
            path: options.path
          } : void 0
        }),
        serialize(COOKIE_NAME_PRERENDER_DATA, "", {
          // To delete a cookie, set `expires` to a date in the past:
          // https://tools.ietf.org/html/rfc6265#section-4.1.1
          // `Max-Age: 0` is not valid, thus ignored, and the cookie is persisted.
          expires: /* @__PURE__ */ new Date(0),
          httpOnly: true,
          sameSite: true ? "none" : "lax",
          secure: true,
          path: "/",
          ...options.path !== void 0 ? {
            path: options.path
          } : void 0
        })
      ]);
      Object.defineProperty(res, SYMBOL_CLEARED_COOKIES, {
        value: true,
        enumerable: false
      });
      return res;
    }
    var ApiError = class extends Error {
      constructor(statusCode, message) {
        super(message);
        this.statusCode = statusCode;
      }
    };
    function sendError(res, statusCode, message) {
      res.statusCode = statusCode;
      res.statusMessage = message;
      res.end(message);
    }
    function setLazyProp({ req }, prop, getter) {
      const opts = {
        configurable: true,
        enumerable: true
      };
      const optsReset = {
        ...opts,
        writable: true
      };
      Object.defineProperty(req, prop, {
        ...opts,
        get: () => {
          const value = getter();
          Object.defineProperty(req, prop, {
            ...optsReset,
            value
          });
          return value;
        },
        set: (value) => {
          Object.defineProperty(req, prop, {
            ...optsReset,
            value
          });
        }
      });
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/request-meta.js
var require_request_meta = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/request-meta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      NEXT_REQUEST_META: function() {
        return NEXT_REQUEST_META;
      },
      addRequestMeta: function() {
        return addRequestMeta;
      },
      getNextInternalQuery: function() {
        return getNextInternalQuery;
      },
      getRequestMeta: function() {
        return getRequestMeta;
      },
      removeRequestMeta: function() {
        return removeRequestMeta;
      },
      setRequestMeta: function() {
        return setRequestMeta;
      }
    });
    var NEXT_REQUEST_META = Symbol.for("NextInternalRequestMeta");
    function getRequestMeta(req, key) {
      const meta = req[NEXT_REQUEST_META] || {};
      return typeof key === "string" ? meta[key] : meta;
    }
    function setRequestMeta(req, meta) {
      req[NEXT_REQUEST_META] = meta;
      return meta;
    }
    function addRequestMeta(request, key, value) {
      const meta = getRequestMeta(request);
      meta[key] = value;
      return setRequestMeta(request, meta);
    }
    function removeRequestMeta(request, key) {
      const meta = getRequestMeta(request);
      delete meta[key];
      return setRequestMeta(request, meta);
    }
    function getNextInternalQuery(query) {
      const keysToInclude = [
        "__nextDefaultLocale",
        "__nextFallback",
        "__nextLocale",
        "__nextSsgPath",
        "_nextBubbleNoFallback",
        "__nextDataReq",
        "__nextInferredLocaleFromDefault"
      ];
      const nextInternalQuery = {};
      for (const key of keysToInclude) {
        if (key in query) {
          nextInternalQuery[key] = query[key];
        }
      }
      return nextInternalQuery;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/client/components/redirect-status-code.js
var require_redirect_status_code = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/client/components/redirect-status-code.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "RedirectStatusCode", {
      enumerable: true,
      get: function() {
        return RedirectStatusCode;
      }
    });
    var RedirectStatusCode;
    (function(RedirectStatusCode2) {
      RedirectStatusCode2[RedirectStatusCode2["SeeOther"] = 303] = "SeeOther";
      RedirectStatusCode2[RedirectStatusCode2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      RedirectStatusCode2[RedirectStatusCode2["PermanentRedirect"] = 308] = "PermanentRedirect";
    })(RedirectStatusCode || (RedirectStatusCode = {}));
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/api-utils/get-cookie-parser.js
var require_get_cookie_parser = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/api-utils/get-cookie-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getCookieParser", {
      enumerable: true,
      get: function() {
        return getCookieParser;
      }
    });
    function getCookieParser(headers) {
      return function parseCookie() {
        const { cookie } = headers;
        if (!cookie) {
          return {};
        }
        const { parse: parseCookieFn } = require_cookie();
        return parseCookieFn(Array.isArray(cookie) ? cookie.join("; ") : cookie);
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/base-http/index.js
var require_base_http = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/base-http/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      BaseNextRequest: function() {
        return BaseNextRequest;
      },
      BaseNextResponse: function() {
        return BaseNextResponse;
      }
    });
    var _redirectstatuscode = require_redirect_status_code();
    var _getcookieparser = require_get_cookie_parser();
    var BaseNextRequest = class {
      constructor(method, url, body) {
        this.method = method;
        this.url = url;
        this.body = body;
      }
      // Utils implemented using the abstract methods above
      get cookies() {
        if (this._cookies)
          return this._cookies;
        return this._cookies = (0, _getcookieparser.getCookieParser)(this.headers)();
      }
    };
    var BaseNextResponse = class {
      constructor(destination) {
        this.destination = destination;
      }
      // Utils implemented using the abstract methods above
      redirect(destination, statusCode) {
        this.setHeader("Location", destination);
        this.statusCode = statusCode;
        if (statusCode === _redirectstatuscode.RedirectStatusCode.PermanentRedirect) {
          this.setHeader("Refresh", `0;url=${destination}`);
        }
        return this;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/base-http/node.js
var require_node = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/base-http/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      NodeNextRequest: function() {
        return NodeNextRequest2;
      },
      NodeNextResponse: function() {
        return NodeNextResponse2;
      }
    });
    var _apiutils = require_api_utils();
    var _requestmeta = require_request_meta();
    var _index = require_base_http();
    var _NEXT_REQUEST_META = _requestmeta.NEXT_REQUEST_META;
    var NodeNextRequest2 = class extends _index.BaseNextRequest {
      constructor(_req) {
        var _this__req;
        super(_req.method.toUpperCase(), _req.url, _req);
        this._req = _req;
        this.headers = this._req.headers;
        this.fetchMetrics = (_this__req = this._req) == null ? void 0 : _this__req.fetchMetrics;
        this[_NEXT_REQUEST_META] = this._req[_requestmeta.NEXT_REQUEST_META] || {};
        this.streaming = false;
      }
      get originalRequest() {
        this._req[_requestmeta.NEXT_REQUEST_META] = this[_requestmeta.NEXT_REQUEST_META];
        this._req.url = this.url;
        this._req.cookies = this.cookies;
        return this._req;
      }
      set originalRequest(value) {
        this._req = value;
      }
      /**
      * Returns the request body as a Web Readable Stream. The body here can only
      * be read once as the body will start flowing as soon as the data handler
      * is attached.
      *
      * @internal
      */
      stream() {
        if (this.streaming) {
          throw new Error("Invariant: NodeNextRequest.stream() can only be called once");
        }
        this.streaming = true;
        return new ReadableStream({
          start: (controller) => {
            this._req.on("data", (chunk) => {
              controller.enqueue(new Uint8Array(chunk));
            });
            this._req.on("end", () => {
              controller.close();
            });
            this._req.on("error", (err) => {
              controller.error(err);
            });
          }
        });
      }
    };
    var NodeNextResponse2 = class extends _index.BaseNextResponse {
      get originalResponse() {
        if (_apiutils.SYMBOL_CLEARED_COOKIES in this) {
          this._res[_apiutils.SYMBOL_CLEARED_COOKIES] = this[_apiutils.SYMBOL_CLEARED_COOKIES];
        }
        return this._res;
      }
      constructor(_res) {
        super(_res);
        this._res = _res;
        this.textBody = void 0;
      }
      get sent() {
        return this._res.finished || this._res.headersSent;
      }
      get statusCode() {
        return this._res.statusCode;
      }
      set statusCode(value) {
        this._res.statusCode = value;
      }
      get statusMessage() {
        return this._res.statusMessage;
      }
      set statusMessage(value) {
        this._res.statusMessage = value;
      }
      setHeader(name, value) {
        this._res.setHeader(name, value);
        return this;
      }
      removeHeader(name) {
        this._res.removeHeader(name);
        return this;
      }
      getHeaderValues(name) {
        const values = this._res.getHeader(name);
        if (values === void 0)
          return void 0;
        return (Array.isArray(values) ? values : [
          values
        ]).map((value) => value.toString());
      }
      hasHeader(name) {
        return this._res.hasHeader(name);
      }
      getHeader(name) {
        const values = this.getHeaderValues(name);
        return Array.isArray(values) ? values.join(",") : void 0;
      }
      getHeaders() {
        return this._res.getHeaders();
      }
      appendHeader(name, value) {
        const currentValues = this.getHeaderValues(name) ?? [];
        if (!currentValues.includes(value)) {
          this._res.setHeader(name, [
            ...currentValues,
            value
          ]);
        }
        return this;
      }
      body(value) {
        this.textBody = value;
        return this;
      }
      send() {
        this._res.end(this.textBody);
      }
      onClose(callback) {
        this.originalResponse.on("close", callback);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/utils.js
var require_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      fromNodeOutgoingHttpHeaders: function() {
        return fromNodeOutgoingHttpHeaders;
      },
      normalizeNextQueryParam: function() {
        return normalizeNextQueryParam;
      },
      splitCookiesString: function() {
        return splitCookiesString;
      },
      toNodeOutgoingHttpHeaders: function() {
        return toNodeOutgoingHttpHeaders;
      },
      validateURL: function() {
        return validateURL;
      }
    });
    var _constants = require_constants();
    function fromNodeOutgoingHttpHeaders(nodeHeaders) {
      const headers = new Headers();
      for (let [key, value] of Object.entries(nodeHeaders)) {
        const values = Array.isArray(value) ? value : [
          value
        ];
        for (let v of values) {
          if (typeof v === "undefined")
            continue;
          if (typeof v === "number") {
            v = v.toString();
          }
          headers.append(key, v);
        }
      }
      return headers;
    }
    function splitCookiesString(cookiesString) {
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    function toNodeOutgoingHttpHeaders(headers) {
      const nodeHeaders = {};
      const cookies = [];
      if (headers) {
        for (const [key, value] of headers.entries()) {
          if (key.toLowerCase() === "set-cookie") {
            cookies.push(...splitCookiesString(value));
            nodeHeaders[key] = cookies.length === 1 ? cookies[0] : cookies;
          } else {
            nodeHeaders[key] = value;
          }
        }
      }
      return nodeHeaders;
    }
    function validateURL(url) {
      try {
        return String(new URL(String(url)));
      } catch (error) {
        throw new Error(`URL is malformed "${String(url)}". Please use only absolute URLs - https://nextjs.org/docs/messages/middleware-relative-urls`, {
          cause: error
        });
      }
    }
    function normalizeNextQueryParam(key, onKeyNormalized) {
      const prefixes = [
        _constants.NEXT_QUERY_PARAM_PREFIX,
        _constants.NEXT_INTERCEPTION_MARKER_PREFIX
      ];
      for (const prefix of prefixes) {
        if (key !== prefix && key.startsWith(prefix)) {
          const normalizedKey = key.substring(prefix.length);
          onKeyNormalized(normalizedKey);
        }
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/mock-request.js
var require_mock_request = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/mock-request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      MockedRequest: function() {
        return MockedRequest;
      },
      MockedResponse: function() {
        return MockedResponse2;
      },
      createRequestResponseMocks: function() {
        return createRequestResponseMocks;
      }
    });
    var _stream = /* @__PURE__ */ _interop_require_default(require("stream"));
    var _utils = require_utils();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var MockedRequest = class extends _stream.default.Readable {
      constructor({ url, headers, method, socket = null, readable }) {
        super();
        this.httpVersion = "1.0";
        this.httpVersionMajor = 1;
        this.httpVersionMinor = 0;
        this.socket = new Proxy({}, {
          get: (_target, prop) => {
            if (prop !== "encrypted" && prop !== "remoteAddress") {
              throw new Error("Method not implemented");
            }
            if (prop === "remoteAddress")
              return void 0;
            return false;
          }
        });
        this.url = url;
        this.headers = headers;
        this.method = method;
        if (readable) {
          this.bodyReadable = readable;
          this.bodyReadable.on("end", () => this.emit("end"));
          this.bodyReadable.on("close", () => this.emit("close"));
        }
        if (socket) {
          this.socket = socket;
        }
      }
      get headersDistinct() {
        const headers = {};
        for (const [key, value] of Object.entries(this.headers)) {
          if (!value)
            continue;
          headers[key] = Array.isArray(value) ? value : [
            value
          ];
        }
        return headers;
      }
      _read(size) {
        if (this.bodyReadable) {
          return this.bodyReadable._read(size);
        } else {
          this.emit("end");
          this.emit("close");
        }
      }
      /**
      * The `connection` property is just an alias for the `socket` property.
      *
      * @deprecated  since v13.0.0 - Use socket instead.
      */
      get connection() {
        return this.socket;
      }
      // The following methods are not implemented as they are not used in the
      // Next.js codebase.
      get aborted() {
        throw new Error("Method not implemented");
      }
      get complete() {
        throw new Error("Method not implemented");
      }
      get trailers() {
        throw new Error("Method not implemented");
      }
      get trailersDistinct() {
        throw new Error("Method not implemented");
      }
      get rawTrailers() {
        throw new Error("Method not implemented");
      }
      get rawHeaders() {
        throw new Error("Method not implemented.");
      }
      setTimeout() {
        throw new Error("Method not implemented.");
      }
    };
    var MockedResponse2 = class extends _stream.default.Writable {
      constructor(res = {}) {
        super();
        this.statusMessage = "";
        this.finished = false;
        this.headersSent = false;
        this.buffers = [];
        this.statusCode = res.statusCode ?? 200;
        this.socket = res.socket ?? null;
        this.headers = res.headers ? (0, _utils.fromNodeOutgoingHttpHeaders)(res.headers) : new Headers();
        this.headPromise = new Promise((resolve) => {
          this.headPromiseResolve = resolve;
        });
        this.hasStreamed = new Promise((resolve, reject) => {
          this.on("finish", () => resolve(true));
          this.on("end", () => resolve(true));
          this.on("error", (err) => reject(err));
        }).then((val) => {
          this.headPromiseResolve == null ? void 0 : this.headPromiseResolve.call(this);
          return val;
        });
        if (res.resWriter) {
          this.resWriter = res.resWriter;
        }
      }
      appendHeader(name, value) {
        const values = Array.isArray(value) ? value : [
          value
        ];
        for (const v of values) {
          this.headers.append(name, v);
        }
        return this;
      }
      /**
      * Returns true if the response has been sent, false otherwise.
      *
      * @internal - used internally by Next.js
      */
      get isSent() {
        return this.finished || this.headersSent;
      }
      /**
      * The `connection` property is just an alias for the `socket` property.
      *
      * @deprecated  since v13.0.0 - Use socket instead.
      */
      get connection() {
        return this.socket;
      }
      write(chunk) {
        if (this.resWriter) {
          return this.resWriter(chunk);
        }
        this.buffers.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
        return true;
      }
      end() {
        this.finished = true;
        return super.end(...arguments);
      }
      /**
      * This method is a no-op because the `MockedResponse` instance is not
      * actually connected to a socket. This method is not specified on the
      * interface type for `ServerResponse` but is called by Node.js.
      *
      * @see https://github.com/nodejs/node/pull/7949
      */
      _implicitHeader() {
      }
      _write(chunk, _encoding, callback) {
        this.write(chunk);
        callback();
      }
      writeHead(statusCode, statusMessage, headers) {
        if (!headers && typeof statusMessage !== "string") {
          headers = statusMessage;
        } else if (typeof statusMessage === "string" && statusMessage.length > 0) {
          this.statusMessage = statusMessage;
        }
        if (headers) {
          if (Array.isArray(headers)) {
            for (let i = 0; i < headers.length; i += 2) {
              this.setHeader(headers[i], headers[i + 1]);
            }
          } else {
            for (const [key, value] of Object.entries(headers)) {
              if (typeof value === "undefined")
                continue;
              this.setHeader(key, value);
            }
          }
        }
        this.statusCode = statusCode;
        this.headersSent = true;
        this.headPromiseResolve == null ? void 0 : this.headPromiseResolve.call(this);
        return this;
      }
      hasHeader(name) {
        return this.headers.has(name);
      }
      getHeader(name) {
        return this.headers.get(name) ?? void 0;
      }
      getHeaders() {
        return (0, _utils.toNodeOutgoingHttpHeaders)(this.headers);
      }
      getHeaderNames() {
        return Array.from(this.headers.keys());
      }
      setHeader(name, value) {
        if (Array.isArray(value)) {
          this.headers.delete(name);
          for (const v of value) {
            this.headers.append(name, v);
          }
        } else if (typeof value === "number") {
          this.headers.set(name, value.toString());
        } else {
          this.headers.set(name, value);
        }
        return this;
      }
      removeHeader(name) {
        this.headers.delete(name);
      }
      flushHeaders() {
      }
      // The following methods are not implemented as they are not used in the
      // Next.js codebase.
      get strictContentLength() {
        throw new Error("Method not implemented.");
      }
      writeEarlyHints() {
        throw new Error("Method not implemented.");
      }
      get req() {
        throw new Error("Method not implemented.");
      }
      assignSocket() {
        throw new Error("Method not implemented.");
      }
      detachSocket() {
        throw new Error("Method not implemented.");
      }
      writeContinue() {
        throw new Error("Method not implemented.");
      }
      writeProcessing() {
        throw new Error("Method not implemented.");
      }
      get upgrading() {
        throw new Error("Method not implemented.");
      }
      get chunkedEncoding() {
        throw new Error("Method not implemented.");
      }
      get shouldKeepAlive() {
        throw new Error("Method not implemented.");
      }
      get useChunkedEncodingByDefault() {
        throw new Error("Method not implemented.");
      }
      get sendDate() {
        throw new Error("Method not implemented.");
      }
      setTimeout() {
        throw new Error("Method not implemented.");
      }
      addTrailers() {
        throw new Error("Method not implemented.");
      }
    };
    function createRequestResponseMocks({ url, headers = {}, method = "GET", bodyReadable, resWriter, socket = null }) {
      return {
        req: new MockedRequest({
          url,
          headers,
          method,
          socket,
          readable: bodyReadable
        }),
        res: new MockedResponse2({
          socket,
          resWriter
        })
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/@opennextjs/cloudflare/cli/templates/shims/empty.ts
var empty_exports = {};
__export2(empty_exports, {
  default: () => empty_default
});
var empty_default;
var init_empty = __esm({
  ".worker-next/.next/standalone/node_modules/@opennextjs/cloudflare/cli/templates/shims/empty.ts"() {
    empty_default = {};
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/node-environment-baseline.js
var require_node_environment_baseline = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/node-environment-baseline.js"() {
    "use strict";
    if (typeof globalThis.AsyncLocalStorage !== "function") {
      const { AsyncLocalStorage: AsyncLocalStorage2 } = require("async_hooks");
      globalThis.AsyncLocalStorage = AsyncLocalStorage2;
    }
    if (typeof globalThis.WebSocket !== "function") {
      Object.defineProperty(globalThis, "WebSocket", {
        get() {
          return (init_empty(), __toCommonJS(empty_exports)).WebSocket;
        }
      });
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/async-local-storage.js
var require_async_local_storage = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/async-local-storage.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      bindSnapshot: function() {
        return bindSnapshot;
      },
      createAsyncLocalStorage: function() {
        return createAsyncLocalStorage;
      },
      createSnapshot: function() {
        return createSnapshot;
      }
    });
    var sharedAsyncLocalStorageNotAvailableError = new Error("Invariant: AsyncLocalStorage accessed in runtime where it is not available");
    var FakeAsyncLocalStorage = class {
      disable() {
        throw sharedAsyncLocalStorageNotAvailableError;
      }
      getStore() {
        return void 0;
      }
      run() {
        throw sharedAsyncLocalStorageNotAvailableError;
      }
      exit() {
        throw sharedAsyncLocalStorageNotAvailableError;
      }
      enterWith() {
        throw sharedAsyncLocalStorageNotAvailableError;
      }
      static bind(fn) {
        return fn;
      }
    };
    var maybeGlobalAsyncLocalStorage = typeof globalThis !== "undefined" && globalThis.AsyncLocalStorage;
    function createAsyncLocalStorage() {
      if (maybeGlobalAsyncLocalStorage) {
        return new maybeGlobalAsyncLocalStorage();
      }
      return new FakeAsyncLocalStorage();
    }
    function bindSnapshot(fn) {
      if (maybeGlobalAsyncLocalStorage) {
        return maybeGlobalAsyncLocalStorage.bind(fn);
      }
      return FakeAsyncLocalStorage.bind(fn);
    }
    function createSnapshot() {
      if (maybeGlobalAsyncLocalStorage) {
        return maybeGlobalAsyncLocalStorage.snapshot();
      }
      return function(fn, ...args) {
        return fn(...args);
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/work-async-storage-instance.js
var require_work_async_storage_instance = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/work-async-storage-instance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "workAsyncStorage", {
      enumerable: true,
      get: function() {
        return workAsyncStorage;
      }
    });
    var _asynclocalstorage = require_async_local_storage();
    var workAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/work-async-storage.external.js
var require_work_async_storage_external = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/work-async-storage.external.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "workAsyncStorage", {
      enumerable: true,
      get: function() {
        return _workasyncstorageinstance.workAsyncStorage;
      }
    });
    var _workasyncstorageinstance = require_work_async_storage_instance();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/work-unit-async-storage-instance.js
var require_work_unit_async_storage_instance = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/work-unit-async-storage-instance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "workUnitAsyncStorage", {
      enumerable: true,
      get: function() {
        return workUnitAsyncStorage;
      }
    });
    var _asynclocalstorage = require_async_local_storage();
    var workUnitAsyncStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js
var require_work_unit_async_storage_external = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/work-unit-async-storage.external.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getExpectedRequestStore: function() {
        return getExpectedRequestStore;
      },
      workUnitAsyncStorage: function() {
        return _workunitasyncstorageinstance.workUnitAsyncStorage;
      }
    });
    var _workunitasyncstorageinstance = require_work_unit_async_storage_instance();
    function getExpectedRequestStore(callingExpression) {
      const workUnitStore = _workunitasyncstorageinstance.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        if (workUnitStore.type === "request") {
          return workUnitStore;
        }
        if (workUnitStore.type === "prerender" || workUnitStore.type === "prerender-ppr" || workUnitStore.type === "prerender-legacy") {
          throw new Error(`\`${callingExpression}\` cannot be called inside a prerender. This is a bug in Next.js.`);
        }
        if (workUnitStore.type === "cache") {
          throw new Error(`\`${callingExpression}\` cannot be called inside "use cache". Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/messages/next-request-in-use-cache`);
        } else if (workUnitStore.type === "unstable-cache") {
          throw new Error(`\`${callingExpression}\` cannot be called inside unstable_cache. Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`);
        }
      }
      throw new Error(`\`${callingExpression}\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`);
    }
  }
});

// .worker-next/.next/standalone/node_modules/react/cjs/react.production.js
var require_react_production = __commonJS({
  ".worker-next/.next/standalone/node_modules/react/cjs/react.production.js"(exports) {
    "use strict";
    var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element");
    var REACT_PORTAL_TYPE = Symbol.for("react.portal");
    var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
    var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
    var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
    var REACT_CONSUMER_TYPE = Symbol.for("react.consumer");
    var REACT_CONTEXT_TYPE = Symbol.for("react.context");
    var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
    var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
    var REACT_MEMO_TYPE = Symbol.for("react.memo");
    var REACT_LAZY_TYPE = Symbol.for("react.lazy");
    var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
    function getIteratorFn(maybeIterable) {
      if (null === maybeIterable || "object" !== typeof maybeIterable)
        return null;
      maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
      return "function" === typeof maybeIterable ? maybeIterable : null;
    }
    var ReactNoopUpdateQueue = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    };
    var assign = Object.assign;
    var emptyObject = {};
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    Component.prototype.isReactComponent = {};
    Component.prototype.setState = function(partialState, callback) {
      if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
        throw Error(
          "takes an object of state variables to update or a function which returns an object of state variables."
        );
      this.updater.enqueueSetState(this, partialState, callback, "setState");
    };
    Component.prototype.forceUpdate = function(callback) {
      this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
    };
    function ComponentDummy() {
    }
    ComponentDummy.prototype = Component.prototype;
    function PureComponent(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;
    }
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;
    var isArrayImpl = Array.isArray;
    var ReactSharedInternals = { H: null, A: null, T: null, S: null };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function ReactElement(type, key, _ref, self2, source, owner, props) {
      _ref = props.ref;
      return {
        $$typeof: REACT_ELEMENT_TYPE,
        type,
        key,
        ref: void 0 !== _ref ? _ref : null,
        props
      };
    }
    function cloneAndReplaceKey(oldElement, newKey) {
      return ReactElement(
        oldElement.type,
        newKey,
        null,
        void 0,
        void 0,
        void 0,
        oldElement.props
      );
    }
    function isValidElement(object) {
      return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function escape(key) {
      var escaperLookup = { "=": "=0", ":": "=2" };
      return "$" + key.replace(/[=:]/g, function(match) {
        return escaperLookup[match];
      });
    }
    var userProvidedKeyEscapeRegex = /\/+/g;
    function getElementKey(element, index) {
      return "object" === typeof element && null !== element && null != element.key ? escape("" + element.key) : index.toString(36);
    }
    function noop$1() {
    }
    function resolveThenable(thenable) {
      switch (thenable.status) {
        case "fulfilled":
          return thenable.value;
        case "rejected":
          throw thenable.reason;
        default:
          switch ("string" === typeof thenable.status ? thenable.then(noop$1, noop$1) : (thenable.status = "pending", thenable.then(
            function(fulfilledValue) {
              "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
            },
            function(error) {
              "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error);
            }
          )), thenable.status) {
            case "fulfilled":
              return thenable.value;
            case "rejected":
              throw thenable.reason;
          }
      }
      throw thenable;
    }
    function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
      var type = typeof children;
      if ("undefined" === type || "boolean" === type)
        children = null;
      var invokeCallback = false;
      if (null === children)
        invokeCallback = true;
      else
        switch (type) {
          case "bigint":
          case "string":
          case "number":
            invokeCallback = true;
            break;
          case "object":
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
                break;
              case REACT_LAZY_TYPE:
                return invokeCallback = children._init, mapIntoArray(
                  invokeCallback(children._payload),
                  array,
                  escapedPrefix,
                  nameSoFar,
                  callback
                );
            }
        }
      if (invokeCallback)
        return callback = callback(children), invokeCallback = "" === nameSoFar ? "." + getElementKey(children, 0) : nameSoFar, isArrayImpl(callback) ? (escapedPrefix = "", null != invokeCallback && (escapedPrefix = invokeCallback.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c) {
          return c;
        })) : null != callback && (isValidElement(callback) && (callback = cloneAndReplaceKey(
          callback,
          escapedPrefix + (null == callback.key || children && children.key === callback.key ? "" : ("" + callback.key).replace(
            userProvidedKeyEscapeRegex,
            "$&/"
          ) + "/") + invokeCallback
        )), array.push(callback)), 1;
      invokeCallback = 0;
      var nextNamePrefix = "" === nameSoFar ? "." : nameSoFar + ":";
      if (isArrayImpl(children))
        for (var i = 0; i < children.length; i++)
          nameSoFar = children[i], type = nextNamePrefix + getElementKey(nameSoFar, i), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if (i = getIteratorFn(children), "function" === typeof i)
        for (children = i.call(children), i = 0; !(nameSoFar = children.next()).done; )
          nameSoFar = nameSoFar.value, type = nextNamePrefix + getElementKey(nameSoFar, i++), invokeCallback += mapIntoArray(
            nameSoFar,
            array,
            escapedPrefix,
            type,
            callback
          );
      else if ("object" === type) {
        if ("function" === typeof children.then)
          return mapIntoArray(
            resolveThenable(children),
            array,
            escapedPrefix,
            nameSoFar,
            callback
          );
        array = String(children);
        throw Error(
          "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
        );
      }
      return invokeCallback;
    }
    function mapChildren(children, func, context) {
      if (null == children)
        return children;
      var result = [], count = 0;
      mapIntoArray(children, result, "", "", function(child) {
        return func.call(context, child, count++);
      });
      return result;
    }
    function lazyInitializer(payload) {
      if (-1 === payload._status) {
        var ctor = payload._result;
        ctor = ctor();
        ctor.then(
          function(moduleObject) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 1, payload._result = moduleObject;
          },
          function(error) {
            if (0 === payload._status || -1 === payload._status)
              payload._status = 2, payload._result = error;
          }
        );
        -1 === payload._status && (payload._status = 0, payload._result = ctor);
      }
      if (1 === payload._status)
        return payload._result.default;
      throw payload._result;
    }
    var reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
      if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
        var event = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
          error
        });
        if (!window.dispatchEvent(event))
          return;
      } else if ("object" === typeof process && "function" === typeof process.emit) {
        process.emit("uncaughtException", error);
        return;
      }
      console.error(error);
    };
    function noop() {
    }
    exports.Children = {
      map: mapChildren,
      forEach: function(children, forEachFunc, forEachContext) {
        mapChildren(
          children,
          function() {
            forEachFunc.apply(this, arguments);
          },
          forEachContext
        );
      },
      count: function(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      },
      toArray: function(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      },
      only: function(children) {
        if (!isValidElement(children))
          throw Error(
            "React.Children.only expected to receive a single React element child."
          );
        return children;
      }
    };
    exports.Component = Component;
    exports.Fragment = REACT_FRAGMENT_TYPE;
    exports.Profiler = REACT_PROFILER_TYPE;
    exports.PureComponent = PureComponent;
    exports.StrictMode = REACT_STRICT_MODE_TYPE;
    exports.Suspense = REACT_SUSPENSE_TYPE;
    exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
    exports.act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    exports.cache = function(fn) {
      return function() {
        return fn.apply(null, arguments);
      };
    };
    exports.cloneElement = function(element, config, children) {
      if (null === element || void 0 === element)
        throw Error(
          "The argument must be a React element, but you passed " + element + "."
        );
      var props = assign({}, element.props), key = element.key, owner = void 0;
      if (null != config)
        for (propName in void 0 !== config.ref && (owner = void 0), void 0 !== config.key && (key = "" + config.key), config)
          !hasOwnProperty.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
      var propName = arguments.length - 2;
      if (1 === propName)
        props.children = children;
      else if (1 < propName) {
        for (var childArray = Array(propName), i = 0; i < propName; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      return ReactElement(element.type, key, null, void 0, void 0, owner, props);
    };
    exports.createContext = function(defaultValue) {
      defaultValue = {
        $$typeof: REACT_CONTEXT_TYPE,
        _currentValue: defaultValue,
        _currentValue2: defaultValue,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      };
      defaultValue.Provider = defaultValue;
      defaultValue.Consumer = {
        $$typeof: REACT_CONSUMER_TYPE,
        _context: defaultValue
      };
      return defaultValue;
    };
    exports.createElement = function(type, config, children) {
      var propName, props = {}, key = null;
      if (null != config)
        for (propName in void 0 !== config.key && (key = "" + config.key), config)
          hasOwnProperty.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (props[propName] = config[propName]);
      var childrenLength = arguments.length - 2;
      if (1 === childrenLength)
        props.children = children;
      else if (1 < childrenLength) {
        for (var childArray = Array(childrenLength), i = 0; i < childrenLength; i++)
          childArray[i] = arguments[i + 2];
        props.children = childArray;
      }
      if (type && type.defaultProps)
        for (propName in childrenLength = type.defaultProps, childrenLength)
          void 0 === props[propName] && (props[propName] = childrenLength[propName]);
      return ReactElement(type, key, null, void 0, void 0, null, props);
    };
    exports.createRef = function() {
      return { current: null };
    };
    exports.forwardRef = function(render) {
      return { $$typeof: REACT_FORWARD_REF_TYPE, render };
    };
    exports.isValidElement = isValidElement;
    exports.lazy = function(ctor) {
      return {
        $$typeof: REACT_LAZY_TYPE,
        _payload: { _status: -1, _result: ctor },
        _init: lazyInitializer
      };
    };
    exports.memo = function(type, compare) {
      return {
        $$typeof: REACT_MEMO_TYPE,
        type,
        compare: void 0 === compare ? null : compare
      };
    };
    exports.startTransition = function(scope) {
      var prevTransition = ReactSharedInternals.T, currentTransition = {};
      ReactSharedInternals.T = currentTransition;
      try {
        var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
        "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && returnValue.then(noop, reportGlobalError);
      } catch (error) {
        reportGlobalError(error);
      } finally {
        ReactSharedInternals.T = prevTransition;
      }
    };
    exports.unstable_useCacheRefresh = function() {
      return ReactSharedInternals.H.useCacheRefresh();
    };
    exports.use = function(usable) {
      return ReactSharedInternals.H.use(usable);
    };
    exports.useActionState = function(action, initialState, permalink) {
      return ReactSharedInternals.H.useActionState(action, initialState, permalink);
    };
    exports.useCallback = function(callback, deps) {
      return ReactSharedInternals.H.useCallback(callback, deps);
    };
    exports.useContext = function(Context) {
      return ReactSharedInternals.H.useContext(Context);
    };
    exports.useDebugValue = function() {
    };
    exports.useDeferredValue = function(value, initialValue) {
      return ReactSharedInternals.H.useDeferredValue(value, initialValue);
    };
    exports.useEffect = function(create, deps) {
      return ReactSharedInternals.H.useEffect(create, deps);
    };
    exports.useId = function() {
      return ReactSharedInternals.H.useId();
    };
    exports.useImperativeHandle = function(ref, create, deps) {
      return ReactSharedInternals.H.useImperativeHandle(ref, create, deps);
    };
    exports.useInsertionEffect = function(create, deps) {
      return ReactSharedInternals.H.useInsertionEffect(create, deps);
    };
    exports.useLayoutEffect = function(create, deps) {
      return ReactSharedInternals.H.useLayoutEffect(create, deps);
    };
    exports.useMemo = function(create, deps) {
      return ReactSharedInternals.H.useMemo(create, deps);
    };
    exports.useOptimistic = function(passthrough, reducer) {
      return ReactSharedInternals.H.useOptimistic(passthrough, reducer);
    };
    exports.useReducer = function(reducer, initialArg, init) {
      return ReactSharedInternals.H.useReducer(reducer, initialArg, init);
    };
    exports.useRef = function(initialValue) {
      return ReactSharedInternals.H.useRef(initialValue);
    };
    exports.useState = function(initialState) {
      return ReactSharedInternals.H.useState(initialState);
    };
    exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
      return ReactSharedInternals.H.useSyncExternalStore(
        subscribe,
        getSnapshot,
        getServerSnapshot
      );
    };
    exports.useTransition = function() {
      return ReactSharedInternals.H.useTransition();
    };
    exports.version = "19.0.0-rc-65a56d0e-20241020";
  }
});

// .worker-next/.next/standalone/node_modules/react/index.js
var require_react = __commonJS({
  ".worker-next/.next/standalone/node_modules/react/index.js"(exports, module) {
    "use strict";
    if (true) {
      module.exports = require_react_production();
    } else {
      module.exports = null;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/client/components/hooks-server-context.js
var require_hooks_server_context = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/client/components/hooks-server-context.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      DynamicServerError: function() {
        return DynamicServerError;
      },
      isDynamicServerError: function() {
        return isDynamicServerError;
      }
    });
    var DYNAMIC_ERROR_CODE = "DYNAMIC_SERVER_USAGE";
    var DynamicServerError = class extends Error {
      constructor(description) {
        super("Dynamic server usage: " + description);
        this.description = description;
        this.digest = DYNAMIC_ERROR_CODE;
      }
    };
    function isDynamicServerError(err) {
      if (typeof err !== "object" || err === null || !("digest" in err) || typeof err.digest !== "string") {
        return false;
      }
      return err.digest === DYNAMIC_ERROR_CODE;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/client/components/static-generation-bailout.js
var require_static_generation_bailout = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/client/components/static-generation-bailout.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      StaticGenBailoutError: function() {
        return StaticGenBailoutError;
      },
      isStaticGenBailoutError: function() {
        return isStaticGenBailoutError;
      }
    });
    var NEXT_STATIC_GEN_BAILOUT = "NEXT_STATIC_GEN_BAILOUT";
    var StaticGenBailoutError = class extends Error {
      constructor(...args) {
        super(...args);
        this.code = NEXT_STATIC_GEN_BAILOUT;
      }
    };
    function isStaticGenBailoutError(error) {
      if (typeof error !== "object" || error === null || !("code" in error)) {
        return false;
      }
      return error.code === NEXT_STATIC_GEN_BAILOUT;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/dynamic-rendering-utils.js
var require_dynamic_rendering_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/dynamic-rendering-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "makeHangingPromise", {
      enumerable: true,
      get: function() {
        return makeHangingPromise;
      }
    });
    function makeHangingPromise(signal, expression) {
      const hangingPromise = new Promise((_, reject) => {
        signal.addEventListener("abort", () => {
          reject(new Error(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \`setTimeout\`, \`unstable_after\`, or similar functions you may observe this error and you should handle it in that context.`));
        });
      });
      hangingPromise.catch(() => {
      });
      return hangingPromise;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/metadata/metadata-constants.js
var require_metadata_constants = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/metadata/metadata-constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      METADATA_BOUNDARY_NAME: function() {
        return METADATA_BOUNDARY_NAME;
      },
      OUTLET_BOUNDARY_NAME: function() {
        return OUTLET_BOUNDARY_NAME;
      },
      VIEWPORT_BOUNDARY_NAME: function() {
        return VIEWPORT_BOUNDARY_NAME;
      }
    });
    var METADATA_BOUNDARY_NAME = "__next_metadata_boundary__";
    var VIEWPORT_BOUNDARY_NAME = "__next_viewport_boundary__";
    var OUTLET_BOUNDARY_NAME = "__next_outlet_boundary__";
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/dynamic-rendering.js
var require_dynamic_rendering = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/dynamic-rendering.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      Postpone: function() {
        return Postpone;
      },
      abortAndThrowOnSynchronousRequestDataAccess: function() {
        return abortAndThrowOnSynchronousRequestDataAccess;
      },
      abortOnSynchronousPlatformIOAccess: function() {
        return abortOnSynchronousPlatformIOAccess;
      },
      accessedDynamicData: function() {
        return accessedDynamicData;
      },
      annotateDynamicAccess: function() {
        return annotateDynamicAccess;
      },
      consumeDynamicAccess: function() {
        return consumeDynamicAccess;
      },
      createDynamicTrackingState: function() {
        return createDynamicTrackingState;
      },
      createDynamicValidationState: function() {
        return createDynamicValidationState;
      },
      createPostponedAbortSignal: function() {
        return createPostponedAbortSignal;
      },
      formatDynamicAPIAccesses: function() {
        return formatDynamicAPIAccesses;
      },
      getFirstDynamicReason: function() {
        return getFirstDynamicReason;
      },
      isDynamicPostpone: function() {
        return isDynamicPostpone;
      },
      isPrerenderInterruptedError: function() {
        return isPrerenderInterruptedError;
      },
      markCurrentScopeAsDynamic: function() {
        return markCurrentScopeAsDynamic;
      },
      postponeWithTracking: function() {
        return postponeWithTracking;
      },
      throwIfDisallowedDynamic: function() {
        return throwIfDisallowedDynamic;
      },
      throwToInterruptStaticGeneration: function() {
        return throwToInterruptStaticGeneration;
      },
      trackAllowedDynamicAccess: function() {
        return trackAllowedDynamicAccess;
      },
      trackDynamicDataInDynamicRender: function() {
        return trackDynamicDataInDynamicRender;
      },
      trackFallbackParamAccessed: function() {
        return trackFallbackParamAccessed;
      },
      useDynamicRouteParams: function() {
        return useDynamicRouteParams;
      }
    });
    var _react = /* @__PURE__ */ _interop_require_default(require_react());
    var _hooksservercontext = require_hooks_server_context();
    var _staticgenerationbailout = require_static_generation_bailout();
    var _workunitasyncstorageexternal = require_work_unit_async_storage_external();
    var _workasyncstorageexternal = require_work_async_storage_external();
    var _dynamicrenderingutils = require_dynamic_rendering_utils();
    var _metadataconstants = require_metadata_constants();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var hasPostpone = typeof _react.default.unstable_postpone === "function";
    function createDynamicTrackingState(isDebugDynamicAccesses) {
      return {
        isDebugDynamicAccesses,
        dynamicAccesses: [],
        syncDynamicExpression: void 0,
        syncDynamicErrorWithStack: null
      };
    }
    function createDynamicValidationState() {
      return {
        hasSuspendedDynamic: false,
        hasDynamicMetadata: false,
        hasDynamicViewport: false,
        syncDynamicErrors: [],
        dynamicErrors: []
      };
    }
    function getFirstDynamicReason(trackingState) {
      var _trackingState_dynamicAccesses_;
      return (_trackingState_dynamicAccesses_ = trackingState.dynamicAccesses[0]) == null ? void 0 : _trackingState_dynamicAccesses_.expression;
    }
    function markCurrentScopeAsDynamic(store, workUnitStore, expression) {
      if (workUnitStore) {
        if (workUnitStore.type === "cache" || workUnitStore.type === "unstable-cache") {
          return;
        }
      }
      if (store.forceDynamic || store.forceStatic)
        return;
      if (store.dynamicShouldError) {
        throw new _staticgenerationbailout.StaticGenBailoutError(`Route ${store.route} with \`dynamic = "error"\` couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`);
      }
      if (workUnitStore) {
        if (workUnitStore.type === "prerender-ppr") {
          postponeWithTracking(store.route, expression, workUnitStore.dynamicTracking);
        } else if (workUnitStore.type === "prerender-legacy") {
          workUnitStore.revalidate = 0;
          const err = new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used ${expression}. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
          store.dynamicUsageDescription = expression;
          store.dynamicUsageStack = err.stack;
          throw err;
        } else if (false) {
          workUnitStore.usedDynamic = true;
        }
      }
    }
    function trackFallbackParamAccessed(store, expression) {
      const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (!prerenderStore || prerenderStore.type !== "prerender-ppr")
        return;
      postponeWithTracking(store.route, expression, prerenderStore.dynamicTracking);
    }
    function throwToInterruptStaticGeneration(expression, store, prerenderStore) {
      const err = new _hooksservercontext.DynamicServerError(`Route ${store.route} couldn't be rendered statically because it used \`${expression}\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`);
      prerenderStore.revalidate = 0;
      store.dynamicUsageDescription = expression;
      store.dynamicUsageStack = err.stack;
      throw err;
    }
    function trackDynamicDataInDynamicRender(_store, workUnitStore) {
      if (workUnitStore) {
        if (workUnitStore.type === "cache" || workUnitStore.type === "unstable-cache") {
          return;
        }
        if (workUnitStore.type === "prerender" || workUnitStore.type === "prerender-legacy") {
          workUnitStore.revalidate = 0;
        }
        if (false) {
          workUnitStore.usedDynamic = true;
        }
      }
    }
    function abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore) {
      const reason = `Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`;
      const error = createPrerenderInterruptedError(reason);
      if (prerenderStore.controller) {
        prerenderStore.controller.abort(error);
      }
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          // When we aren't debugging, we don't need to create another error for the
          // stack trace.
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : void 0,
          expression
        });
      }
    }
    function abortOnSynchronousPlatformIOAccess(route, expression, errorWithStack, prerenderStore) {
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
          dynamicTracking.syncDynamicExpression = expression;
          dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
      }
      return abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
    }
    function abortAndThrowOnSynchronousRequestDataAccess(route, expression, errorWithStack, prerenderStore) {
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        if (dynamicTracking.syncDynamicErrorWithStack === null) {
          dynamicTracking.syncDynamicExpression = expression;
          dynamicTracking.syncDynamicErrorWithStack = errorWithStack;
        }
      }
      abortOnSynchronousDynamicDataAccess(route, expression, prerenderStore);
      throw createPrerenderInterruptedError(`Route ${route} needs to bail out of prerendering at this point because it used ${expression}.`);
    }
    function Postpone({ reason, route }) {
      const prerenderStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      const dynamicTracking = prerenderStore && prerenderStore.type === "prerender-ppr" ? prerenderStore.dynamicTracking : null;
      postponeWithTracking(route, reason, dynamicTracking);
    }
    function postponeWithTracking(route, expression, dynamicTracking) {
      assertPostpone();
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          // When we aren't debugging, we don't need to create another error for the
          // stack trace.
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : void 0,
          expression
        });
      }
      _react.default.unstable_postpone(createPostponeReason(route, expression));
    }
    function createPostponeReason(route, expression) {
      return `Route ${route} needs to bail out of prerendering at this point because it used ${expression}. React throws this special object to indicate where. It should not be caught by your own try/catch. Learn more: https://nextjs.org/docs/messages/ppr-caught-error`;
    }
    function isDynamicPostpone(err) {
      if (typeof err === "object" && err !== null && typeof err.message === "string") {
        return isDynamicPostponeReason(err.message);
      }
      return false;
    }
    function isDynamicPostponeReason(reason) {
      return reason.includes("needs to bail out of prerendering at this point because it used") && reason.includes("Learn more: https://nextjs.org/docs/messages/ppr-caught-error");
    }
    if (isDynamicPostponeReason(createPostponeReason("%%%", "^^^")) === false) {
      throw new Error("Invariant: isDynamicPostpone misidentified a postpone reason. This is a bug in Next.js");
    }
    var NEXT_PRERENDER_INTERRUPTED = "NEXT_PRERENDER_INTERRUPTED";
    function createPrerenderInterruptedError(message) {
      const error = new Error(message);
      error.digest = NEXT_PRERENDER_INTERRUPTED;
      return error;
    }
    function isPrerenderInterruptedError(error) {
      return typeof error === "object" && error !== null && error.digest === NEXT_PRERENDER_INTERRUPTED && "name" in error && "message" in error && error instanceof Error;
    }
    function accessedDynamicData(dynamicAccesses) {
      return dynamicAccesses.length > 0;
    }
    function consumeDynamicAccess(serverDynamic, clientDynamic) {
      serverDynamic.dynamicAccesses.push(...clientDynamic.dynamicAccesses);
      return serverDynamic.dynamicAccesses;
    }
    function formatDynamicAPIAccesses(dynamicAccesses) {
      return dynamicAccesses.filter((access) => typeof access.stack === "string" && access.stack.length > 0).map(({ expression, stack }) => {
        stack = stack.split("\n").slice(4).filter((line) => {
          if (line.includes("node_modules/next/")) {
            return false;
          }
          if (line.includes(" (<anonymous>)")) {
            return false;
          }
          if (line.includes(" (node:")) {
            return false;
          }
          return true;
        }).join("\n");
        return `Dynamic API Usage Debug - ${expression}:
${stack}`;
      });
    }
    function assertPostpone() {
      if (!hasPostpone) {
        throw new Error(`Invariant: React.unstable_postpone is not defined. This suggests the wrong version of React was loaded. This is a bug in Next.js`);
      }
    }
    function createPostponedAbortSignal(reason) {
      assertPostpone();
      const controller = new AbortController();
      try {
        _react.default.unstable_postpone(reason);
      } catch (x) {
        controller.abort(x);
      }
      return controller.signal;
    }
    function annotateDynamicAccess(expression, prerenderStore) {
      const dynamicTracking = prerenderStore.dynamicTracking;
      if (dynamicTracking) {
        dynamicTracking.dynamicAccesses.push({
          stack: dynamicTracking.isDebugDynamicAccesses ? new Error().stack : void 0,
          expression
        });
      }
    }
    function useDynamicRouteParams(expression) {
      if (typeof window === "undefined") {
        const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
        if (workStore && workStore.isStaticGeneration && workStore.fallbackRouteParams && workStore.fallbackRouteParams.size > 0) {
          const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
          if (workUnitStore) {
            if (workUnitStore.type === "prerender") {
              _react.default.use((0, _dynamicrenderingutils.makeHangingPromise)(workUnitStore.renderSignal, expression));
            } else if (workUnitStore.type === "prerender-ppr") {
              postponeWithTracking(workStore.route, expression, workUnitStore.dynamicTracking);
            } else if (workUnitStore.type === "prerender-legacy") {
              throwToInterruptStaticGeneration(expression, workStore, workUnitStore);
            }
          }
        }
      }
    }
    var hasSuspenseRegex = /\n\s+at Suspense \(<anonymous>\)/;
    var hasMetadataRegex = new RegExp(`\\n\\s+at ${_metadataconstants.METADATA_BOUNDARY_NAME}[\\n\\s]`);
    var hasViewportRegex = new RegExp(`\\n\\s+at ${_metadataconstants.VIEWPORT_BOUNDARY_NAME}[\\n\\s]`);
    var hasOutletRegex = new RegExp(`\\n\\s+at ${_metadataconstants.OUTLET_BOUNDARY_NAME}[\\n\\s]`);
    function trackAllowedDynamicAccess(route, componentStack, dynamicValidation, serverDynamic, clientDynamic) {
      if (hasOutletRegex.test(componentStack)) {
        return;
      } else if (hasMetadataRegex.test(componentStack)) {
        dynamicValidation.hasDynamicMetadata = true;
        return;
      } else if (hasViewportRegex.test(componentStack)) {
        dynamicValidation.hasDynamicViewport = true;
        return;
      } else if (hasSuspenseRegex.test(componentStack)) {
        dynamicValidation.hasSuspendedDynamic = true;
        return;
      } else if (typeof serverDynamic.syncDynamicExpression === "string") {
        const message = `In Route "${route}" this parent component stack may help you locate where ${serverDynamic.syncDynamicExpression} was used.`;
        const error = createErrorWithComponentStack(message, componentStack);
        dynamicValidation.syncDynamicErrors.push(error);
        return;
      } else if (typeof clientDynamic.syncDynamicExpression === "string") {
        const message = `In Route "${route}" this parent component stack may help you locate where ${clientDynamic.syncDynamicExpression} was used.`;
        const error = createErrorWithComponentStack(message, componentStack);
        dynamicValidation.syncDynamicErrors.push(error);
        return;
      } else {
        const message = `In Route "${route}" this component accessed data without a fallback UI available somewhere above it using Suspense.`;
        const error = createErrorWithComponentStack(message, componentStack);
        dynamicValidation.dynamicErrors.push(error);
        return;
      }
    }
    function createErrorWithComponentStack(message, componentStack) {
      const error = new Error(message);
      error.stack = "Error: " + message + componentStack;
      return error;
    }
    function throwIfDisallowedDynamic(workStore, dynamicValidation, serverDynamic, clientDynamic) {
      const syncDynamicErrors = dynamicValidation.syncDynamicErrors;
      let syncError, syncExpression;
      if (serverDynamic.syncDynamicExpression) {
        syncError = serverDynamic.syncDynamicErrorWithStack;
        syncExpression = serverDynamic.syncDynamicExpression;
      } else if (clientDynamic.syncDynamicExpression) {
        syncError = clientDynamic.syncDynamicErrorWithStack;
        syncExpression = clientDynamic.syncDynamicExpression;
      } else {
        syncError = null;
        syncExpression = void 0;
      }
      if (syncDynamicErrors.length && syncError) {
        console.error(syncError);
        for (let i = 0; i < syncDynamicErrors.length; i++) {
          console.error(syncDynamicErrors[i]);
        }
        throw new _staticgenerationbailout.StaticGenBailoutError(`Route "${workStore.route}" could not be prerendered.`);
      }
      const dynamicErrors = dynamicValidation.dynamicErrors;
      if (dynamicErrors.length) {
        for (let i = 0; i < dynamicErrors.length; i++) {
          console.error(dynamicErrors[i]);
        }
        throw new _staticgenerationbailout.StaticGenBailoutError(`Route "${workStore.route}" could not be prerendered.`);
      }
      if (!dynamicValidation.hasSuspendedDynamic) {
        if (dynamicValidation.hasDynamicMetadata) {
          if (syncError) {
            console.error(syncError);
            throw new _staticgenerationbailout.StaticGenBailoutError(`Route "${workStore.route}" has a \`generateMetadata\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`);
          }
          throw new _staticgenerationbailout.StaticGenBailoutError(`Route "${workStore.route}" has a \`generateMetadata\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateMetadata\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`);
        } else if (dynamicValidation.hasDynamicViewport) {
          if (syncError) {
            console.error(syncError);
            throw new _staticgenerationbailout.StaticGenBailoutError(`Route "${workStore.route}" has a \`generateViewport\` that could not finish rendering before ${syncExpression} was used. Follow the instructions in the error for this expression to resolve.`);
          }
          throw new _staticgenerationbailout.StaticGenBailoutError(`Route "${workStore.route}" has a \`generateViewport\` that depends on Request data (\`cookies()\`, etc...) or external data (\`fetch(...)\`, etc...) but the rest of the route was static or only used cached data (\`"use cache"\`). If you expected this route to be prerenderable update your \`generateViewport\` to not use Request data and only use cached external data. Otherwise, add \`await connection()\` somewhere within this route to indicate explicitly it should not be prerendered.`);
        }
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/invariant-error.js
var require_invariant_error = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/invariant-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "InvariantError", {
      enumerable: true,
      get: function() {
        return InvariantError;
      }
    });
    var InvariantError = class extends Error {
      constructor(message, options) {
        super("Invariant: " + (message.endsWith(".") ? message : message + ".") + " This is a bug in Next.js.", options);
        this.name = "InvariantError";
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/utils.js
var require_utils2 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "io", {
      enumerable: true,
      get: function() {
        return io;
      }
    });
    var _workasyncstorageexternal = require_work_async_storage_external();
    var _workunitasyncstorageexternal = require_work_unit_async_storage_external();
    var _dynamicrendering = require_dynamic_rendering();
    var _invarianterror = require_invariant_error();
    function io(expression, type) {
      const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
      if (workUnitStore) {
        if (workUnitStore.type === "prerender") {
          const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
          if (workStore) {
            let message;
            switch (type) {
              case "time":
                message = `Route "${workStore.route}" used ${expression} instead of using \`performance\` or without explicitly calling \`await connection()\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-current-time`;
                break;
              case "random":
                message = `Route "${workStore.route}" used ${expression} outside of \`"use cache"\` and without explicitly calling \`await connection()\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-random`;
                break;
              case "crypto":
                message = `Route "${workStore.route}" used ${expression} outside of \`"use cache"\` and without explicitly calling \`await connection()\` beforehand. See more info here: https://nextjs.org/docs/messages/next-prerender-crypto`;
                break;
              default:
                throw new _invarianterror.InvariantError("Unknown expression type in abortOnSynchronousPlatformIOAccess.");
            }
            const errorWithStack = new Error(message);
            (0, _dynamicrendering.abortOnSynchronousPlatformIOAccess)(workStore.route, expression, errorWithStack, workUnitStore);
          }
        }
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/random.js
var require_random = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _utils = require_utils2();
    var expression = "`Math.random()`";
    try {
      const _random = Math.random;
      Math.random = function random() {
        (0, _utils.io)(expression, "random");
        return _random.apply(null, arguments);
      }.bind(null);
      Object.defineProperty(Math.random, "name", {
        value: "random"
      });
    } catch {
      console.error(`Failed to install ${expression} extension. When using \`experimental.dynamicIO\` calling this function will not correctly trigger dynamic behavior.`);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/date.js
var require_date = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/date.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _utils = require_utils2();
    function createNow(originalNow) {
      return {
        now: function now() {
          (0, _utils.io)("`Date.now()`", "time");
          return originalNow();
        }
      }["now".slice()].bind(null);
    }
    function createDate(originalConstructor) {
      const properties = Object.getOwnPropertyDescriptors(originalConstructor);
      properties.now.value = createNow(originalConstructor.now);
      const apply = Reflect.apply;
      const construct = Reflect.construct;
      const newConstructor = Object.defineProperties(
        // Ideally this should not minify the name.
        function Date1() {
          if (new.target === void 0) {
            (0, _utils.io)("`Date()`", "time");
            return apply(originalConstructor, void 0, arguments);
          }
          if (arguments.length === 0) {
            (0, _utils.io)("`new Date()`", "time");
          }
          return construct(originalConstructor, arguments, new.target);
        },
        properties
      );
      Object.defineProperty(originalConstructor.prototype, "constructor", {
        value: newConstructor
      });
      return newConstructor;
    }
    try {
      Date = createDate(Date);
    } catch {
      console.error("Failed to install `Date` class extension. When using `experimental.dynamicIO`, APIs that read the current time will not correctly trigger dynamic behavior.");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/web-crypto.js
var require_web_crypto = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/web-crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _utils = require_utils2();
    var webCrypto;
    if (false) {
      webCrypto = crypto;
    } else {
      if (typeof crypto === "undefined") {
        webCrypto = require("node:crypto").webcrypto;
      } else {
        webCrypto = crypto;
      }
    }
    var getRandomValuesExpression = "`crypto.getRandomValues()`";
    try {
      const _getRandomValues = webCrypto.getRandomValues;
      webCrypto.getRandomValues = function getRandomValues() {
        (0, _utils.io)(getRandomValuesExpression, "crypto");
        return _getRandomValues.apply(webCrypto, arguments);
      };
    } catch {
      console.error(`Failed to install ${getRandomValuesExpression} extension. When using \`experimental.dynamicIO\` calling this function will not correctly trigger dynamic behavior.`);
    }
    var randomUUIDExpression = "`crypto.randomUUID()`";
    try {
      const _randomUUID = webCrypto.randomUUID;
      webCrypto.randomUUID = function randomUUID() {
        (0, _utils.io)(randomUUIDExpression, "crypto");
        return _randomUUID.apply(webCrypto, arguments);
      };
    } catch {
      console.error(`Failed to install ${getRandomValuesExpression} extension. When using \`experimental.dynamicIO\` calling this function will not correctly trigger dynamic behavior.`);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/node-crypto.js
var require_node_crypto = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/node-environment-extensions/node-crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _utils = require_utils2();
    if (false) {
    } else {
      const nodeCrypto = require("node:crypto");
      const randomUUIDExpression = "`require('node:crypto').randomUUID()`";
      try {
        const _randomUUID = nodeCrypto.randomUUID;
        nodeCrypto.randomUUID = function randomUUID() {
          (0, _utils.io)(randomUUIDExpression, "random");
          return _randomUUID.apply(this, arguments);
        };
      } catch {
        console.error(`Failed to install ${randomUUIDExpression} extension. When using \`experimental.dynamicIO\` calling this function will not correctly trigger dynamic behavior.`);
      }
      const randomBytesExpression = "`require('node:crypto').randomBytes(size)`";
      try {
        const _randomBytes = nodeCrypto.randomBytes;
        nodeCrypto.randomBytes = function randomBytes() {
          if (typeof arguments[1] !== "function") {
            (0, _utils.io)(randomBytesExpression, "random");
          }
          return _randomBytes.apply(this, arguments);
        };
      } catch {
        console.error(`Failed to install ${randomBytesExpression} extension. When using \`experimental.dynamicIO\` calling this function without a callback argument will not correctly trigger dynamic behavior.`);
      }
      const randomFillSyncExpression = "`require('node:crypto').randomFillSync(...)`";
      try {
        const _randomFillSync = nodeCrypto.randomFillSync;
        nodeCrypto.randomFillSync = function randomFillSync() {
          (0, _utils.io)(randomFillSyncExpression, "random");
          return _randomFillSync.apply(this, arguments);
        };
      } catch {
        console.error(`Failed to install ${randomFillSyncExpression} extension. When using \`experimental.dynamicIO\` calling this function will not correctly trigger dynamic behavior.`);
      }
      const randomIntExpression = "`require('node:crypto').randomInt(min, max)`";
      try {
        const _randomInt = nodeCrypto.randomInt;
        nodeCrypto.randomInt = function randomInt() {
          if (typeof arguments[2] !== "function") {
            (0, _utils.io)(randomIntExpression, "random");
          }
          return _randomInt.apply(this, arguments);
        };
      } catch {
        console.error(`Failed to install ${randomBytesExpression} extension. When using \`experimental.dynamicIO\` calling this function without a callback argument will not correctly trigger dynamic behavior.`);
      }
      const generatePrimeSyncExpression = "`require('node:crypto').generatePrimeSync(...)`";
      try {
        const _generatePrimeSync = nodeCrypto.generatePrimeSync;
        nodeCrypto.generatePrimeSync = function generatePrimeSync() {
          (0, _utils.io)(generatePrimeSyncExpression, "random");
          return _generatePrimeSync.apply(this, arguments);
        };
      } catch {
        console.error(`Failed to install ${generatePrimeSyncExpression} extension. When using \`experimental.dynamicIO\` calling this function will not correctly trigger dynamic behavior.`);
      }
      const generateKeyPairSyncExpression = "`require('node:crypto').generateKeyPairSync(...)`";
      try {
        const _generateKeyPairSync = nodeCrypto.generateKeyPairSync;
        nodeCrypto.generateKeyPairSync = function generateKeyPairSync() {
          (0, _utils.io)(generateKeyPairSyncExpression, "random");
          return _generateKeyPairSync.apply(this, arguments);
        };
      } catch {
        console.error(`Failed to install ${generateKeyPairSyncExpression} extension. When using \`experimental.dynamicIO\` calling this function will not correctly trigger dynamic behavior.`);
      }
      const generateKeySyncExpression = "`require('node:crypto').generateKeySync(...)`";
      try {
        const _generateKeySync = nodeCrypto.generateKeySync;
        nodeCrypto.generateKeySync = function generateKeySync() {
          (0, _utils.io)(generateKeySyncExpression, "random");
          return _generateKeySync.apply(this, arguments);
        };
      } catch {
        console.error(`Failed to install ${generateKeySyncExpression} extension. When using \`experimental.dynamicIO\` calling this function will not correctly trigger dynamic behavior.`);
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/node-environment.js
var require_node_environment = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/node-environment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    require_node_environment_baseline();
    require_random();
    require_date();
    require_web_crypto();
    require_node_crypto();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/node-polyfill-crypto.js
var require_node_polyfill_crypto = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/node-polyfill-crypto.js"() {
    "use strict";
    if (!global.crypto) {
      let webcrypto;
      Object.defineProperty(global, "crypto", {
        enumerable: false,
        configurable: true,
        get() {
          if (!webcrypto) {
            webcrypto = require("node:crypto").webcrypto;
          }
          return webcrypto;
        },
        set(value) {
          webcrypto = value;
        }
      });
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/utils.js
var require_utils3 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      DecodeError: function() {
        return DecodeError;
      },
      MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
      },
      MissingStaticPage: function() {
        return MissingStaticPage;
      },
      NormalizeError: function() {
        return NormalizeError;
      },
      PageNotFoundError: function() {
        return PageNotFoundError;
      },
      SP: function() {
        return SP;
      },
      ST: function() {
        return ST;
      },
      WEB_VITALS: function() {
        return WEB_VITALS;
      },
      execOnce: function() {
        return execOnce;
      },
      getDisplayName: function() {
        return getDisplayName;
      },
      getLocationOrigin: function() {
        return getLocationOrigin;
      },
      getURL: function() {
        return getURL;
      },
      isAbsoluteUrl: function() {
        return isAbsoluteUrl;
      },
      isResSent: function() {
        return isResSent;
      },
      loadGetInitialProps: function() {
        return loadGetInitialProps;
      },
      normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
      },
      stringifyError: function() {
        return stringifyError;
      }
    });
    var WEB_VITALS = [
      "CLS",
      "FCP",
      "FID",
      "INP",
      "LCP",
      "TTFB"
    ];
    function execOnce(fn) {
      let used = false;
      let result;
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (!used) {
          used = true;
          result = fn(...args);
        }
        return result;
      };
    }
    var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
    var isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
    function getLocationOrigin() {
      const { protocol, hostname, port } = window.location;
      return protocol + "//" + hostname + (port ? ":" + port : "");
    }
    function getURL() {
      const { href } = window.location;
      const origin = getLocationOrigin();
      return href.substring(origin.length);
    }
    function getDisplayName(Component) {
      return typeof Component === "string" ? Component : Component.displayName || Component.name || "Unknown";
    }
    function isResSent(res) {
      return res.finished || res.headersSent;
    }
    function normalizeRepeatedSlashes(url) {
      const urlParts = url.split("?");
      const urlNoQuery = urlParts[0];
      return urlNoQuery.replace(/\\/g, "/").replace(/\/\/+/g, "/") + (urlParts[1] ? "?" + urlParts.slice(1).join("?") : "");
    }
    async function loadGetInitialProps(App, ctx) {
      if (false) {
        var _App_prototype;
        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {
          const message = '"' + getDisplayName(App) + '.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';
          throw new Error(message);
        }
      }
      const res = ctx.res || ctx.ctx && ctx.ctx.res;
      if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
          return {
            pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
          };
        }
        return {};
      }
      const props = await App.getInitialProps(ctx);
      if (res && isResSent(res)) {
        return props;
      }
      if (!props) {
        const message = '"' + getDisplayName(App) + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
        throw new Error(message);
      }
      if (false) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
          console.warn("" + getDisplayName(App) + " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps");
        }
      }
      return props;
    }
    var SP = typeof performance !== "undefined";
    var ST = SP && [
      "mark",
      "measure",
      "getEntriesByName"
    ].every((method) => typeof performance[method] === "function");
    var DecodeError = class extends Error {
    };
    var NormalizeError = class extends Error {
    };
    var PageNotFoundError = class extends Error {
      constructor(page) {
        super();
        this.code = "ENOENT";
        this.name = "PageNotFoundError";
        this.message = "Cannot find module for page: " + page;
      }
    };
    var MissingStaticPage = class extends Error {
      constructor(page, message) {
        super();
        this.message = "Failed to load static file for page: " + page + " " + message;
      }
    };
    var MiddlewareNotFoundError = class extends Error {
      constructor() {
        super();
        this.code = "ENOENT";
        this.message = "Cannot find the middleware module";
      }
    };
    function stringifyError(error) {
      return JSON.stringify({
        message: error.message,
        stack: error.stack
      });
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/route-matcher.js
var require_route_matcher = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getRouteMatcher", {
      enumerable: true,
      get: function() {
        return getRouteMatcher;
      }
    });
    var _utils = require_utils3();
    function getRouteMatcher(param) {
      let { re, groups } = param;
      return (pathname) => {
        const routeMatch = re.exec(pathname);
        if (!routeMatch) {
          return false;
        }
        const decode = (param2) => {
          try {
            return decodeURIComponent(param2);
          } catch (_) {
            throw new _utils.DecodeError("failed to decode param");
          }
        };
        const params = {};
        Object.keys(groups).forEach((slugName) => {
          const g = groups[slugName];
          const m = routeMatch[g.pos];
          if (m !== void 0) {
            params[slugName] = ~m.indexOf("/") ? m.split("/").map((entry) => decode(entry)) : g.repeat ? [
              decode(m)
            ] : decode(m);
          }
        });
        return params;
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/@swc/helpers/cjs/_interop_require_default.cjs
var require_interop_require_default = __commonJS({
  ".worker-next/.next/standalone/node_modules/@swc/helpers/cjs/_interop_require_default.cjs"(exports) {
    "use strict";
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports._ = _interop_require_default;
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/modern-browserslist-target.js
var require_modern_browserslist_target = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/modern-browserslist-target.js"(exports, module) {
    "use strict";
    var MODERN_BROWSERSLIST_TARGET = [
      "chrome 64",
      "edge 79",
      "firefox 67",
      "opera 51",
      "safari 12"
    ];
    module.exports = MODERN_BROWSERSLIST_TARGET;
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/constants.js
var require_constants3 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/constants.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      APP_BUILD_MANIFEST: function() {
        return APP_BUILD_MANIFEST;
      },
      APP_CLIENT_INTERNALS: function() {
        return APP_CLIENT_INTERNALS;
      },
      APP_PATHS_MANIFEST: function() {
        return APP_PATHS_MANIFEST;
      },
      APP_PATH_ROUTES_MANIFEST: function() {
        return APP_PATH_ROUTES_MANIFEST;
      },
      BARREL_OPTIMIZATION_PREFIX: function() {
        return BARREL_OPTIMIZATION_PREFIX;
      },
      BLOCKED_PAGES: function() {
        return BLOCKED_PAGES;
      },
      BUILD_ID_FILE: function() {
        return BUILD_ID_FILE;
      },
      BUILD_MANIFEST: function() {
        return BUILD_MANIFEST;
      },
      CLIENT_PUBLIC_FILES_PATH: function() {
        return CLIENT_PUBLIC_FILES_PATH;
      },
      CLIENT_REFERENCE_MANIFEST: function() {
        return CLIENT_REFERENCE_MANIFEST;
      },
      CLIENT_STATIC_FILES_PATH: function() {
        return CLIENT_STATIC_FILES_PATH;
      },
      CLIENT_STATIC_FILES_RUNTIME_AMP: function() {
        return CLIENT_STATIC_FILES_RUNTIME_AMP;
      },
      CLIENT_STATIC_FILES_RUNTIME_MAIN: function() {
        return CLIENT_STATIC_FILES_RUNTIME_MAIN;
      },
      CLIENT_STATIC_FILES_RUNTIME_MAIN_APP: function() {
        return CLIENT_STATIC_FILES_RUNTIME_MAIN_APP;
      },
      CLIENT_STATIC_FILES_RUNTIME_POLYFILLS: function() {
        return CLIENT_STATIC_FILES_RUNTIME_POLYFILLS;
      },
      CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL: function() {
        return CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL;
      },
      CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH: function() {
        return CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH;
      },
      CLIENT_STATIC_FILES_RUNTIME_WEBPACK: function() {
        return CLIENT_STATIC_FILES_RUNTIME_WEBPACK;
      },
      COMPILER_INDEXES: function() {
        return COMPILER_INDEXES;
      },
      COMPILER_NAMES: function() {
        return COMPILER_NAMES;
      },
      CONFIG_FILES: function() {
        return CONFIG_FILES;
      },
      DEFAULT_RUNTIME_WEBPACK: function() {
        return DEFAULT_RUNTIME_WEBPACK;
      },
      DEFAULT_SANS_SERIF_FONT: function() {
        return DEFAULT_SANS_SERIF_FONT;
      },
      DEFAULT_SERIF_FONT: function() {
        return DEFAULT_SERIF_FONT;
      },
      DEV_CLIENT_MIDDLEWARE_MANIFEST: function() {
        return DEV_CLIENT_MIDDLEWARE_MANIFEST;
      },
      DEV_CLIENT_PAGES_MANIFEST: function() {
        return DEV_CLIENT_PAGES_MANIFEST;
      },
      EDGE_RUNTIME_WEBPACK: function() {
        return EDGE_RUNTIME_WEBPACK;
      },
      EDGE_UNSUPPORTED_NODE_APIS: function() {
        return EDGE_UNSUPPORTED_NODE_APIS;
      },
      EXPORT_DETAIL: function() {
        return EXPORT_DETAIL;
      },
      EXPORT_MARKER: function() {
        return EXPORT_MARKER;
      },
      FUNCTIONS_CONFIG_MANIFEST: function() {
        return FUNCTIONS_CONFIG_MANIFEST;
      },
      IMAGES_MANIFEST: function() {
        return IMAGES_MANIFEST;
      },
      INTERCEPTION_ROUTE_REWRITE_MANIFEST: function() {
        return INTERCEPTION_ROUTE_REWRITE_MANIFEST;
      },
      MIDDLEWARE_BUILD_MANIFEST: function() {
        return MIDDLEWARE_BUILD_MANIFEST;
      },
      MIDDLEWARE_MANIFEST: function() {
        return MIDDLEWARE_MANIFEST;
      },
      MIDDLEWARE_REACT_LOADABLE_MANIFEST: function() {
        return MIDDLEWARE_REACT_LOADABLE_MANIFEST;
      },
      MODERN_BROWSERSLIST_TARGET: function() {
        return _modernbrowserslisttarget.default;
      },
      NEXT_BUILTIN_DOCUMENT: function() {
        return NEXT_BUILTIN_DOCUMENT;
      },
      NEXT_FONT_MANIFEST: function() {
        return NEXT_FONT_MANIFEST;
      },
      PAGES_MANIFEST: function() {
        return PAGES_MANIFEST;
      },
      PHASE_DEVELOPMENT_SERVER: function() {
        return PHASE_DEVELOPMENT_SERVER;
      },
      PHASE_EXPORT: function() {
        return PHASE_EXPORT;
      },
      PHASE_INFO: function() {
        return PHASE_INFO;
      },
      PHASE_PRODUCTION_BUILD: function() {
        return PHASE_PRODUCTION_BUILD;
      },
      PHASE_PRODUCTION_SERVER: function() {
        return PHASE_PRODUCTION_SERVER;
      },
      PHASE_TEST: function() {
        return PHASE_TEST;
      },
      PRERENDER_MANIFEST: function() {
        return PRERENDER_MANIFEST;
      },
      REACT_LOADABLE_MANIFEST: function() {
        return REACT_LOADABLE_MANIFEST;
      },
      ROUTES_MANIFEST: function() {
        return ROUTES_MANIFEST;
      },
      RSC_MODULE_TYPES: function() {
        return RSC_MODULE_TYPES;
      },
      SERVER_DIRECTORY: function() {
        return SERVER_DIRECTORY;
      },
      SERVER_FILES_MANIFEST: function() {
        return SERVER_FILES_MANIFEST;
      },
      SERVER_PROPS_ID: function() {
        return SERVER_PROPS_ID;
      },
      SERVER_REFERENCE_MANIFEST: function() {
        return SERVER_REFERENCE_MANIFEST;
      },
      STATIC_PROPS_ID: function() {
        return STATIC_PROPS_ID;
      },
      STATIC_STATUS_PAGES: function() {
        return STATIC_STATUS_PAGES;
      },
      STRING_LITERAL_DROP_BUNDLE: function() {
        return STRING_LITERAL_DROP_BUNDLE;
      },
      SUBRESOURCE_INTEGRITY_MANIFEST: function() {
        return SUBRESOURCE_INTEGRITY_MANIFEST;
      },
      SYSTEM_ENTRYPOINTS: function() {
        return SYSTEM_ENTRYPOINTS;
      },
      TRACE_OUTPUT_VERSION: function() {
        return TRACE_OUTPUT_VERSION;
      },
      TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST: function() {
        return TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST;
      },
      TURBO_TRACE_DEFAULT_MEMORY_LIMIT: function() {
        return TURBO_TRACE_DEFAULT_MEMORY_LIMIT;
      },
      UNDERSCORE_NOT_FOUND_ROUTE: function() {
        return UNDERSCORE_NOT_FOUND_ROUTE;
      },
      UNDERSCORE_NOT_FOUND_ROUTE_ENTRY: function() {
        return UNDERSCORE_NOT_FOUND_ROUTE_ENTRY;
      },
      WEBPACK_STATS: function() {
        return WEBPACK_STATS;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _modernbrowserslisttarget = /* @__PURE__ */ _interop_require_default._(require_modern_browserslist_target());
    var COMPILER_NAMES = {
      client: "client",
      server: "server",
      edgeServer: "edge-server"
    };
    var COMPILER_INDEXES = {
      [COMPILER_NAMES.client]: 0,
      [COMPILER_NAMES.server]: 1,
      [COMPILER_NAMES.edgeServer]: 2
    };
    var UNDERSCORE_NOT_FOUND_ROUTE = "/_not-found";
    var UNDERSCORE_NOT_FOUND_ROUTE_ENTRY = "" + UNDERSCORE_NOT_FOUND_ROUTE + "/page";
    var PHASE_EXPORT = "phase-export";
    var PHASE_PRODUCTION_BUILD = "phase-production-build";
    var PHASE_PRODUCTION_SERVER = "phase-production-server";
    var PHASE_DEVELOPMENT_SERVER = "phase-development-server";
    var PHASE_TEST = "phase-test";
    var PHASE_INFO = "phase-info";
    var PAGES_MANIFEST = "pages-manifest.json";
    var WEBPACK_STATS = "webpack-stats.json";
    var APP_PATHS_MANIFEST = "app-paths-manifest.json";
    var APP_PATH_ROUTES_MANIFEST = "app-path-routes-manifest.json";
    var BUILD_MANIFEST = "build-manifest.json";
    var APP_BUILD_MANIFEST = "app-build-manifest.json";
    var FUNCTIONS_CONFIG_MANIFEST = "functions-config-manifest.json";
    var SUBRESOURCE_INTEGRITY_MANIFEST = "subresource-integrity-manifest";
    var NEXT_FONT_MANIFEST = "next-font-manifest";
    var EXPORT_MARKER = "export-marker.json";
    var EXPORT_DETAIL = "export-detail.json";
    var PRERENDER_MANIFEST = "prerender-manifest.json";
    var ROUTES_MANIFEST = "routes-manifest.json";
    var IMAGES_MANIFEST = "images-manifest.json";
    var SERVER_FILES_MANIFEST = "required-server-files.json";
    var DEV_CLIENT_PAGES_MANIFEST = "_devPagesManifest.json";
    var MIDDLEWARE_MANIFEST = "middleware-manifest.json";
    var TURBOPACK_CLIENT_MIDDLEWARE_MANIFEST = "_clientMiddlewareManifest.json";
    var DEV_CLIENT_MIDDLEWARE_MANIFEST = "_devMiddlewareManifest.json";
    var REACT_LOADABLE_MANIFEST = "react-loadable-manifest.json";
    var SERVER_DIRECTORY = "server";
    var CONFIG_FILES = [
      "next.config.js",
      "next.config.mjs",
      "next.config.ts"
    ];
    var BUILD_ID_FILE = "BUILD_ID";
    var BLOCKED_PAGES = [
      "/_document",
      "/_app",
      "/_error"
    ];
    var CLIENT_PUBLIC_FILES_PATH = "public";
    var CLIENT_STATIC_FILES_PATH = "static";
    var STRING_LITERAL_DROP_BUNDLE = "__NEXT_DROP_CLIENT_FILE__";
    var NEXT_BUILTIN_DOCUMENT = "__NEXT_BUILTIN_DOCUMENT__";
    var BARREL_OPTIMIZATION_PREFIX = "__barrel_optimize__";
    var CLIENT_REFERENCE_MANIFEST = "client-reference-manifest";
    var SERVER_REFERENCE_MANIFEST = "server-reference-manifest";
    var MIDDLEWARE_BUILD_MANIFEST = "middleware-build-manifest";
    var MIDDLEWARE_REACT_LOADABLE_MANIFEST = "middleware-react-loadable-manifest";
    var INTERCEPTION_ROUTE_REWRITE_MANIFEST = "interception-route-rewrite-manifest";
    var CLIENT_STATIC_FILES_RUNTIME_MAIN = "main";
    var CLIENT_STATIC_FILES_RUNTIME_MAIN_APP = "" + CLIENT_STATIC_FILES_RUNTIME_MAIN + "-app";
    var APP_CLIENT_INTERNALS = "app-pages-internals";
    var CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH = "react-refresh";
    var CLIENT_STATIC_FILES_RUNTIME_AMP = "amp";
    var CLIENT_STATIC_FILES_RUNTIME_WEBPACK = "webpack";
    var CLIENT_STATIC_FILES_RUNTIME_POLYFILLS = "polyfills";
    var CLIENT_STATIC_FILES_RUNTIME_POLYFILLS_SYMBOL = Symbol(CLIENT_STATIC_FILES_RUNTIME_POLYFILLS);
    var DEFAULT_RUNTIME_WEBPACK = "webpack-runtime";
    var EDGE_RUNTIME_WEBPACK = "edge-runtime-webpack";
    var STATIC_PROPS_ID = "__N_SSG";
    var SERVER_PROPS_ID = "__N_SSP";
    var DEFAULT_SERIF_FONT = {
      name: "Times New Roman",
      xAvgCharWidth: 821,
      azAvgWidth: 854.3953488372093,
      unitsPerEm: 2048
    };
    var DEFAULT_SANS_SERIF_FONT = {
      name: "Arial",
      xAvgCharWidth: 904,
      azAvgWidth: 934.5116279069767,
      unitsPerEm: 2048
    };
    var STATIC_STATUS_PAGES = [
      "/500"
    ];
    var TRACE_OUTPUT_VERSION = 1;
    var TURBO_TRACE_DEFAULT_MEMORY_LIMIT = 6e3;
    var RSC_MODULE_TYPES = {
      client: "client",
      server: "server"
    };
    var EDGE_UNSUPPORTED_NODE_APIS = [
      "clearImmediate",
      "setImmediate",
      "BroadcastChannel",
      "ByteLengthQueuingStrategy",
      "CompressionStream",
      "CountQueuingStrategy",
      "DecompressionStream",
      "DomException",
      "MessageChannel",
      "MessageEvent",
      "MessagePort",
      "ReadableByteStreamController",
      "ReadableStreamBYOBRequest",
      "ReadableStreamDefaultController",
      "TransformStreamDefaultController",
      "WritableStreamDefaultController"
    ];
    var SYSTEM_ENTRYPOINTS = /* @__PURE__ */ new Set([
      CLIENT_STATIC_FILES_RUNTIME_MAIN,
      CLIENT_STATIC_FILES_RUNTIME_REACT_REFRESH,
      CLIENT_STATIC_FILES_RUNTIME_AMP,
      CLIENT_STATIC_FILES_RUNTIME_MAIN_APP
    ]);
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/find-pages-dir.js
var require_find_pages_dir = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/find-pages-dir.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      findDir: function() {
        return findDir;
      },
      findPagesDir: function() {
        return findPagesDir;
      }
    });
    var _fs = /* @__PURE__ */ _interop_require_default(require("fs"));
    var _path = /* @__PURE__ */ _interop_require_default(require("path"));
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function findDir(dir, name) {
			if (dir.endsWith(".next/server")) {
			if (name === "app") {
			  return true;
	    }
			if (name === "pages") {
			  return true;
	    }
		}
		throw new Error("Unknown findDir call: " + dir + " " + name);
		
      let curDir = _path.default.join(dir, name);
      if (_fs.default.existsSync(curDir))
        return curDir;
      curDir = _path.default.join(dir, "src", name);
      if (_fs.default.existsSync(curDir))
        return curDir;
      return null;
    }
    function findPagesDir(dir) {
      const pagesDir = findDir(dir, "pages") || void 0;
      const appDir = findDir(dir, "app") || void 0;
      if (appDir == null && pagesDir == null) {
        throw new Error("> Couldn't find any `pages` or `app` directory. Please create one under the project root");
      }
      return {
        pagesDir,
        appDir
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/etag.js
var require_etag = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/etag.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      fnv1a52: function() {
        return fnv1a52;
      },
      generateETag: function() {
        return generateETag;
      }
    });
    var fnv1a52 = (str) => {
      const len = str.length;
      let i = 0, t0 = 0, v0 = 8997, t1 = 0, v1 = 33826, t2 = 0, v2 = 40164, t3 = 0, v3 = 52210;
      while (i < len) {
        v0 ^= str.charCodeAt(i++);
        t0 = v0 * 435;
        t1 = v1 * 435;
        t2 = v2 * 435;
        t3 = v3 * 435;
        t2 += v0 << 8;
        t3 += v1 << 8;
        t1 += t0 >>> 16;
        v0 = t0 & 65535;
        t2 += t1 >>> 16;
        v1 = t1 & 65535;
        v3 = t3 + (t2 >>> 16) & 65535;
        v2 = t2 & 65535;
      }
      return (v3 & 15) * 281474976710656 + v2 * 4294967296 + v1 * 65536 + (v0 ^ v3 >> 4);
    };
    var generateETag = (payload, weak = false) => {
      const prefix = weak ? 'W/"' : '"';
      return prefix + fnv1a52(payload).toString(36) + payload.length.toString(36) + '"';
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/compiled/fresh/index.js
var require_fresh = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/compiled/fresh/index.js"(exports, module) {
    (() => {
      "use strict";
      var e = { 695: (e2) => {
        var r2 = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
        e2.exports = fresh;
        function fresh(e3, a2) {
          var t = e3["if-modified-since"];
          var s = e3["if-none-match"];
          if (!t && !s) {
            return false;
          }
          var i = e3["cache-control"];
          if (i && r2.test(i)) {
            return false;
          }
          if (s && s !== "*") {
            var f = a2["etag"];
            if (!f) {
              return false;
            }
            var n = true;
            var u = parseTokenList(s);
            for (var _ = 0; _ < u.length; _++) {
              var o = u[_];
              if (o === f || o === "W/" + f || "W/" + o === f) {
                n = false;
                break;
              }
            }
            if (n) {
              return false;
            }
          }
          if (t) {
            var p = a2["last-modified"];
            var v = !p || !(parseHttpDate(p) <= parseHttpDate(t));
            if (v) {
              return false;
            }
          }
          return true;
        }
        function parseHttpDate(e3) {
          var r3 = e3 && Date.parse(e3);
          return typeof r3 === "number" ? r3 : NaN;
        }
        function parseTokenList(e3) {
          var r3 = 0;
          var a2 = [];
          var t = 0;
          for (var s = 0, i = e3.length; s < i; s++) {
            switch (e3.charCodeAt(s)) {
              case 32:
                if (t === r3) {
                  t = r3 = s + 1;
                }
                break;
              case 44:
                a2.push(e3.substring(t, r3));
                t = r3 = s + 1;
                break;
              default:
                r3 = s + 1;
                break;
            }
          }
          a2.push(e3.substring(t, r3));
          return a2;
        }
      } };
      var r = {};
      function __nccwpck_require__2(a2) {
        var t = r[a2];
        if (t !== void 0) {
          return t.exports;
        }
        var s = r[a2] = { exports: {} };
        var i = true;
        try {
          e[a2](s, s.exports, __nccwpck_require__2);
          i = false;
        } finally {
          if (i)
            delete r[a2];
        }
        return s.exports;
      }
      if (typeof __nccwpck_require__2 !== "undefined")
        __nccwpck_require__2.ab = "/";
      var a = __nccwpck_require__2(695);
      module.exports = a;
    })();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/revalidate.js
var require_revalidate = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/revalidate.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "formatRevalidate", {
      enumerable: true,
      get: function() {
        return formatRevalidate;
      }
    });
    var _constants = require_constants();
    function formatRevalidate({ revalidate, expireTime }) {
      const swrHeader = typeof revalidate === "number" && expireTime !== void 0 ? revalidate >= expireTime ? "" : `stale-while-revalidate=${expireTime - revalidate}` : "stale-while-revalidate";
      if (revalidate === 0) {
        return "private, no-cache, no-store, max-age=0, must-revalidate";
      } else if (typeof revalidate === "number") {
        return `s-maxage=${revalidate}, ${swrHeader}`;
      }
      return `s-maxage=${_constants.CACHE_ONE_YEAR}, ${swrHeader}`;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/client/components/app-router-headers.js
var require_app_router_headers = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/client/components/app-router-headers.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      ACTION_HEADER: function() {
        return ACTION_HEADER;
      },
      FLIGHT_HEADERS: function() {
        return FLIGHT_HEADERS;
      },
      NEXT_DID_POSTPONE_HEADER: function() {
        return NEXT_DID_POSTPONE_HEADER;
      },
      NEXT_HMR_REFRESH_HEADER: function() {
        return NEXT_HMR_REFRESH_HEADER;
      },
      NEXT_IS_PRERENDER_HEADER: function() {
        return NEXT_IS_PRERENDER_HEADER;
      },
      NEXT_ROUTER_PREFETCH_HEADER: function() {
        return NEXT_ROUTER_PREFETCH_HEADER;
      },
      NEXT_ROUTER_SEGMENT_PREFETCH_HEADER: function() {
        return NEXT_ROUTER_SEGMENT_PREFETCH_HEADER;
      },
      NEXT_ROUTER_STALE_TIME_HEADER: function() {
        return NEXT_ROUTER_STALE_TIME_HEADER;
      },
      NEXT_ROUTER_STATE_TREE_HEADER: function() {
        return NEXT_ROUTER_STATE_TREE_HEADER;
      },
      NEXT_RSC_UNION_QUERY: function() {
        return NEXT_RSC_UNION_QUERY;
      },
      NEXT_URL: function() {
        return NEXT_URL;
      },
      RSC_CONTENT_TYPE_HEADER: function() {
        return RSC_CONTENT_TYPE_HEADER;
      },
      RSC_HEADER: function() {
        return RSC_HEADER;
      }
    });
    var RSC_HEADER = "RSC";
    var ACTION_HEADER = "Next-Action";
    var NEXT_ROUTER_STATE_TREE_HEADER = "Next-Router-State-Tree";
    var NEXT_ROUTER_PREFETCH_HEADER = "Next-Router-Prefetch";
    var NEXT_ROUTER_SEGMENT_PREFETCH_HEADER = "Next-Router-Segment-Prefetch";
    var NEXT_HMR_REFRESH_HEADER = "Next-HMR-Refresh";
    var NEXT_URL = "Next-Url";
    var RSC_CONTENT_TYPE_HEADER = "text/x-component";
    var FLIGHT_HEADERS = [
      RSC_HEADER,
      NEXT_ROUTER_STATE_TREE_HEADER,
      NEXT_ROUTER_PREFETCH_HEADER,
      NEXT_HMR_REFRESH_HEADER,
      NEXT_ROUTER_SEGMENT_PREFETCH_HEADER
    ];
    var NEXT_RSC_UNION_QUERY = "_rsc";
    var NEXT_ROUTER_STALE_TIME_HEADER = "x-nextjs-stale-time";
    var NEXT_DID_POSTPONE_HEADER = "x-nextjs-postponed";
    var NEXT_IS_PRERENDER_HEADER = "x-nextjs-prerender";
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/send-payload.js
var require_send_payload = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/send-payload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      sendEtagResponse: function() {
        return sendEtagResponse;
      },
      sendRenderResult: function() {
        return sendRenderResult;
      }
    });
    var _utils = require_utils3();
    var _etag = require_etag();
    var _fresh = /* @__PURE__ */ _interop_require_default(require_fresh());
    var _revalidate = require_revalidate();
    var _approuterheaders = require_app_router_headers();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function sendEtagResponse(req, res, etag) {
      if (etag) {
        res.setHeader("ETag", etag);
      }
      if ((0, _fresh.default)(req.headers, {
        etag
      })) {
        res.statusCode = 304;
        res.end();
        return true;
      }
      return false;
    }
    async function sendRenderResult({ req, res, result, type, generateEtags, poweredByHeader, revalidate, expireTime }) {
      if ((0, _utils.isResSent)(res)) {
        return;
      }
      if (poweredByHeader && type === "html") {
        res.setHeader("X-Powered-By", "Next.js");
      }
      if (typeof revalidate !== "undefined" && !res.getHeader("Cache-Control")) {
        res.setHeader("Cache-Control", (0, _revalidate.formatRevalidate)({
          revalidate,
          expireTime
        }));
      }
      const payload = result.isDynamic ? null : result.toUnchunkedString();
      if (generateEtags && payload !== null) {
        const etag = (0, _etag.generateETag)(payload);
        if (sendEtagResponse(req, res, etag)) {
          return;
        }
      }
      if (!res.getHeader("Content-Type")) {
        res.setHeader("Content-Type", result.contentType ? result.contentType : type === "rsc" ? _approuterheaders.RSC_CONTENT_TYPE_HEADER : type === "json" ? "application/json" : "text/html; charset=utf-8");
      }
      if (payload) {
        res.setHeader("Content-Length", Buffer.byteLength(payload));
      }
      if (req.method === "HEAD") {
        res.end(null);
        return;
      }
      if (payload !== null) {
        res.end(payload);
        return;
      }
      await result.pipeToNodeResponse(res);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/querystring.js
var require_querystring = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/querystring.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      assign: function() {
        return assign;
      },
      searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
      },
      urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
      }
    });
    function searchParamsToUrlQuery(searchParams) {
      const query = {};
      searchParams.forEach((value, key) => {
        if (typeof query[key] === "undefined") {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [
            query[key],
            value
          ];
        }
      });
      return query;
    }
    function stringifyUrlQueryParam(param) {
      if (typeof param === "string" || typeof param === "number" && !isNaN(param) || typeof param === "boolean") {
        return String(param);
      } else {
        return "";
      }
    }
    function urlQueryToSearchParams(urlQuery) {
      const result = new URLSearchParams();
      Object.entries(urlQuery).forEach((param) => {
        let [key, value] = param;
        if (Array.isArray(value)) {
          value.forEach((item) => result.append(key, stringifyUrlQueryParam(item)));
        } else {
          result.set(key, stringifyUrlQueryParam(value));
        }
      });
      return result;
    }
    function assign(target) {
      for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        searchParamsList[_key - 1] = arguments[_key];
      }
      searchParamsList.forEach((searchParams) => {
        Array.from(searchParams.keys()).forEach((key) => target.delete(key));
        searchParams.forEach((value, key) => target.append(key, value));
      });
      return target;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js
var require_parse_relative_url = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parseRelativeUrl", {
      enumerable: true,
      get: function() {
        return parseRelativeUrl;
      }
    });
    var _utils = require_utils3();
    var _querystring = require_querystring();
    function parseRelativeUrl(url, base, parseQuery) {
      if (parseQuery === void 0)
        parseQuery = true;
      const globalBase = new URL(typeof window === "undefined" ? "http://n" : (0, _utils.getLocationOrigin)());
      const resolvedBase = base ? new URL(base, globalBase) : url.startsWith(".") ? new URL(typeof window === "undefined" ? "http://n" : window.location.href) : globalBase;
      const { pathname, searchParams, search, hash, href, origin } = new URL(url, resolvedBase);
      if (origin !== globalBase.origin) {
        throw new Error("invariant: invalid relative URL, router received " + url);
      }
      return {
        pathname,
        query: parseQuery ? (0, _querystring.searchParamsToUrlQuery)(searchParams) : void 0,
        search,
        hash,
        href: href.slice(origin.length)
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/parse-url.js
var require_parse_url = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/parse-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parseUrl", {
      enumerable: true,
      get: function() {
        return parseUrl;
      }
    });
    var _querystring = require_querystring();
    var _parserelativeurl = require_parse_relative_url();
    function parseUrl(url) {
      if (url.startsWith("/")) {
        return (0, _parserelativeurl.parseRelativeUrl)(url);
      }
      const parsedURL = new URL(url);
      return {
        hash: parsedURL.hash,
        hostname: parsedURL.hostname,
        href: parsedURL.href,
        pathname: parsedURL.pathname,
        port: parsedURL.port,
        protocol: parsedURL.protocol,
        query: (0, _querystring.searchParamsToUrlQuery)(parsedURL.searchParams),
        search: parsedURL.search
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/picocolors.js
var require_picocolors = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/picocolors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      bgBlack: function() {
        return bgBlack;
      },
      bgBlue: function() {
        return bgBlue;
      },
      bgCyan: function() {
        return bgCyan;
      },
      bgGreen: function() {
        return bgGreen;
      },
      bgMagenta: function() {
        return bgMagenta;
      },
      bgRed: function() {
        return bgRed;
      },
      bgWhite: function() {
        return bgWhite;
      },
      bgYellow: function() {
        return bgYellow;
      },
      black: function() {
        return black;
      },
      blue: function() {
        return blue;
      },
      bold: function() {
        return bold;
      },
      cyan: function() {
        return cyan;
      },
      dim: function() {
        return dim;
      },
      gray: function() {
        return gray;
      },
      green: function() {
        return green;
      },
      hidden: function() {
        return hidden;
      },
      inverse: function() {
        return inverse;
      },
      italic: function() {
        return italic;
      },
      magenta: function() {
        return magenta;
      },
      purple: function() {
        return purple;
      },
      red: function() {
        return red;
      },
      reset: function() {
        return reset;
      },
      strikethrough: function() {
        return strikethrough;
      },
      underline: function() {
        return underline;
      },
      white: function() {
        return white;
      },
      yellow: function() {
        return yellow;
      }
    });
    var _globalThis;
    var { env, stdout } = ((_globalThis = globalThis) == null ? void 0 : _globalThis.process) ?? {};
    var enabled = env && !env.NO_COLOR && (env.FORCE_COLOR || (stdout == null ? void 0 : stdout.isTTY) && !env.CI && env.TERM !== "dumb");
    var replaceClose = (str, close, replace, index) => {
      const start = str.substring(0, index) + replace;
      const end = str.substring(index + close.length);
      const nextIndex = end.indexOf(close);
      return ~nextIndex ? start + replaceClose(end, close, replace, nextIndex) : start + end;
    };
    var formatter = (open, close, replace = open) => {
      if (!enabled)
        return String;
      return (input) => {
        const string = "" + input;
        const index = string.indexOf(close, open.length);
        return ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close;
      };
    };
    var reset = enabled ? (s) => `\x1B[0m${s}\x1B[0m` : String;
    var bold = formatter("\x1B[1m", "\x1B[22m", "\x1B[22m\x1B[1m");
    var dim = formatter("\x1B[2m", "\x1B[22m", "\x1B[22m\x1B[2m");
    var italic = formatter("\x1B[3m", "\x1B[23m");
    var underline = formatter("\x1B[4m", "\x1B[24m");
    var inverse = formatter("\x1B[7m", "\x1B[27m");
    var hidden = formatter("\x1B[8m", "\x1B[28m");
    var strikethrough = formatter("\x1B[9m", "\x1B[29m");
    var black = formatter("\x1B[30m", "\x1B[39m");
    var red = formatter("\x1B[31m", "\x1B[39m");
    var green = formatter("\x1B[32m", "\x1B[39m");
    var yellow = formatter("\x1B[33m", "\x1B[39m");
    var blue = formatter("\x1B[34m", "\x1B[39m");
    var magenta = formatter("\x1B[35m", "\x1B[39m");
    var purple = formatter("\x1B[38;2;173;127;168m", "\x1B[39m");
    var cyan = formatter("\x1B[36m", "\x1B[39m");
    var white = formatter("\x1B[37m", "\x1B[39m");
    var gray = formatter("\x1B[90m", "\x1B[39m");
    var bgBlack = formatter("\x1B[40m", "\x1B[49m");
    var bgRed = formatter("\x1B[41m", "\x1B[49m");
    var bgGreen = formatter("\x1B[42m", "\x1B[49m");
    var bgYellow = formatter("\x1B[43m", "\x1B[49m");
    var bgBlue = formatter("\x1B[44m", "\x1B[49m");
    var bgMagenta = formatter("\x1B[45m", "\x1B[49m");
    var bgCyan = formatter("\x1B[46m", "\x1B[49m");
    var bgWhite = formatter("\x1B[47m", "\x1B[49m");
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/build/output/log.js
var require_log = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/build/output/log.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      bootstrap: function() {
        return bootstrap;
      },
      error: function() {
        return error;
      },
      event: function() {
        return event;
      },
      info: function() {
        return info;
      },
      prefixes: function() {
        return prefixes;
      },
      ready: function() {
        return ready;
      },
      trace: function() {
        return trace;
      },
      wait: function() {
        return wait;
      },
      warn: function() {
        return warn;
      },
      warnOnce: function() {
        return warnOnce;
      }
    });
    var _picocolors = require_picocolors();
    var prefixes = {
      wait: (0, _picocolors.white)((0, _picocolors.bold)("\u25CB")),
      error: (0, _picocolors.red)((0, _picocolors.bold)("\u2A2F")),
      warn: (0, _picocolors.yellow)((0, _picocolors.bold)("\u26A0")),
      ready: "\u25B2",
      info: (0, _picocolors.white)((0, _picocolors.bold)(" ")),
      event: (0, _picocolors.green)((0, _picocolors.bold)("\u2713")),
      trace: (0, _picocolors.magenta)((0, _picocolors.bold)("\xBB"))
    };
    var LOGGING_METHOD = {
      log: "log",
      warn: "warn",
      error: "error"
    };
    function prefixedLog(prefixType, ...message) {
      if ((message[0] === "" || message[0] === void 0) && message.length === 1) {
        message.shift();
      }
      const consoleMethod = prefixType in LOGGING_METHOD ? LOGGING_METHOD[prefixType] : "log";
      const prefix = prefixes[prefixType];
      if (message.length === 0) {
        console[consoleMethod]("");
      } else {
        console[consoleMethod](" " + prefix, ...message);
      }
    }
    function bootstrap(...message) {
      console.log(" ", ...message);
    }
    function wait(...message) {
      prefixedLog("wait", ...message);
    }
    function error(...message) {
      prefixedLog("error", ...message);
    }
    function warn(...message) {
      prefixedLog("warn", ...message);
    }
    function ready(...message) {
      prefixedLog("ready", ...message);
    }
    function info(...message) {
      prefixedLog("info", ...message);
    }
    function event(...message) {
      prefixedLog("event", ...message);
    }
    function trace(...message) {
      prefixedLog("trace", ...message);
    }
    var warnOnceMessages = /* @__PURE__ */ new Set();
    function warnOnce(...message) {
      if (!warnOnceMessages.has(message[0])) {
        warnOnceMessages.add(message.join(" "));
        warn(...message);
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js
var require_ensure_leading_slash = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ensureLeadingSlash", {
      enumerable: true,
      get: function() {
        return ensureLeadingSlash;
      }
    });
    function ensureLeadingSlash(path) {
      return path.startsWith("/") ? path : "/" + path;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/segment.js
var require_segment = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/segment.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      DEFAULT_SEGMENT_KEY: function() {
        return DEFAULT_SEGMENT_KEY;
      },
      PAGE_SEGMENT_KEY: function() {
        return PAGE_SEGMENT_KEY;
      },
      addSearchParamsIfPageSegment: function() {
        return addSearchParamsIfPageSegment;
      },
      isGroupSegment: function() {
        return isGroupSegment;
      }
    });
    function isGroupSegment(segment) {
      return segment[0] === "(" && segment.endsWith(")");
    }
    function addSearchParamsIfPageSegment(segment, searchParams) {
      const isPageSegment = segment.includes(PAGE_SEGMENT_KEY);
      if (isPageSegment) {
        const stringifiedQuery = JSON.stringify(searchParams);
        return stringifiedQuery !== "{}" ? PAGE_SEGMENT_KEY + "?" + stringifiedQuery : PAGE_SEGMENT_KEY;
      }
      return segment;
    }
    var PAGE_SEGMENT_KEY = "__PAGE__";
    var DEFAULT_SEGMENT_KEY = "__DEFAULT__";
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/app-paths.js
var require_app_paths = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/app-paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      normalizeAppPath: function() {
        return normalizeAppPath;
      },
      normalizeRscURL: function() {
        return normalizeRscURL;
      }
    });
    var _ensureleadingslash = require_ensure_leading_slash();
    var _segment = require_segment();
    function normalizeAppPath(route) {
      return (0, _ensureleadingslash.ensureLeadingSlash)(route.split("/").reduce((pathname, segment, index, segments) => {
        if (!segment) {
          return pathname;
        }
        if ((0, _segment.isGroupSegment)(segment)) {
          return pathname;
        }
        if (segment[0] === "@") {
          return pathname;
        }
        if ((segment === "page" || segment === "route") && index === segments.length - 1) {
          return pathname;
        }
        return pathname + "/" + segment;
      }, ""));
    }
    function normalizeRscURL(url) {
      return url.replace(
        /\.rsc($|\?)/,
        // $1 ensures `?` is preserved
        "$1"
      );
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/interception-routes.js
var require_interception_routes = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/interception-routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      INTERCEPTION_ROUTE_MARKERS: function() {
        return INTERCEPTION_ROUTE_MARKERS;
      },
      extractInterceptionRouteInformation: function() {
        return extractInterceptionRouteInformation;
      },
      isInterceptionRouteAppPath: function() {
        return isInterceptionRouteAppPath;
      }
    });
    var _apppaths = require_app_paths();
    var INTERCEPTION_ROUTE_MARKERS = [
      "(..)(..)",
      "(.)",
      "(..)",
      "(...)"
    ];
    function isInterceptionRouteAppPath(path) {
      return path.split("/").find((segment) => INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))) !== void 0;
    }
    function extractInterceptionRouteInformation(path) {
      let interceptingRoute, marker, interceptedRoute;
      for (const segment of path.split("/")) {
        marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
        if (marker) {
          [interceptingRoute, interceptedRoute] = path.split(marker, 2);
          break;
        }
      }
      if (!interceptingRoute || !marker || !interceptedRoute) {
        throw new Error(`Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);
      }
      interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute);
      switch (marker) {
        case "(.)":
          if (interceptingRoute === "/") {
            interceptedRoute = `/${interceptedRoute}`;
          } else {
            interceptedRoute = interceptingRoute + "/" + interceptedRoute;
          }
          break;
        case "(..)":
          if (interceptingRoute === "/") {
            throw new Error(`Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`);
          }
          interceptedRoute = interceptingRoute.split("/").slice(0, -1).concat(interceptedRoute).join("/");
          break;
        case "(...)":
          interceptedRoute = "/" + interceptedRoute;
          break;
        case "(..)(..)":
          const splitInterceptingRoute = interceptingRoute.split("/");
          if (splitInterceptingRoute.length <= 2) {
            throw new Error(`Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`);
          }
          interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join("/");
          break;
        default:
          throw new Error("Invariant: unexpected marker");
      }
      return {
        interceptingRoute,
        interceptedRoute
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/escape-regexp.js
var require_escape_regexp = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/escape-regexp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "escapeStringRegexp", {
      enumerable: true,
      get: function() {
        return escapeStringRegexp;
      }
    });
    var reHasRegExp = /[|\\{}()[\]^$+*?.-]/;
    var reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
    function escapeStringRegexp(str) {
      if (reHasRegExp.test(str)) {
        return str.replace(reReplaceRegExp, "\\$&");
      }
      return str;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js
var require_remove_trailing_slash = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removeTrailingSlash", {
      enumerable: true,
      get: function() {
        return removeTrailingSlash;
      }
    });
    function removeTrailingSlash(route) {
      return route.replace(/\/$/, "") || "/";
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/route-regex.js
var require_route_regex = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/route-regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getNamedMiddlewareRegex: function() {
        return getNamedMiddlewareRegex;
      },
      getNamedRouteRegex: function() {
        return getNamedRouteRegex;
      },
      getRouteRegex: function() {
        return getRouteRegex;
      },
      parseParameter: function() {
        return parseParameter;
      }
    });
    var _constants = require_constants();
    var _interceptionroutes = require_interception_routes();
    var _escaperegexp = require_escape_regexp();
    var _removetrailingslash = require_remove_trailing_slash();
    var PARAMETER_PATTERN = /\[((?:\[.*\])|.+)\]/;
    function parseParameter(param) {
      const match = param.match(PARAMETER_PATTERN);
      if (!match) {
        return parseMatchedParameter(param);
      }
      return parseMatchedParameter(match[1]);
    }
    function parseMatchedParameter(param) {
      const optional = param.startsWith("[") && param.endsWith("]");
      if (optional) {
        param = param.slice(1, -1);
      }
      const repeat = param.startsWith("...");
      if (repeat) {
        param = param.slice(3);
      }
      return {
        key: param,
        repeat,
        optional
      };
    }
    function getParametrizedRoute(route) {
      const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split("/");
      const groups = {};
      let groupIndex = 1;
      return {
        parameterizedRoute: segments.map((segment) => {
          const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
          const paramMatches = segment.match(PARAMETER_PATTERN);
          if (markerMatch && paramMatches) {
            const { key, optional, repeat } = parseMatchedParameter(paramMatches[1]);
            groups[key] = {
              pos: groupIndex++,
              repeat,
              optional
            };
            return "/" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + "([^/]+?)";
          } else if (paramMatches) {
            const { key, repeat, optional } = parseMatchedParameter(paramMatches[1]);
            groups[key] = {
              pos: groupIndex++,
              repeat,
              optional
            };
            return repeat ? optional ? "(?:/(.+?))?" : "/(.+?)" : "/([^/]+?)";
          } else {
            return "/" + (0, _escaperegexp.escapeStringRegexp)(segment);
          }
        }).join(""),
        groups
      };
    }
    function getRouteRegex(normalizedRoute) {
      const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute);
      return {
        re: new RegExp("^" + parameterizedRoute + "(?:/)?$"),
        groups
      };
    }
    function buildGetSafeRouteKey() {
      let i = 0;
      return () => {
        let routeKey = "";
        let j = ++i;
        while (j > 0) {
          routeKey += String.fromCharCode(97 + (j - 1) % 26);
          j = Math.floor((j - 1) / 26);
        }
        return routeKey;
      };
    }
    function getSafeKeyFromSegment(param) {
      let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix } = param;
      const { key, optional, repeat } = parseMatchedParameter(segment);
      let cleanedKey = key.replace(/\W/g, "");
      if (keyPrefix) {
        cleanedKey = "" + keyPrefix + cleanedKey;
      }
      let invalidKey = false;
      if (cleanedKey.length === 0 || cleanedKey.length > 30) {
        invalidKey = true;
      }
      if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {
        invalidKey = true;
      }
      if (invalidKey) {
        cleanedKey = getSafeRouteKey();
      }
      if (keyPrefix) {
        routeKeys[cleanedKey] = "" + keyPrefix + key;
      } else {
        routeKeys[cleanedKey] = key;
      }
      const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : "";
      return repeat ? optional ? "(?:/" + interceptionPrefix + "(?<" + cleanedKey + ">.+?))?" : "/" + interceptionPrefix + "(?<" + cleanedKey + ">.+?)" : "/" + interceptionPrefix + "(?<" + cleanedKey + ">[^/]+?)";
    }
    function getNamedParametrizedRoute(route, prefixRouteKeys) {
      const segments = (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split("/");
      const getSafeRouteKey = buildGetSafeRouteKey();
      const routeKeys = {};
      return {
        namedParameterizedRoute: segments.map((segment) => {
          const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m));
          const paramMatches = segment.match(/\[((?:\[.*\])|.+)\]/);
          if (hasInterceptionMarker && paramMatches) {
            const [usedMarker] = segment.split(paramMatches[0]);
            return getSafeKeyFromSegment({
              getSafeRouteKey,
              interceptionMarker: usedMarker,
              segment: paramMatches[1],
              routeKeys,
              keyPrefix: prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : void 0
            });
          } else if (paramMatches) {
            return getSafeKeyFromSegment({
              getSafeRouteKey,
              segment: paramMatches[1],
              routeKeys,
              keyPrefix: prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : void 0
            });
          } else {
            return "/" + (0, _escaperegexp.escapeStringRegexp)(segment);
          }
        }).join(""),
        routeKeys
      };
    }
    function getNamedRouteRegex(normalizedRoute, prefixRouteKey) {
      const result = getNamedParametrizedRoute(normalizedRoute, prefixRouteKey);
      return {
        ...getRouteRegex(normalizedRoute),
        namedRegex: "^" + result.namedParameterizedRoute + "(?:/)?$",
        routeKeys: result.routeKeys
      };
    }
    function getNamedMiddlewareRegex(normalizedRoute, options) {
      const { parameterizedRoute } = getParametrizedRoute(normalizedRoute);
      const { catchAll = true } = options;
      if (parameterizedRoute === "/") {
        let catchAllRegex = catchAll ? ".*" : "";
        return {
          namedRegex: "^/" + catchAllRegex + "$"
        };
      }
      const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false);
      let catchAllGroupedRegex = catchAll ? "(?:(/.*)?)" : "";
      return {
        namedRegex: "^" + namedParameterizedRoute + catchAllGroupedRegex + "$"
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/request/fallback-params.js
var require_fallback_params = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/request/fallback-params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getFallbackRouteParams: function() {
        return getFallbackRouteParams;
      },
      getParamKeys: function() {
        return getParamKeys;
      }
    });
    var _routematcher = require_route_matcher();
    var _routeregex = require_route_regex();
    function getParamKeys(page) {
      const pattern = (0, _routeregex.getRouteRegex)(page);
      const matcher = (0, _routematcher.getRouteMatcher)(pattern);
      return Object.keys(matcher(page));
    }
    function getFallbackRouteParams(pageOrKeys) {
      let keys;
      if (typeof pageOrKeys === "string") {
        keys = getParamKeys(pageOrKeys);
      } else {
        keys = pageOrKeys;
      }
      if (keys.length === 0)
        return null;
      const params = /* @__PURE__ */ new Map();
      const uniqueID = Math.random().toString(16).slice(2);
      for (const key of keys) {
        params.set(key, `%%drp:${key}:${uniqueID}%%`);
      }
      return params;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/response-cache/types.js
var require_types = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/response-cache/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      CachedRouteKind: function() {
        return CachedRouteKind;
      },
      IncrementalCacheKind: function() {
        return IncrementalCacheKind;
      }
    });
    var CachedRouteKind;
    (function(CachedRouteKind2) {
      CachedRouteKind2["APP_PAGE"] = "APP_PAGE";
      CachedRouteKind2["APP_ROUTE"] = "APP_ROUTE";
      CachedRouteKind2["PAGES"] = "PAGES";
      CachedRouteKind2["FETCH"] = "FETCH";
      CachedRouteKind2["REDIRECT"] = "REDIRECT";
      CachedRouteKind2["IMAGE"] = "IMAGE";
    })(CachedRouteKind || (CachedRouteKind = {}));
    var IncrementalCacheKind;
    (function(IncrementalCacheKind2) {
      IncrementalCacheKind2["APP_PAGE"] = "APP_PAGE";
      IncrementalCacheKind2["APP_ROUTE"] = "APP_ROUTE";
      IncrementalCacheKind2["PAGES"] = "PAGES";
      IncrementalCacheKind2["FETCH"] = "FETCH";
      IncrementalCacheKind2["IMAGE"] = "IMAGE";
    })(IncrementalCacheKind || (IncrementalCacheKind = {}));
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/detached-promise.js
var require_detached_promise = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/detached-promise.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DetachedPromise", {
      enumerable: true,
      get: function() {
        return DetachedPromise;
      }
    });
    var DetachedPromise = class {
      constructor() {
        let resolve;
        let reject;
        this.promise = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        });
        this.resolve = resolve;
        this.reject = reject;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/batcher.js
var require_batcher = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/batcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Batcher", {
      enumerable: true,
      get: function() {
        return Batcher;
      }
    });
    var _detachedpromise = require_detached_promise();
    var Batcher = class {
      constructor(cacheKeyFn, schedulerFn = (fn) => fn()) {
        this.cacheKeyFn = cacheKeyFn;
        this.schedulerFn = schedulerFn;
        this.pending = /* @__PURE__ */ new Map();
      }
      static create(options) {
        return new Batcher(options == null ? void 0 : options.cacheKeyFn, options == null ? void 0 : options.schedulerFn);
      }
      /**
      * Wraps a function in a promise that will be resolved or rejected only once
      * for a given key. This will allow multiple calls to the function to be
      * made, but only one will be executed at a time. The result of the first
      * call will be returned to all callers.
      *
      * @param key the key to use for the cache
      * @param fn the function to wrap
      * @returns a promise that resolves to the result of the function
      */
      async batch(key, fn) {
        const cacheKey = this.cacheKeyFn ? await this.cacheKeyFn(key) : key;
        if (cacheKey === null) {
          return fn(cacheKey, Promise.resolve);
        }
        const pending = this.pending.get(cacheKey);
        if (pending)
          return pending;
        const { promise, resolve, reject } = new _detachedpromise.DetachedPromise();
        this.pending.set(cacheKey, promise);
        this.schedulerFn(async () => {
          try {
            const result = await fn(cacheKey, resolve);
            resolve(result);
          } catch (err) {
            reject(err);
          } finally {
            this.pending.delete(cacheKey);
          }
        });
        return promise;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/scheduler.js
var require_scheduler = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/scheduler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      atLeastOneTask: function() {
        return atLeastOneTask;
      },
      scheduleImmediate: function() {
        return scheduleImmediate;
      },
      scheduleOnNextTick: function() {
        return scheduleOnNextTick;
      },
      waitAtLeastOneReactRenderTask: function() {
        return waitAtLeastOneReactRenderTask;
      }
    });
    var scheduleOnNextTick = (cb) => {
      Promise.resolve().then(() => {
        if (false) {
          setTimeout(cb, 0);
        } else {
          process.nextTick(cb);
        }
      });
    };
    var scheduleImmediate = (cb) => {
      if (false) {
        setTimeout(cb, 0);
      } else {
        setImmediate(cb);
      }
    };
    function atLeastOneTask() {
      return new Promise((resolve) => scheduleImmediate(resolve));
    }
    function waitAtLeastOneReactRenderTask() {
      if (false) {
        return new Promise((r) => setTimeout(r, 0));
      } else {
        return new Promise((r) => setImmediate(r));
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/stream-utils/encodedTags.js
var require_encodedTags = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/stream-utils/encodedTags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ENCODED_TAGS", {
      enumerable: true,
      get: function() {
        return ENCODED_TAGS;
      }
    });
    var ENCODED_TAGS = {
      // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`
      OPENING: {
        // <html
        HTML: new Uint8Array([
          60,
          104,
          116,
          109,
          108
        ]),
        // <body
        BODY: new Uint8Array([
          60,
          98,
          111,
          100,
          121
        ])
      },
      CLOSED: {
        // </head>
        HEAD: new Uint8Array([
          60,
          47,
          104,
          101,
          97,
          100,
          62
        ]),
        // </body>
        BODY: new Uint8Array([
          60,
          47,
          98,
          111,
          100,
          121,
          62
        ]),
        // </html>
        HTML: new Uint8Array([
          60,
          47,
          104,
          116,
          109,
          108,
          62
        ]),
        // </body></html>
        BODY_AND_HTML: new Uint8Array([
          60,
          47,
          98,
          111,
          100,
          121,
          62,
          60,
          47,
          104,
          116,
          109,
          108,
          62
        ])
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/stream-utils/uint8array-helpers.js
var require_uint8array_helpers = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/stream-utils/uint8array-helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      indexOfUint8Array: function() {
        return indexOfUint8Array;
      },
      isEquivalentUint8Arrays: function() {
        return isEquivalentUint8Arrays;
      },
      removeFromUint8Array: function() {
        return removeFromUint8Array;
      }
    });
    function indexOfUint8Array(a, b) {
      if (b.length === 0)
        return 0;
      if (a.length === 0 || b.length > a.length)
        return -1;
      for (let i = 0; i <= a.length - b.length; i++) {
        let completeMatch = true;
        for (let j = 0; j < b.length; j++) {
          if (a[i + j] !== b[j]) {
            completeMatch = false;
            break;
          }
        }
        if (completeMatch) {
          return i;
        }
      }
      return -1;
    }
    function isEquivalentUint8Arrays(a, b) {
      if (a.length !== b.length)
        return false;
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i])
          return false;
      }
      return true;
    }
    function removeFromUint8Array(a, b) {
      const tagIndex = indexOfUint8Array(a, b);
      if (tagIndex === 0)
        return a.subarray(b.length);
      if (tagIndex > -1) {
        const removed = new Uint8Array(a.length - b.length);
        removed.set(a.slice(0, tagIndex));
        removed.set(a.slice(tagIndex + b.length), tagIndex);
        return removed;
      } else {
        return a;
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/stream-utils/node-web-streams-helper.js
var require_node_web_streams_helper = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/stream-utils/node-web-streams-helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      chainStreams: function() {
        return chainStreams;
      },
      continueDynamicHTMLResume: function() {
        return continueDynamicHTMLResume;
      },
      continueDynamicPrerender: function() {
        return continueDynamicPrerender;
      },
      continueFizzStream: function() {
        return continueFizzStream;
      },
      continueStaticPrerender: function() {
        return continueStaticPrerender;
      },
      createBufferedTransformStream: function() {
        return createBufferedTransformStream;
      },
      createDocumentClosingStream: function() {
        return createDocumentClosingStream;
      },
      createRootLayoutValidatorStream: function() {
        return createRootLayoutValidatorStream;
      },
      renderToInitialFizzStream: function() {
        return renderToInitialFizzStream;
      },
      streamFromBuffer: function() {
        return streamFromBuffer;
      },
      streamFromString: function() {
        return streamFromString;
      },
      streamToBuffer: function() {
        return streamToBuffer;
      },
      streamToString: function() {
        return streamToString;
      }
    });
    var _tracer = require_tracer();
    var _constants = require_constants2();
    var _detachedpromise = require_detached_promise();
    var _scheduler = require_scheduler();
    var _encodedTags = require_encodedTags();
    var _uint8arrayhelpers = require_uint8array_helpers();
    function voidCatch() {
    }
    var encoder = new TextEncoder();
    function chainStreams(...streams) {
      if (streams.length === 0) {
        throw new Error("Invariant: chainStreams requires at least one stream");
      }
      if (streams.length === 1) {
        return streams[0];
      }
      const { readable, writable } = new TransformStream();
      let promise = streams[0].pipeTo(writable, {
        preventClose: true
      });
      let i = 1;
      for (; i < streams.length - 1; i++) {
        const nextStream = streams[i];
        promise = promise.then(() => nextStream.pipeTo(writable, {
          preventClose: true
        }));
      }
      const lastStream = streams[i];
      promise = promise.then(() => lastStream.pipeTo(writable));
      promise.catch(voidCatch);
      return readable;
    }
    function streamFromString(str) {
      return new ReadableStream({
        start(controller) {
          controller.enqueue(encoder.encode(str));
          controller.close();
        }
      });
    }
    function streamFromBuffer(chunk) {
      return new ReadableStream({
        start(controller) {
          controller.enqueue(chunk);
          controller.close();
        }
      });
    }
    async function streamToBuffer(stream) {
      const reader = stream.getReader();
      const chunks = [];
      while (true) {
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        chunks.push(value);
      }
      return Buffer.concat(chunks);
    }
    async function streamToString(stream) {
      const decoder = new TextDecoder("utf-8", {
        fatal: true
      });
      let string = "";
      for await (const chunk of stream) {
        string += decoder.decode(chunk, {
          stream: true
        });
      }
      string += decoder.decode();
      return string;
    }
    function createBufferedTransformStream() {
      let bufferedChunks = [];
      let bufferByteLength = 0;
      let pending;
      const flush = (controller) => {
        if (pending)
          return;
        const detached = new _detachedpromise.DetachedPromise();
        pending = detached;
        (0, _scheduler.scheduleImmediate)(() => {
          try {
            const chunk = new Uint8Array(bufferByteLength);
            let copiedBytes = 0;
            for (let i = 0; i < bufferedChunks.length; i++) {
              const bufferedChunk = bufferedChunks[i];
              chunk.set(bufferedChunk, copiedBytes);
              copiedBytes += bufferedChunk.byteLength;
            }
            bufferedChunks.length = 0;
            bufferByteLength = 0;
            controller.enqueue(chunk);
          } catch {
          } finally {
            pending = void 0;
            detached.resolve();
          }
        });
      };
      return new TransformStream({
        transform(chunk, controller) {
          bufferedChunks.push(chunk);
          bufferByteLength += chunk.byteLength;
          flush(controller);
        },
        flush() {
          if (!pending)
            return;
          return pending.promise;
        }
      });
    }
    function createInsertedHTMLStream(getServerInsertedHTML) {
      return new TransformStream({
        transform: async (chunk, controller) => {
          const html = await getServerInsertedHTML();
          if (html) {
            controller.enqueue(encoder.encode(html));
          }
          controller.enqueue(chunk);
        }
      });
    }
    function renderToInitialFizzStream({ ReactDOMServer, element, streamOptions }) {
      return (0, _tracer.getTracer)().trace(_constants.AppRenderSpan.renderToReadableStream, async () => ReactDOMServer.renderToReadableStream(element, streamOptions));
    }
    function createHeadInsertionTransformStream(insert) {
      let inserted = false;
      let freezing = false;
      let hasBytes = false;
      return new TransformStream({
        async transform(chunk, controller) {
          hasBytes = true;
          if (freezing) {
            controller.enqueue(chunk);
            return;
          }
          const insertion = await insert();
          if (inserted) {
            if (insertion) {
              const encodedInsertion = encoder.encode(insertion);
              controller.enqueue(encodedInsertion);
            }
            controller.enqueue(chunk);
            freezing = true;
          } else {
            const index = (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.HEAD);
            if (index !== -1) {
              if (insertion) {
                const encodedInsertion = encoder.encode(insertion);
                const insertedHeadContent = new Uint8Array(chunk.length + encodedInsertion.length);
                insertedHeadContent.set(chunk.slice(0, index));
                insertedHeadContent.set(encodedInsertion, index);
                insertedHeadContent.set(chunk.slice(index), index + encodedInsertion.length);
                controller.enqueue(insertedHeadContent);
              } else {
                controller.enqueue(chunk);
              }
              freezing = true;
              inserted = true;
            }
          }
          if (!inserted) {
            controller.enqueue(chunk);
          } else {
            (0, _scheduler.scheduleImmediate)(() => {
              freezing = false;
            });
          }
        },
        async flush(controller) {
          if (hasBytes) {
            const insertion = await insert();
            if (insertion) {
              controller.enqueue(encoder.encode(insertion));
            }
          }
        }
      });
    }
    function createDeferredSuffixStream(suffix) {
      let flushed = false;
      let pending;
      const flush = (controller) => {
        const detached = new _detachedpromise.DetachedPromise();
        pending = detached;
        (0, _scheduler.scheduleImmediate)(() => {
          try {
            controller.enqueue(encoder.encode(suffix));
          } catch {
          } finally {
            pending = void 0;
            detached.resolve();
          }
        });
      };
      return new TransformStream({
        transform(chunk, controller) {
          controller.enqueue(chunk);
          if (flushed)
            return;
          flushed = true;
          flush(controller);
        },
        flush(controller) {
          if (pending)
            return pending.promise;
          if (flushed)
            return;
          controller.enqueue(encoder.encode(suffix));
        }
      });
    }
    function createMergedTransformStream(stream) {
      let pull = null;
      let donePulling = false;
      async function startPulling(controller) {
        if (pull) {
          return;
        }
        const reader = stream.getReader();
        await (0, _scheduler.atLeastOneTask)();
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              donePulling = true;
              return;
            }
            controller.enqueue(value);
          }
        } catch (err) {
          controller.error(err);
        }
      }
      return new TransformStream({
        transform(chunk, controller) {
          controller.enqueue(chunk);
          if (!pull) {
            pull = startPulling(controller);
          }
        },
        flush(controller) {
          if (donePulling) {
            return;
          }
          return pull || startPulling(controller);
        }
      });
    }
    var CLOSE_TAG = "</body></html>";
    function createMoveSuffixStream() {
      let foundSuffix = false;
      return new TransformStream({
        transform(chunk, controller) {
          if (foundSuffix) {
            return controller.enqueue(chunk);
          }
          const index = (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);
          if (index > -1) {
            foundSuffix = true;
            if (chunk.length === _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {
              return;
            }
            const before = chunk.slice(0, index);
            controller.enqueue(before);
            if (chunk.length > _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {
              const after = chunk.slice(index + _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML.length);
              controller.enqueue(after);
            }
          } else {
            controller.enqueue(chunk);
          }
        },
        flush(controller) {
          controller.enqueue(_encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);
        }
      });
    }
    function createStripDocumentClosingTagsTransform() {
      return new TransformStream({
        transform(chunk, controller) {
          if ((0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML) || (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.BODY) || (0, _uint8arrayhelpers.isEquivalentUint8Arrays)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.HTML)) {
            return;
          }
          chunk = (0, _uint8arrayhelpers.removeFromUint8Array)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.BODY);
          chunk = (0, _uint8arrayhelpers.removeFromUint8Array)(chunk, _encodedTags.ENCODED_TAGS.CLOSED.HTML);
          controller.enqueue(chunk);
        }
      });
    }
    function createRootLayoutValidatorStream() {
      let foundHtml = false;
      let foundBody = false;
      return new TransformStream({
        async transform(chunk, controller) {
          if (!foundHtml && (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedTags.ENCODED_TAGS.OPENING.HTML) > -1) {
            foundHtml = true;
          }
          if (!foundBody && (0, _uint8arrayhelpers.indexOfUint8Array)(chunk, _encodedTags.ENCODED_TAGS.OPENING.BODY) > -1) {
            foundBody = true;
          }
          controller.enqueue(chunk);
        },
        flush(controller) {
          const missingTags = [];
          if (!foundHtml)
            missingTags.push("html");
          if (!foundBody)
            missingTags.push("body");
          if (!missingTags.length)
            return;
          controller.enqueue(encoder.encode(`<script>self.__next_root_layout_missing_tags=${JSON.stringify(missingTags)}</script>`));
        }
      });
    }
    function chainTransformers(readable, transformers) {
      let stream = readable;
      for (const transformer of transformers) {
        if (!transformer)
          continue;
        stream = stream.pipeThrough(transformer);
      }
      return stream;
    }
    async function continueFizzStream(renderStream, { suffix, inlinedDataStream, isStaticGeneration, getServerInsertedHTML, serverInsertedHTMLToHead, validateRootLayout }) {
      const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null;
      if (isStaticGeneration && "allReady" in renderStream) {
        await renderStream.allReady;
      }
      return chainTransformers(renderStream, [
        // Buffer everything to avoid flushing too frequently
        createBufferedTransformStream(),
        // Insert generated tags to head
        getServerInsertedHTML && !serverInsertedHTMLToHead ? createInsertedHTMLStream(getServerInsertedHTML) : null,
        // Insert suffix content
        suffixUnclosed != null && suffixUnclosed.length > 0 ? createDeferredSuffixStream(suffixUnclosed) : null,
        // Insert the inlined data (Flight data, form state, etc.) stream into the HTML
        inlinedDataStream ? createMergedTransformStream(inlinedDataStream) : null,
        // Validate the root layout for missing html or body tags
        validateRootLayout ? createRootLayoutValidatorStream() : null,
        // Close tags should always be deferred to the end
        createMoveSuffixStream(),
        // Special head insertions
        // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid
        // hydration errors. Remove this once it's ready to be handled by react itself.
        getServerInsertedHTML && serverInsertedHTMLToHead ? createHeadInsertionTransformStream(getServerInsertedHTML) : null
      ]);
    }
    async function continueDynamicPrerender(prerenderStream, { getServerInsertedHTML }) {
      return prerenderStream.pipeThrough(createBufferedTransformStream()).pipeThrough(createStripDocumentClosingTagsTransform()).pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML));
    }
    async function continueStaticPrerender(prerenderStream, { inlinedDataStream, getServerInsertedHTML }) {
      return prerenderStream.pipeThrough(createBufferedTransformStream()).pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)).pipeThrough(createMergedTransformStream(inlinedDataStream)).pipeThrough(createMoveSuffixStream());
    }
    async function continueDynamicHTMLResume(renderStream, { inlinedDataStream, getServerInsertedHTML }) {
      return renderStream.pipeThrough(createBufferedTransformStream()).pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML)).pipeThrough(createMergedTransformStream(inlinedDataStream)).pipeThrough(createMoveSuffixStream());
    }
    function createDocumentClosingStream() {
      return streamFromString(CLOSE_TAG);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js
var require_detect_domain_locale = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "detectDomainLocale", {
      enumerable: true,
      get: function() {
        return detectDomainLocale;
      }
    });
    function detectDomainLocale(domainItems, hostname, detectedLocale) {
      if (!domainItems)
        return;
      if (detectedLocale) {
        detectedLocale = detectedLocale.toLowerCase();
      }
      for (const item of domainItems) {
        var _item_domain, _item_locales;
        const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(":", 1)[0].toLowerCase();
        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale) => locale.toLowerCase() === detectedLocale))) {
          return item;
        }
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/parse-path.js
var require_parse_path = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/parse-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parsePath", {
      enumerable: true,
      get: function() {
        return parsePath;
      }
    });
    function parsePath(path) {
      const hashIndex = path.indexOf("#");
      const queryIndex = path.indexOf("?");
      const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
      if (hasQuery || hashIndex > -1) {
        return {
          pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
          query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : void 0) : "",
          hash: hashIndex > -1 ? path.slice(hashIndex) : ""
        };
      }
      return {
        pathname: path,
        query: "",
        hash: ""
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js
var require_add_path_prefix = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addPathPrefix", {
      enumerable: true,
      get: function() {
        return addPathPrefix;
      }
    });
    var _parsepath = require_parse_path();
    function addPathPrefix(path, prefix) {
      if (!path.startsWith("/") || !prefix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
      return "" + prefix + pathname + query + hash;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js
var require_add_path_suffix = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addPathSuffix", {
      enumerable: true,
      get: function() {
        return addPathSuffix;
      }
    });
    var _parsepath = require_parse_path();
    function addPathSuffix(path, suffix) {
      if (!path.startsWith("/") || !suffix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
      return "" + pathname + suffix + query + hash;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js
var require_path_has_prefix = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "pathHasPrefix", {
      enumerable: true,
      get: function() {
        return pathHasPrefix;
      }
    });
    var _parsepath = require_parse_path();
    function pathHasPrefix(path, prefix) {
      if (typeof path !== "string") {
        return false;
      }
      const { pathname } = (0, _parsepath.parsePath)(path);
      return pathname === prefix || pathname.startsWith(prefix + "/");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/add-locale.js
var require_add_locale = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/add-locale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addLocale", {
      enumerable: true,
      get: function() {
        return addLocale;
      }
    });
    var _addpathprefix = require_add_path_prefix();
    var _pathhasprefix = require_path_has_prefix();
    function addLocale(path, locale, defaultLocale, ignorePrefix) {
      if (!locale || locale === defaultLocale)
        return path;
      const lower = path.toLowerCase();
      if (!ignorePrefix) {
        if ((0, _pathhasprefix.pathHasPrefix)(lower, "/api"))
          return path;
        if ((0, _pathhasprefix.pathHasPrefix)(lower, "/" + locale.toLowerCase()))
          return path;
      }
      return (0, _addpathprefix.addPathPrefix)(path, "/" + locale);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js
var require_format_next_pathname_info = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "formatNextPathnameInfo", {
      enumerable: true,
      get: function() {
        return formatNextPathnameInfo;
      }
    });
    var _removetrailingslash = require_remove_trailing_slash();
    var _addpathprefix = require_add_path_prefix();
    var _addpathsuffix = require_add_path_suffix();
    var _addlocale = require_add_locale();
    function formatNextPathnameInfo(info) {
      let pathname = (0, _addlocale.addLocale)(info.pathname, info.locale, info.buildId ? void 0 : info.defaultLocale, info.ignorePrefix);
      if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);
      }
      if (info.buildId) {
        pathname = (0, _addpathsuffix.addPathSuffix)((0, _addpathprefix.addPathPrefix)(pathname, "/_next/data/" + info.buildId), info.pathname === "/" ? "index.json" : ".json");
      }
      pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);
      return !info.buildId && info.trailingSlash ? !pathname.endsWith("/") ? (0, _addpathsuffix.addPathSuffix)(pathname, "/") : pathname : (0, _removetrailingslash.removeTrailingSlash)(pathname);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/get-hostname.js
var require_get_hostname = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/get-hostname.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getHostname", {
      enumerable: true,
      get: function() {
        return getHostname;
      }
    });
    function getHostname(parsed, headers) {
      let hostname;
      if ((headers == null ? void 0 : headers.host) && !Array.isArray(headers.host)) {
        hostname = headers.host.toString().split(":", 1)[0];
      } else if (parsed.hostname) {
        hostname = parsed.hostname;
      } else
        return;
      return hostname.toLowerCase();
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js
var require_normalize_locale_path = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizeLocalePath", {
      enumerable: true,
      get: function() {
        return normalizeLocalePath;
      }
    });
    function normalizeLocalePath(pathname, locales) {
      let detectedLocale;
      const pathnameParts = pathname.split("/");
      (locales || []).some((locale) => {
        if (pathnameParts[1] && pathnameParts[1].toLowerCase() === locale.toLowerCase()) {
          detectedLocale = locale;
          pathnameParts.splice(1, 1);
          pathname = pathnameParts.join("/") || "/";
          return true;
        }
        return false;
      });
      return {
        pathname,
        detectedLocale
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js
var require_remove_path_prefix = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removePathPrefix", {
      enumerable: true,
      get: function() {
        return removePathPrefix;
      }
    });
    var _pathhasprefix = require_path_has_prefix();
    function removePathPrefix(path, prefix) {
      if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {
        return path;
      }
      const withoutPrefix = path.slice(prefix.length);
      if (withoutPrefix.startsWith("/")) {
        return withoutPrefix;
      }
      return "/" + withoutPrefix;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js
var require_get_next_pathname_info = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getNextPathnameInfo", {
      enumerable: true,
      get: function() {
        return getNextPathnameInfo;
      }
    });
    var _normalizelocalepath = require_normalize_locale_path();
    var _removepathprefix = require_remove_path_prefix();
    var _pathhasprefix = require_path_has_prefix();
    function getNextPathnameInfo(pathname, options) {
      var _options_nextConfig;
      const { basePath, i18n, trailingSlash } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};
      const info = {
        pathname,
        trailingSlash: pathname !== "/" ? pathname.endsWith("/") : trailingSlash
      };
      if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {
        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);
        info.basePath = basePath;
      }
      let pathnameNoDataPrefix = info.pathname;
      if (info.pathname.startsWith("/_next/data/") && info.pathname.endsWith(".json")) {
        const paths = info.pathname.replace(/^\/_next\/data\//, "").replace(/\.json$/, "").split("/");
        const buildId = paths[0];
        info.buildId = buildId;
        pathnameNoDataPrefix = paths[1] !== "index" ? "/" + paths.slice(1).join("/") : "/";
        if (options.parseData === true) {
          info.pathname = pathnameNoDataPrefix;
        }
      }
      if (i18n) {
        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;
        if (!result.detectedLocale && info.buildId) {
          result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, _normalizelocalepath.normalizeLocalePath)(pathnameNoDataPrefix, i18n.locales);
          if (result.detectedLocale) {
            info.locale = result.detectedLocale;
          }
        }
      }
      return info;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/next-url.js
var require_next_url = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/next-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NextURL", {
      enumerable: true,
      get: function() {
        return NextURL;
      }
    });
    var _detectdomainlocale = require_detect_domain_locale();
    var _formatnextpathnameinfo = require_format_next_pathname_info();
    var _gethostname = require_get_hostname();
    var _getnextpathnameinfo = require_get_next_pathname_info();
    var REGEX_LOCALHOST_HOSTNAME = /(?!^https?:\/\/)(127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}|\[::1\]|localhost)/;
    function parseURL(url, base) {
      return new URL(String(url).replace(REGEX_LOCALHOST_HOSTNAME, "localhost"), base && String(base).replace(REGEX_LOCALHOST_HOSTNAME, "localhost"));
    }
    var Internal = Symbol("NextURLInternal");
    var NextURL = class {
      constructor(input, baseOrOpts, opts) {
        let base;
        let options;
        if (typeof baseOrOpts === "object" && "pathname" in baseOrOpts || typeof baseOrOpts === "string") {
          base = baseOrOpts;
          options = opts || {};
        } else {
          options = opts || baseOrOpts || {};
        }
        this[Internal] = {
          url: parseURL(input, base ?? options.base),
          options,
          basePath: ""
        };
        this.analyze();
      }
      analyze() {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig, _this_Internal_domainLocale, _this_Internal_options_nextConfig_i18n1, _this_Internal_options_nextConfig1;
        const info = (0, _getnextpathnameinfo.getNextPathnameInfo)(this[Internal].url.pathname, {
          nextConfig: this[Internal].options.nextConfig,
          parseData: !process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE,
          i18nProvider: this[Internal].options.i18nProvider
        });
        const hostname = (0, _gethostname.getHostname)(this[Internal].url, this[Internal].options.headers);
        this[Internal].domainLocale = this[Internal].options.i18nProvider ? this[Internal].options.i18nProvider.detectDomainLocale(hostname) : (0, _detectdomainlocale.detectDomainLocale)((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.domains, hostname);
        const defaultLocale = ((_this_Internal_domainLocale = this[Internal].domainLocale) == null ? void 0 : _this_Internal_domainLocale.defaultLocale) || ((_this_Internal_options_nextConfig1 = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n1 = _this_Internal_options_nextConfig1.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n1.defaultLocale);
        this[Internal].url.pathname = info.pathname;
        this[Internal].defaultLocale = defaultLocale;
        this[Internal].basePath = info.basePath ?? "";
        this[Internal].buildId = info.buildId;
        this[Internal].locale = info.locale ?? defaultLocale;
        this[Internal].trailingSlash = info.trailingSlash;
      }
      formatPathname() {
        return (0, _formatnextpathnameinfo.formatNextPathnameInfo)({
          basePath: this[Internal].basePath,
          buildId: this[Internal].buildId,
          defaultLocale: !this[Internal].options.forceLocale ? this[Internal].defaultLocale : void 0,
          locale: this[Internal].locale,
          pathname: this[Internal].url.pathname,
          trailingSlash: this[Internal].trailingSlash
        });
      }
      formatSearch() {
        return this[Internal].url.search;
      }
      get buildId() {
        return this[Internal].buildId;
      }
      set buildId(buildId) {
        this[Internal].buildId = buildId;
      }
      get locale() {
        return this[Internal].locale ?? "";
      }
      set locale(locale) {
        var _this_Internal_options_nextConfig_i18n, _this_Internal_options_nextConfig;
        if (!this[Internal].locale || !((_this_Internal_options_nextConfig = this[Internal].options.nextConfig) == null ? void 0 : (_this_Internal_options_nextConfig_i18n = _this_Internal_options_nextConfig.i18n) == null ? void 0 : _this_Internal_options_nextConfig_i18n.locales.includes(locale))) {
          throw new TypeError(`The NextURL configuration includes no locale "${locale}"`);
        }
        this[Internal].locale = locale;
      }
      get defaultLocale() {
        return this[Internal].defaultLocale;
      }
      get domainLocale() {
        return this[Internal].domainLocale;
      }
      get searchParams() {
        return this[Internal].url.searchParams;
      }
      get host() {
        return this[Internal].url.host;
      }
      set host(value) {
        this[Internal].url.host = value;
      }
      get hostname() {
        return this[Internal].url.hostname;
      }
      set hostname(value) {
        this[Internal].url.hostname = value;
      }
      get port() {
        return this[Internal].url.port;
      }
      set port(value) {
        this[Internal].url.port = value;
      }
      get protocol() {
        return this[Internal].url.protocol;
      }
      set protocol(value) {
        this[Internal].url.protocol = value;
      }
      get href() {
        const pathname = this.formatPathname();
        const search = this.formatSearch();
        return `${this.protocol}//${this.host}${pathname}${search}${this.hash}`;
      }
      set href(url) {
        this[Internal].url = parseURL(url);
        this.analyze();
      }
      get origin() {
        return this[Internal].url.origin;
      }
      get pathname() {
        return this[Internal].url.pathname;
      }
      set pathname(value) {
        this[Internal].url.pathname = value;
      }
      get hash() {
        return this[Internal].url.hash;
      }
      set hash(value) {
        this[Internal].url.hash = value;
      }
      get search() {
        return this[Internal].url.search;
      }
      set search(value) {
        this[Internal].url.search = value;
      }
      get password() {
        return this[Internal].url.password;
      }
      set password(value) {
        this[Internal].url.password = value;
      }
      get username() {
        return this[Internal].url.username;
      }
      set username(value) {
        this[Internal].url.username = value;
      }
      get basePath() {
        return this[Internal].basePath;
      }
      set basePath(value) {
        this[Internal].basePath = value.startsWith("/") ? value : `/${value}`;
      }
      toString() {
        return this.href;
      }
      toJSON() {
        return this.href;
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return {
          href: this.href,
          origin: this.origin,
          protocol: this.protocol,
          username: this.username,
          password: this.password,
          host: this.host,
          hostname: this.hostname,
          port: this.port,
          pathname: this.pathname,
          search: this.search,
          searchParams: this.searchParams,
          hash: this.hash
        };
      }
      clone() {
        return new NextURL(String(this), this[Internal].options);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/error.js
var require_error = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      PageSignatureError: function() {
        return PageSignatureError;
      },
      RemovedPageError: function() {
        return RemovedPageError;
      },
      RemovedUAError: function() {
        return RemovedUAError;
      }
    });
    var PageSignatureError = class extends Error {
      constructor({ page }) {
        super(`The middleware "${page}" accepts an async API directly with the form:
  
  export function middleware(request, event) {
    return NextResponse.redirect('/new-location')
  }
  
  Read more: https://nextjs.org/docs/messages/middleware-new-signature
  `);
      }
    };
    var RemovedPageError = class extends Error {
      constructor() {
        super(`The request.page has been deprecated in favour of \`URLPattern\`.
  Read more: https://nextjs.org/docs/messages/middleware-request-page
  `);
      }
    };
    var RemovedUAError = class extends Error {
      constructor() {
        super(`The request.ua has been removed in favour of \`userAgent\` function.
  Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
  `);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js
var require_cookies = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/compiled/@edge-runtime/cookies/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export3 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export3(src_exports, {
      RequestCookies: () => RequestCookies,
      ResponseCookies: () => ResponseCookies,
      parseCookie: () => parseCookie,
      parseSetCookie: () => parseSetCookie,
      stringifyCookie: () => stringifyCookie
    });
    module.exports = __toCommonJS2(src_exports);
    function stringifyCookie(c) {
      var _a;
      const attrs = [
        "path" in c && c.path && `Path=${c.path}`,
        "expires" in c && (c.expires || c.expires === 0) && `Expires=${(typeof c.expires === "number" ? new Date(c.expires) : c.expires).toUTCString()}`,
        "maxAge" in c && typeof c.maxAge === "number" && `Max-Age=${c.maxAge}`,
        "domain" in c && c.domain && `Domain=${c.domain}`,
        "secure" in c && c.secure && "Secure",
        "httpOnly" in c && c.httpOnly && "HttpOnly",
        "sameSite" in c && c.sameSite && `SameSite=${c.sameSite}`,
        "partitioned" in c && c.partitioned && "Partitioned",
        "priority" in c && c.priority && `Priority=${c.priority}`
      ].filter(Boolean);
      const stringified = `${c.name}=${encodeURIComponent((_a = c.value) != null ? _a : "")}`;
      return attrs.length === 0 ? stringified : `${stringified}; ${attrs.join("; ")}`;
    }
    function parseCookie(cookie) {
      const map = /* @__PURE__ */ new Map();
      for (const pair of cookie.split(/; */)) {
        if (!pair)
          continue;
        const splitAt = pair.indexOf("=");
        if (splitAt === -1) {
          map.set(pair, "true");
          continue;
        }
        const [key, value] = [pair.slice(0, splitAt), pair.slice(splitAt + 1)];
        try {
          map.set(key, decodeURIComponent(value != null ? value : "true"));
        } catch {
        }
      }
      return map;
    }
    function parseSetCookie(setCookie) {
      if (!setCookie) {
        return void 0;
      }
      const [[name, value], ...attributes] = parseCookie(setCookie);
      const {
        domain,
        expires,
        httponly,
        maxage,
        path,
        samesite,
        secure,
        partitioned,
        priority
      } = Object.fromEntries(
        attributes.map(([key, value2]) => [key.toLowerCase(), value2])
      );
      const cookie = {
        name,
        value: decodeURIComponent(value),
        domain,
        ...expires && { expires: new Date(expires) },
        ...httponly && { httpOnly: true },
        ...typeof maxage === "string" && { maxAge: Number(maxage) },
        path,
        ...samesite && { sameSite: parseSameSite(samesite) },
        ...secure && { secure: true },
        ...priority && { priority: parsePriority(priority) },
        ...partitioned && { partitioned: true }
      };
      return compact(cookie);
    }
    function compact(t) {
      const newT = {};
      for (const key in t) {
        if (t[key]) {
          newT[key] = t[key];
        }
      }
      return newT;
    }
    var SAME_SITE = ["strict", "lax", "none"];
    function parseSameSite(string) {
      string = string.toLowerCase();
      return SAME_SITE.includes(string) ? string : void 0;
    }
    var PRIORITY = ["low", "medium", "high"];
    function parsePriority(string) {
      string = string.toLowerCase();
      return PRIORITY.includes(string) ? string : void 0;
    }
    function splitCookiesString(cookiesString) {
      if (!cookiesString)
        return [];
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    var RequestCookies = class {
      constructor(requestHeaders) {
        this._parsed = /* @__PURE__ */ new Map();
        this._headers = requestHeaders;
        const header = requestHeaders.get("cookie");
        if (header) {
          const parsed = parseCookie(header);
          for (const [name, value] of parsed) {
            this._parsed.set(name, { name, value });
          }
        }
      }
      [Symbol.iterator]() {
        return this._parsed[Symbol.iterator]();
      }
      /**
       * The amount of cookies received from the client
       */
      get size() {
        return this._parsed.size;
      }
      get(...args) {
        const name = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(name);
      }
      getAll(...args) {
        var _a;
        const all = Array.from(this._parsed);
        if (!args.length) {
          return all.map(([_, value]) => value);
        }
        const name = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter(([n]) => n === name).map(([_, value]) => value);
      }
      has(name) {
        return this._parsed.has(name);
      }
      set(...args) {
        const [name, value] = args.length === 1 ? [args[0].name, args[0].value] : args;
        const map = this._parsed;
        map.set(name, { name, value });
        this._headers.set(
          "cookie",
          Array.from(map).map(([_, value2]) => stringifyCookie(value2)).join("; ")
        );
        return this;
      }
      /**
       * Delete the cookies matching the passed name or names in the request.
       */
      delete(names) {
        const map = this._parsed;
        const result = !Array.isArray(names) ? map.delete(names) : names.map((name) => map.delete(name));
        this._headers.set(
          "cookie",
          Array.from(map).map(([_, value]) => stringifyCookie(value)).join("; ")
        );
        return result;
      }
      /**
       * Delete all the cookies in the cookies in the request.
       */
      clear() {
        this.delete(Array.from(this._parsed.keys()));
        return this;
      }
      /**
       * Format the cookies in the request as a string for logging
       */
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return `RequestCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
      }
      toString() {
        return [...this._parsed.values()].map((v) => `${v.name}=${encodeURIComponent(v.value)}`).join("; ");
      }
    };
    var ResponseCookies = class {
      constructor(responseHeaders) {
        this._parsed = /* @__PURE__ */ new Map();
        var _a, _b, _c;
        this._headers = responseHeaders;
        const setCookie = (_c = (_b = (_a = responseHeaders.getSetCookie) == null ? void 0 : _a.call(responseHeaders)) != null ? _b : responseHeaders.get("set-cookie")) != null ? _c : [];
        const cookieStrings = Array.isArray(setCookie) ? setCookie : splitCookiesString(setCookie);
        for (const cookieString of cookieStrings) {
          const parsed = parseSetCookie(cookieString);
          if (parsed)
            this._parsed.set(parsed.name, parsed);
        }
      }
      /**
       * {@link https://wicg.github.io/cookie-store/#CookieStore-get CookieStore#get} without the Promise.
       */
      get(...args) {
        const key = typeof args[0] === "string" ? args[0] : args[0].name;
        return this._parsed.get(key);
      }
      /**
       * {@link https://wicg.github.io/cookie-store/#CookieStore-getAll CookieStore#getAll} without the Promise.
       */
      getAll(...args) {
        var _a;
        const all = Array.from(this._parsed.values());
        if (!args.length) {
          return all;
        }
        const key = typeof args[0] === "string" ? args[0] : (_a = args[0]) == null ? void 0 : _a.name;
        return all.filter((c) => c.name === key);
      }
      has(name) {
        return this._parsed.has(name);
      }
      /**
       * {@link https://wicg.github.io/cookie-store/#CookieStore-set CookieStore#set} without the Promise.
       */
      set(...args) {
        const [name, value, cookie] = args.length === 1 ? [args[0].name, args[0].value, args[0]] : args;
        const map = this._parsed;
        map.set(name, normalizeCookie({ name, value, ...cookie }));
        replace(map, this._headers);
        return this;
      }
      /**
       * {@link https://wicg.github.io/cookie-store/#CookieStore-delete CookieStore#delete} without the Promise.
       */
      delete(...args) {
        const [name, path, domain] = typeof args[0] === "string" ? [args[0]] : [args[0].name, args[0].path, args[0].domain];
        return this.set({ name, path, domain, value: "", expires: /* @__PURE__ */ new Date(0) });
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return `ResponseCookies ${JSON.stringify(Object.fromEntries(this._parsed))}`;
      }
      toString() {
        return [...this._parsed.values()].map(stringifyCookie).join("; ");
      }
    };
    function replace(bag, headers) {
      headers.delete("set-cookie");
      for (const [, value] of bag) {
        const serialized = stringifyCookie(value);
        headers.append("set-cookie", serialized);
      }
    }
    function normalizeCookie(cookie = { name: "", value: "" }) {
      if (typeof cookie.expires === "number") {
        cookie.expires = new Date(cookie.expires);
      }
      if (cookie.maxAge) {
        cookie.expires = new Date(Date.now() + cookie.maxAge * 1e3);
      }
      if (cookie.path === null || cookie.path === void 0) {
        cookie.path = "/";
      }
      return cookie;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/cookies.js
var require_cookies2 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/cookies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      RequestCookies: function() {
        return _cookies.RequestCookies;
      },
      ResponseCookies: function() {
        return _cookies.ResponseCookies;
      },
      stringifyCookie: function() {
        return _cookies.stringifyCookie;
      }
    });
    var _cookies = require_cookies();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/request.js
var require_request = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      INTERNALS: function() {
        return INTERNALS;
      },
      NextRequest: function() {
        return NextRequest;
      }
    });
    var _nexturl = require_next_url();
    var _utils = require_utils();
    var _error = require_error();
    var _cookies = require_cookies2();
    var INTERNALS = Symbol("internal request");
    var NextRequest = class extends Request {
      constructor(input, init = {}) {
        const url = typeof input !== "string" && "url" in input ? input.url : String(input);
        (0, _utils.validateURL)(url);
        if (input instanceof Request)
          super(input, init);
        else
          super(url, init);
        const nextUrl = new _nexturl.NextURL(url, {
          headers: (0, _utils.toNodeOutgoingHttpHeaders)(this.headers),
          nextConfig: init.nextConfig
        });
        this[INTERNALS] = {
          cookies: new _cookies.RequestCookies(this.headers),
          nextUrl,
          url: process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE ? url : nextUrl.toString()
        };
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return {
          cookies: this.cookies,
          nextUrl: this.nextUrl,
          url: this.url,
          // rest of props come from Request
          bodyUsed: this.bodyUsed,
          cache: this.cache,
          credentials: this.credentials,
          destination: this.destination,
          headers: Object.fromEntries(this.headers),
          integrity: this.integrity,
          keepalive: this.keepalive,
          method: this.method,
          mode: this.mode,
          redirect: this.redirect,
          referrer: this.referrer,
          referrerPolicy: this.referrerPolicy,
          signal: this.signal
        };
      }
      get cookies() {
        return this[INTERNALS].cookies;
      }
      get nextUrl() {
        return this[INTERNALS].nextUrl;
      }
      /**
      * @deprecated
      * `page` has been deprecated in favour of `URLPattern`.
      * Read more: https://nextjs.org/docs/messages/middleware-request-page
      */
      get page() {
        throw new _error.RemovedPageError();
      }
      /**
      * @deprecated
      * `ua` has been removed in favour of \`userAgent\` function.
      * Read more: https://nextjs.org/docs/messages/middleware-parse-user-agent
      */
      get ua() {
        throw new _error.RemovedUAError();
      }
      get url() {
        return this[INTERNALS].url;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/base-http/helpers.js
var require_helpers = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/base-http/helpers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      isNodeNextRequest: function() {
        return isNodeNextRequest;
      },
      isNodeNextResponse: function() {
        return isNodeNextResponse;
      },
      isWebNextRequest: function() {
        return isWebNextRequest;
      },
      isWebNextResponse: function() {
        return isWebNextResponse;
      }
    });
    var isWebNextRequest = (req) => false;
    var isWebNextResponse = (res) => false;
    var isNodeNextRequest = (req) => true;
    var isNodeNextResponse = (res) => true;
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/adapters/next-request.js
var require_next_request = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/adapters/next-request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      NextRequestAdapter: function() {
        return NextRequestAdapter;
      },
      ResponseAborted: function() {
        return ResponseAborted;
      },
      ResponseAbortedName: function() {
        return ResponseAbortedName;
      },
      createAbortController: function() {
        return createAbortController;
      },
      signalFromNodeResponse: function() {
        return signalFromNodeResponse;
      }
    });
    var _requestmeta = require_request_meta();
    var _utils = require_utils();
    var _request = require_request();
    var _helpers = require_helpers();
    var ResponseAbortedName = "ResponseAborted";
    var ResponseAborted = class extends Error {
      constructor(...args) {
        super(...args);
        this.name = ResponseAbortedName;
      }
    };
    function createAbortController(response) {
      const controller = new AbortController();
      response.once("close", () => {
        if (response.writableFinished)
          return;
        controller.abort(new ResponseAborted());
      });
      return controller;
    }
    function signalFromNodeResponse(response) {
      const { errored, destroyed } = response;
      if (errored || destroyed) {
        return AbortSignal.abort(errored ?? new ResponseAborted());
      }
      const { signal } = createAbortController(response);
      return signal;
    }
    var NextRequestAdapter = class {
      static fromBaseNextRequest(request, signal) {
        if (
          // The type check here ensures that `req` is correctly typed, and the
          // environment variable check provides dead code elimination.
          false
        ) {
          return NextRequestAdapter.fromWebNextRequest(request);
        } else if ((0, _helpers.isNodeNextRequest)(request)) {
          return NextRequestAdapter.fromNodeNextRequest(request, signal);
        } else {
          throw new Error("Invariant: Unsupported NextRequest type");
        }
      }
      static fromNodeNextRequest(request, signal) {
        let body = null;
        if (request.method !== "GET" && request.method !== "HEAD" && request.body) {
          body = request.body;
        }
        let url;
        if (request.url.startsWith("http")) {
          url = new URL(request.url);
        } else {
          const base = (0, _requestmeta.getRequestMeta)(request, "initURL");
          if (!base || !base.startsWith("http")) {
            url = new URL(request.url, "http://n");
          } else {
            url = new URL(request.url, base);
          }
        }
        return new _request.NextRequest(url, {
          method: request.method,
          headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),
          // @ts-expect-error - see https://github.com/whatwg/fetch/pull/1457
          duplex: "half",
          signal,
          // geo
          // ip
          // nextConfig
          // body can not be passed if request was aborted
          // or we get a Request body was disturbed error
          ...signal.aborted ? {} : {
            body
          }
        });
      }
      static fromWebNextRequest(request) {
        let body = null;
        if (request.method !== "GET" && request.method !== "HEAD") {
          body = request.body;
        }
        return new _request.NextRequest(request.url, {
          method: request.method,
          headers: (0, _utils.fromNodeOutgoingHttpHeaders)(request.headers),
          // @ts-expect-error - see https://github.com/whatwg/fetch/pull/1457
          duplex: "half",
          signal: request.request.signal,
          // geo
          // ip
          // nextConfig
          // body can not be passed if request was aborted
          // or we get a Request body was disturbed error
          ...request.request.signal.aborted ? {} : {
            body
          }
        });
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/client-component-renderer-logger.js
var require_client_component_renderer_logger = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/client-component-renderer-logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getClientComponentLoaderMetrics: function() {
        return getClientComponentLoaderMetrics;
      },
      wrapClientComponentLoader: function() {
        return wrapClientComponentLoader;
      }
    });
    var clientComponentLoadStart = 0;
    var clientComponentLoadTimes = 0;
    var clientComponentLoadCount = 0;
    function wrapClientComponentLoader(ComponentMod) {
      if (!("performance" in globalThis)) {
        return ComponentMod.__next_app__;
      }
      return {
        require: (...args) => {
          const startTime = performance.now();
          if (clientComponentLoadStart === 0) {
            clientComponentLoadStart = startTime;
          }
          try {
            clientComponentLoadCount += 1;
            return ComponentMod.__next_app__.require(...args);
          } finally {
            clientComponentLoadTimes += performance.now() - startTime;
          }
        },
        loadChunk: (...args) => {
          const startTime = performance.now();
          try {
            clientComponentLoadCount += 1;
            return ComponentMod.__next_app__.loadChunk(...args);
          } finally {
            clientComponentLoadTimes += performance.now() - startTime;
          }
        }
      };
    }
    function getClientComponentLoaderMetrics(options = {}) {
      const metrics = clientComponentLoadStart === 0 ? void 0 : {
        clientComponentLoadStart,
        clientComponentLoadTimes,
        clientComponentLoadCount
      };
      if (options.reset) {
        clientComponentLoadStart = 0;
        clientComponentLoadTimes = 0;
        clientComponentLoadCount = 0;
      }
      return metrics;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/pipe-readable.js
var require_pipe_readable = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/pipe-readable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      isAbortError: function() {
        return isAbortError;
      },
      pipeToNodeResponse: function() {
        return pipeToNodeResponse;
      }
    });
    var _nextrequest = require_next_request();
    var _detachedpromise = require_detached_promise();
    var _tracer = require_tracer();
    var _constants = require_constants2();
    var _clientcomponentrendererlogger = require_client_component_renderer_logger();
    function isAbortError(e) {
      return (e == null ? void 0 : e.name) === "AbortError" || (e == null ? void 0 : e.name) === _nextrequest.ResponseAbortedName;
    }
    function createWriterFromResponse(res, waitUntilForEnd) {
      let started = false;
      let drained = new _detachedpromise.DetachedPromise();
      function onDrain() {
        drained.resolve();
      }
      res.on("drain", onDrain);
      res.once("close", () => {
        res.off("drain", onDrain);
        drained.resolve();
      });
      const finished = new _detachedpromise.DetachedPromise();
      res.once("finish", () => {
        finished.resolve();
      });
      return new WritableStream({
        write: async (chunk) => {
          if (!started) {
            started = true;
            if ("performance" in globalThis && process.env.NEXT_OTEL_PERFORMANCE_PREFIX) {
              const metrics = (0, _clientcomponentrendererlogger.getClientComponentLoaderMetrics)();
              if (metrics) {
                performance.measure(`${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`, {
                  start: metrics.clientComponentLoadStart,
                  end: metrics.clientComponentLoadStart + metrics.clientComponentLoadTimes
                });
              }
            }
            res.flushHeaders();
            (0, _tracer.getTracer)().trace(_constants.NextNodeServerSpan.startResponse, {
              spanName: "start response"
            }, () => void 0);
          }
          try {
            const ok = res.write(chunk);
            if ("flush" in res && typeof res.flush === "function") {
              res.flush();
            }
            if (!ok) {
              await drained.promise;
              drained = new _detachedpromise.DetachedPromise();
            }
          } catch (err) {
            res.end();
            throw new Error("failed to write chunk to response", {
              cause: err
            });
          }
        },
        abort: (err) => {
          if (res.writableFinished)
            return;
          res.destroy(err);
        },
        close: async () => {
          if (waitUntilForEnd) {
            await waitUntilForEnd;
          }
          if (res.writableFinished)
            return;
          res.end();
          return finished.promise;
        }
      });
    }
    async function pipeToNodeResponse(readable, res, waitUntilForEnd) {
      try {
        const { errored, destroyed } = res;
        if (errored || destroyed)
          return;
        const controller = (0, _nextrequest.createAbortController)(res);
        const writer = createWriterFromResponse(res, waitUntilForEnd);
        await readable.pipeTo(writer, {
          signal: controller.signal
        });
      } catch (err) {
        if (isAbortError(err))
          return;
        throw new Error("failed to pipe response", {
          cause: err
        });
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/render-result.js
var require_render_result = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/render-result.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return RenderResult;
      }
    });
    var _nodewebstreamshelper = require_node_web_streams_helper();
    var _pipereadable = require_pipe_readable();
    var RenderResult = class {
      /**
      * Creates a new RenderResult instance from a static response.
      *
      * @param value the static response value
      * @returns a new RenderResult instance
      */
      static fromStatic(value) {
        return new RenderResult(value, {
          metadata: {}
        });
      }
      constructor(response, { contentType, waitUntil, metadata }) {
        this.response = response;
        this.contentType = contentType;
        this.metadata = metadata;
        this.waitUntil = waitUntil;
      }
      assignMetadata(metadata) {
        Object.assign(this.metadata, metadata);
      }
      /**
      * Returns true if the response is null. It can be null if the response was
      * not found or was already sent.
      */
      get isNull() {
        return this.response === null;
      }
      /**
      * Returns false if the response is a string. It can be a string if the page
      * was prerendered. If it's not, then it was generated dynamically.
      */
      get isDynamic() {
        return typeof this.response !== "string";
      }
      toUnchunkedBuffer(stream = false) {
        if (this.response === null) {
          throw new Error("Invariant: null responses cannot be unchunked");
        }
        if (typeof this.response !== "string") {
          if (!stream) {
            throw new Error("Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js");
          }
          return (0, _nodewebstreamshelper.streamToBuffer)(this.readable);
        }
        return Buffer.from(this.response);
      }
      toUnchunkedString(stream = false) {
        if (this.response === null) {
          throw new Error("Invariant: null responses cannot be unchunked");
        }
        if (typeof this.response !== "string") {
          if (!stream) {
            throw new Error("Invariant: dynamic responses cannot be unchunked. This is a bug in Next.js");
          }
          return (0, _nodewebstreamshelper.streamToString)(this.readable);
        }
        return this.response;
      }
      /**
      * Returns the response if it is a stream, or throws an error if it is a
      * string.
      */
      get readable() {
        if (this.response === null) {
          throw new Error("Invariant: null responses cannot be streamed");
        }
        if (typeof this.response === "string") {
          throw new Error("Invariant: static responses cannot be streamed");
        }
        if (Buffer.isBuffer(this.response)) {
          return (0, _nodewebstreamshelper.streamFromBuffer)(this.response);
        }
        if (Array.isArray(this.response)) {
          return (0, _nodewebstreamshelper.chainStreams)(...this.response);
        }
        return this.response;
      }
      /**
      * Chains a new stream to the response. This will convert the response to an
      * array of streams if it is not already one and will add the new stream to
      * the end. When this response is piped, all of the streams will be piped
      * one after the other.
      *
      * @param readable The new stream to chain
      */
      chain(readable) {
        if (this.response === null) {
          throw new Error("Invariant: response is null. This is a bug in Next.js");
        }
        let responses;
        if (typeof this.response === "string") {
          responses = [
            (0, _nodewebstreamshelper.streamFromString)(this.response)
          ];
        } else if (Array.isArray(this.response)) {
          responses = this.response;
        } else if (Buffer.isBuffer(this.response)) {
          responses = [
            (0, _nodewebstreamshelper.streamFromBuffer)(this.response)
          ];
        } else {
          responses = [
            this.response
          ];
        }
        responses.push(readable);
        this.response = responses;
      }
      /**
      * Pipes the response to a writable stream. This will close/cancel the
      * writable stream if an error is encountered. If this doesn't throw, then
      * the writable stream will be closed or aborted.
      *
      * @param writable Writable stream to pipe the response to
      */
      async pipeTo(writable) {
        try {
          await this.readable.pipeTo(writable, {
            // We want to close the writable stream ourselves so that we can wait
            // for the waitUntil promise to resolve before closing it. If an error
            // is encountered, we'll abort the writable stream if we swallowed the
            // error.
            preventClose: true
          });
          if (this.waitUntil)
            await this.waitUntil;
          await writable.close();
        } catch (err) {
          if ((0, _pipereadable.isAbortError)(err)) {
            await writable.abort(err);
            return;
          }
          throw err;
        }
      }
      /**
      * Pipes the response to a node response. This will close/cancel the node
      * response if an error is encountered.
      *
      * @param res
      */
      async pipeToNodeResponse(res) {
        await (0, _pipereadable.pipeToNodeResponse)(this.readable, res, this.waitUntil);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-kind.js
var require_route_kind = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-kind.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "RouteKind", {
      enumerable: true,
      get: function() {
        return RouteKind;
      }
    });
    var RouteKind;
    (function(RouteKind2) {
      RouteKind2["PAGES"] = "PAGES";
      RouteKind2["PAGES_API"] = "PAGES_API";
      RouteKind2["APP_PAGE"] = "APP_PAGE";
      RouteKind2["APP_ROUTE"] = "APP_ROUTE";
      RouteKind2["IMAGE"] = "IMAGE";
    })(RouteKind || (RouteKind = {}));
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/response-cache/utils.js
var require_utils4 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/response-cache/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      fromResponseCacheEntry: function() {
        return fromResponseCacheEntry;
      },
      routeKindToIncrementalCacheKind: function() {
        return routeKindToIncrementalCacheKind;
      },
      toResponseCacheEntry: function() {
        return toResponseCacheEntry;
      }
    });
    var _types = require_types();
    var _renderresult = /* @__PURE__ */ _interop_require_default(require_render_result());
    var _routekind = require_route_kind();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    async function fromResponseCacheEntry(cacheEntry) {
      var _cacheEntry_value, _cacheEntry_value1;
      return {
        ...cacheEntry,
        value: ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === _types.CachedRouteKind.PAGES ? {
          kind: _types.CachedRouteKind.PAGES,
          html: await cacheEntry.value.html.toUnchunkedString(true),
          pageData: cacheEntry.value.pageData,
          headers: cacheEntry.value.headers,
          status: cacheEntry.value.status
        } : ((_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind) === _types.CachedRouteKind.APP_PAGE ? {
          kind: _types.CachedRouteKind.APP_PAGE,
          html: await cacheEntry.value.html.toUnchunkedString(true),
          postponed: cacheEntry.value.postponed,
          rscData: cacheEntry.value.rscData,
          headers: cacheEntry.value.headers,
          status: cacheEntry.value.status,
          segmentData: cacheEntry.value.segmentData
        } : cacheEntry.value
      };
    }
    async function toResponseCacheEntry(response) {
      var _response_value, _response_value1, _response_value2;
      if (!response)
        return null;
      if (((_response_value = response.value) == null ? void 0 : _response_value.kind) === _types.CachedRouteKind.FETCH) {
        throw new Error("Invariant: unexpected cachedResponse of kind fetch in response cache");
      }
      return {
        isMiss: response.isMiss,
        isStale: response.isStale,
        revalidate: response.revalidate,
        isFallback: response.isFallback,
        value: ((_response_value1 = response.value) == null ? void 0 : _response_value1.kind) === _types.CachedRouteKind.PAGES ? {
          kind: _types.CachedRouteKind.PAGES,
          html: _renderresult.default.fromStatic(response.value.html),
          pageData: response.value.pageData,
          headers: response.value.headers,
          status: response.value.status
        } : ((_response_value2 = response.value) == null ? void 0 : _response_value2.kind) === _types.CachedRouteKind.APP_PAGE ? {
          kind: _types.CachedRouteKind.APP_PAGE,
          html: _renderresult.default.fromStatic(response.value.html),
          rscData: response.value.rscData,
          headers: response.value.headers,
          status: response.value.status,
          postponed: response.value.postponed,
          segmentData: response.value.segmentData
        } : response.value
      };
    }
    function routeKindToIncrementalCacheKind(routeKind) {
      switch (routeKind) {
        case _routekind.RouteKind.PAGES:
          return _types.IncrementalCacheKind.PAGES;
        case _routekind.RouteKind.APP_PAGE:
          return _types.IncrementalCacheKind.APP_PAGE;
        case _routekind.RouteKind.IMAGE:
          return _types.IncrementalCacheKind.IMAGE;
        case _routekind.RouteKind.APP_ROUTE:
          return _types.IncrementalCacheKind.APP_ROUTE;
        default:
          throw new Error(`Unexpected route kind ${routeKind}`);
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/response-cache/index.js
var require_response_cache = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/response-cache/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return ResponseCache;
      }
    });
    var _types = _export_star(require_types(), exports);
    var _batcher = require_batcher();
    var _scheduler = require_scheduler();
    var _utils = require_utils4();
    function _export_star(from, to) {
      Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
          Object.defineProperty(to, k, {
            enumerable: true,
            get: function() {
              return from[k];
            }
          });
        }
      });
      return from;
    }
    var ResponseCache = class {
      constructor(minimalMode) {
        this.batcher = _batcher.Batcher.create({
          // Ensure on-demand revalidate doesn't block normal requests, it should be
          // safe to run an on-demand revalidate for the same key as a normal request.
          cacheKeyFn: ({ key, isOnDemandRevalidate }) => `${key}-${isOnDemandRevalidate ? "1" : "0"}`,
          // We wait to do any async work until after we've added our promise to
          // `pendingResponses` to ensure that any any other calls will reuse the
          // same promise until we've fully finished our work.
          schedulerFn: _scheduler.scheduleOnNextTick
        });
        const minimalModeKey = "minimalMode";
        this[minimalModeKey] = minimalMode;
      }
      async get(key, responseGenerator, context) {
        if (!key) {
          return responseGenerator({
            hasResolved: false,
            previousCacheEntry: null
          });
        }
        const { incrementalCache, isOnDemandRevalidate = false, isFallback = false, isRoutePPREnabled = false } = context;
        const response = await this.batcher.batch({
          key,
          isOnDemandRevalidate
        }, async (cacheKey, resolve) => {
          var _this_previousCacheItem;
          if (this.minimalMode && ((_this_previousCacheItem = this.previousCacheItem) == null ? void 0 : _this_previousCacheItem.key) === cacheKey && this.previousCacheItem.expiresAt > Date.now()) {
            return this.previousCacheItem.entry;
          }
          const kind = (0, _utils.routeKindToIncrementalCacheKind)(context.routeKind);
          let resolved = false;
          let cachedResponse = null;
          try {
            cachedResponse = !this.minimalMode ? await incrementalCache.get(key, {
              kind,
              isRoutePPREnabled: context.isRoutePPREnabled,
              isFallback
            }) : null;
            if (cachedResponse && !isOnDemandRevalidate) {
              var _cachedResponse_value;
              if (((_cachedResponse_value = cachedResponse.value) == null ? void 0 : _cachedResponse_value.kind) === _types.CachedRouteKind.FETCH) {
                throw new Error(`invariant: unexpected cachedResponse of kind fetch in response cache`);
              }
              resolve({
                ...cachedResponse,
                revalidate: cachedResponse.curRevalidate
              });
              resolved = true;
              if (!cachedResponse.isStale || context.isPrefetch) {
                return null;
              }
            }
            const cacheEntry = await responseGenerator({
              hasResolved: resolved,
              previousCacheEntry: cachedResponse,
              isRevalidating: true
            });
            if (!cacheEntry) {
              if (this.minimalMode)
                this.previousCacheItem = void 0;
              return null;
            }
            const resolveValue = await (0, _utils.fromResponseCacheEntry)({
              ...cacheEntry,
              isMiss: !cachedResponse
            });
            if (!resolveValue) {
              if (this.minimalMode)
                this.previousCacheItem = void 0;
              return null;
            }
            if (!isOnDemandRevalidate && !resolved) {
              resolve(resolveValue);
              resolved = true;
            }
            if (typeof resolveValue.revalidate !== "undefined") {
              if (this.minimalMode) {
                this.previousCacheItem = {
                  key: cacheKey,
                  entry: resolveValue,
                  expiresAt: Date.now() + 1e3
                };
              } else {
                await incrementalCache.set(key, resolveValue.value, {
                  revalidate: resolveValue.revalidate,
                  isRoutePPREnabled,
                  isFallback
                });
              }
            }
            return resolveValue;
          } catch (err) {
            if (cachedResponse) {
              await incrementalCache.set(key, cachedResponse.value, {
                revalidate: Math.min(Math.max(cachedResponse.revalidate || 3, 3), 30),
                isRoutePPREnabled,
                isFallback
              });
            }
            if (resolved) {
              console.error(err);
              return null;
            }
            throw err;
          }
        });
        return (0, _utils.toResponseCacheEntry)(response);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/is-ipv6.js
var require_is_ipv6 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/is-ipv6.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isIPv6", {
      enumerable: true,
      get: function() {
        return isIPv6;
      }
    });
    var v4Seg = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
    var v4Str = `(${v4Seg}[.]){3}${v4Seg}`;
    var v6Seg = "(?:[0-9a-fA-F]{1,4})";
    var IPv6Reg = new RegExp(`^((?:${v6Seg}:){7}(?:${v6Seg}|:)|(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1,2}|:)|(?:${v6Seg}:){4}(?:(:${v6Seg}){0,1}:${v4Str}|(:${v6Seg}){1,3}|:)|(?:${v6Seg}:){3}(?:(:${v6Seg}){0,2}:${v4Str}|(:${v6Seg}){1,4}|:)|(?:${v6Seg}:){2}(?:(:${v6Seg}){0,3}:${v4Str}|(:${v6Seg}){1,5}|:)|(?:${v6Seg}:){1}(?:(:${v6Seg}){0,4}:${v4Str}|(:${v6Seg}){1,6}|:)|(?::((?::${v6Seg}){0,5}:${v4Str}|(?::${v6Seg}){1,7}|:)))(%[0-9a-zA-Z-.:]{1,})?$`);
    function isIPv6(s) {
      return IPv6Reg.test(s);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/format-hostname.js
var require_format_hostname = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/format-hostname.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "formatHostname", {
      enumerable: true,
      get: function() {
        return formatHostname;
      }
    });
    var _isipv6 = require_is_ipv6();
    function formatHostname(hostname) {
      return (0, _isipv6.isIPv6)(hostname) ? `[${hostname}]` : hostname;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/redirect-status.js
var require_redirect_status = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/redirect-status.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      allowedStatusCodes: function() {
        return allowedStatusCodes;
      },
      getRedirectStatus: function() {
        return getRedirectStatus;
      },
      modifyRouteRegex: function() {
        return modifyRouteRegex;
      }
    });
    var _redirectstatuscode = require_redirect_status_code();
    var allowedStatusCodes = /* @__PURE__ */ new Set([
      301,
      302,
      303,
      307,
      308
    ]);
    function getRedirectStatus(route) {
      return route.statusCode || (route.permanent ? _redirectstatuscode.RedirectStatusCode.PermanentRedirect : _redirectstatuscode.RedirectStatusCode.TemporaryRedirect);
    }
    function modifyRouteRegex(regex, restrictedPaths) {
      if (restrictedPaths) {
        regex = regex.replace(/\^/, `^(?!${restrictedPaths.map((path) => path.replace(/\//g, "\\/")).join("|")})`);
      }
      regex = regex.replace(/\$$/, "(?:\\/)?$");
      return regex;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/is-edge-runtime.js
var require_is_edge_runtime = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/is-edge-runtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isEdgeRuntime", {
      enumerable: true,
      get: function() {
        return isEdgeRuntime;
      }
    });
    var _constants = require_constants();
    function isEdgeRuntime(value) {
      return value === _constants.SERVER_RUNTIME.experimentalEdge || value === _constants.SERVER_RUNTIME.edge;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js
var require_sorted_routes = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getSortedRouteObjects: function() {
        return getSortedRouteObjects;
      },
      getSortedRoutes: function() {
        return getSortedRoutes;
      }
    });
    var UrlNode = class {
      insert(urlPath) {
        this._insert(urlPath.split("/").filter(Boolean), [], false);
      }
      smoosh() {
        return this._smoosh();
      }
      _smoosh(prefix) {
        if (prefix === void 0)
          prefix = "/";
        const childrenPaths = [
          ...this.children.keys()
        ].sort();
        if (this.slugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[]"), 1);
        }
        if (this.restSlugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[...]"), 1);
        }
        if (this.optionalRestSlugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[[...]]"), 1);
        }
        const routes = childrenPaths.map((c) => this.children.get(c)._smoosh("" + prefix + c + "/")).reduce((prev, curr) => [
          ...prev,
          ...curr
        ], []);
        if (this.slugName !== null) {
          routes.push(...this.children.get("[]")._smoosh(prefix + "[" + this.slugName + "]/"));
        }
        if (!this.placeholder) {
          const r = prefix === "/" ? "/" : prefix.slice(0, -1);
          if (this.optionalRestSlugName != null) {
            throw new Error('You cannot define a route with the same specificity as a optional catch-all route ("' + r + '" and "' + r + "[[..." + this.optionalRestSlugName + ']]").');
          }
          routes.unshift(r);
        }
        if (this.restSlugName !== null) {
          routes.push(...this.children.get("[...]")._smoosh(prefix + "[..." + this.restSlugName + "]/"));
        }
        if (this.optionalRestSlugName !== null) {
          routes.push(...this.children.get("[[...]]")._smoosh(prefix + "[[..." + this.optionalRestSlugName + "]]/"));
        }
        return routes;
      }
      _insert(urlPaths, slugNames, isCatchAll) {
        if (urlPaths.length === 0) {
          this.placeholder = false;
          return;
        }
        if (isCatchAll) {
          throw new Error("Catch-all must be the last part of the URL.");
        }
        let nextSegment = urlPaths[0];
        if (nextSegment.startsWith("[") && nextSegment.endsWith("]")) {
          let handleSlug = function(previousSlug, nextSlug) {
            if (previousSlug !== null) {
              if (previousSlug !== nextSlug) {
                throw new Error("You cannot use different slug names for the same dynamic path ('" + previousSlug + "' !== '" + nextSlug + "').");
              }
            }
            slugNames.forEach((slug) => {
              if (slug === nextSlug) {
                throw new Error('You cannot have the same slug name "' + nextSlug + '" repeat within a single dynamic path');
              }
              if (slug.replace(/\W/g, "") === nextSegment.replace(/\W/g, "")) {
                throw new Error('You cannot have the slug names "' + slug + '" and "' + nextSlug + '" differ only by non-word symbols within a single dynamic path');
              }
            });
            slugNames.push(nextSlug);
          };
          let segmentName = nextSegment.slice(1, -1);
          let isOptional = false;
          if (segmentName.startsWith("[") && segmentName.endsWith("]")) {
            segmentName = segmentName.slice(1, -1);
            isOptional = true;
          }
          if (segmentName.startsWith("\u2026")) {
            throw new Error("Detected a three-dot character ('\u2026') at ('" + segmentName + "'). Did you mean ('...')?");
          }
          if (segmentName.startsWith("...")) {
            segmentName = segmentName.substring(3);
            isCatchAll = true;
          }
          if (segmentName.startsWith("[") || segmentName.endsWith("]")) {
            throw new Error("Segment names may not start or end with extra brackets ('" + segmentName + "').");
          }
          if (segmentName.startsWith(".")) {
            throw new Error("Segment names may not start with erroneous periods ('" + segmentName + "').");
          }
          if (isCatchAll) {
            if (isOptional) {
              if (this.restSlugName != null) {
                throw new Error('You cannot use both an required and optional catch-all route at the same level ("[...' + this.restSlugName + ']" and "' + urlPaths[0] + '" ).');
              }
              handleSlug(this.optionalRestSlugName, segmentName);
              this.optionalRestSlugName = segmentName;
              nextSegment = "[[...]]";
            } else {
              if (this.optionalRestSlugName != null) {
                throw new Error('You cannot use both an optional and required catch-all route at the same level ("[[...' + this.optionalRestSlugName + ']]" and "' + urlPaths[0] + '").');
              }
              handleSlug(this.restSlugName, segmentName);
              this.restSlugName = segmentName;
              nextSegment = "[...]";
            }
          } else {
            if (isOptional) {
              throw new Error('Optional route parameters are not yet supported ("' + urlPaths[0] + '").');
            }
            handleSlug(this.slugName, segmentName);
            this.slugName = segmentName;
            nextSegment = "[]";
          }
        }
        if (!this.children.has(nextSegment)) {
          this.children.set(nextSegment, new UrlNode());
        }
        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
      }
      constructor() {
        this.placeholder = true;
        this.children = /* @__PURE__ */ new Map();
        this.slugName = null;
        this.restSlugName = null;
        this.optionalRestSlugName = null;
      }
    };
    function getSortedRoutes(normalizedPages) {
      const root = new UrlNode();
      normalizedPages.forEach((pagePath) => root.insert(pagePath));
      return root.smoosh();
    }
    function getSortedRouteObjects(objects, getter) {
      const indexes = {};
      const pathnames = [];
      for (let i = 0; i < objects.length; i++) {
        const pathname = getter(objects[i]);
        indexes[pathname] = i;
        pathnames[i] = pathname;
      }
      const sorted = getSortedRoutes(pathnames);
      return sorted.map((pathname) => objects[indexes[pathname]]);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js
var require_is_dynamic = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDynamicRoute", {
      enumerable: true,
      get: function() {
        return isDynamicRoute;
      }
    });
    var _interceptionroutes = require_interception_routes();
    var TEST_ROUTE = /\/\[[^/]+?\](?=\/|$)/;
    function isDynamicRoute(route) {
      if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {
        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;
      }
      return TEST_ROUTE.test(route);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/index.js
var require_utils5 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getSortedRouteObjects: function() {
        return _sortedroutes.getSortedRouteObjects;
      },
      getSortedRoutes: function() {
        return _sortedroutes.getSortedRoutes;
      },
      isDynamicRoute: function() {
        return _isdynamic.isDynamicRoute;
      }
    });
    var _sortedroutes = require_sorted_routes();
    var _isdynamic = require_is_dynamic();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/runtime-config.external.js
var require_runtime_config_external = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/runtime-config.external.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      default: function() {
        return _default;
      },
      setConfig: function() {
        return setConfig;
      }
    });
    var runtimeConfig;
    var _default = () => {
      return runtimeConfig;
    };
    function setConfig(configValue) {
      runtimeConfig = configValue;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/utils.js
var require_utils6 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      cleanAmpPath: function() {
        return cleanAmpPath;
      },
      debounce: function() {
        return debounce;
      },
      isBlockedPage: function() {
        return isBlockedPage;
      }
    });
    var _constants = require_constants3();
    function isBlockedPage(page) {
      return _constants.BLOCKED_PAGES.includes(page);
    }
    function cleanAmpPath(pathname) {
      if (pathname.match(/\?amp=(y|yes|true|1)/)) {
        pathname = pathname.replace(/\?amp=(y|yes|true|1)&?/, "?");
      }
      if (pathname.match(/&amp=(y|yes|true|1)/)) {
        pathname = pathname.replace(/&amp=(y|yes|true|1)/, "");
      }
      pathname = pathname.replace(/\?$/, "");
      return pathname;
    }
    function debounce(fn, ms, maxWait = Infinity) {
      let timeoutId;
      let startTime = 0;
      let lastCall = 0;
      let args, context;
      function run() {
        const now = Date.now();
        const diff = lastCall + ms - now;
        if (diff <= 0 || startTime + maxWait >= now) {
          timeoutId = void 0;
          fn.apply(context, args);
        } else {
          timeoutId = setTimeout(run, diff);
        }
      }
      return function(...passedArgs) {
        args = passedArgs;
        context = this;
        lastCall = Date.now();
        if (timeoutId === void 0) {
          startTime = lastCall;
          timeoutId = setTimeout(run, ms);
        }
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/is-bot.js
var require_is_bot = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/is-bot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isBot", {
      enumerable: true,
      get: function() {
        return isBot;
      }
    });
    var BOT_UA_RE = /Googlebot|Mediapartners-Google|AdsBot-Google|googleweblight|Storebot-Google|Google-PageRenderer|Bingbot|BingPreview|Slurp|DuckDuckBot|baiduspider|yandex|sogou|LinkedInBot|bitlybot|tumblr|vkShare|quora link preview|facebookexternalhit|facebookcatalog|Twitterbot|applebot|redditbot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|ia_archiver/i;
    function isBot(userAgent) {
      return BOT_UA_RE.test(userAgent);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js
var require_normalize_path_sep = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizePathSep", {
      enumerable: true,
      get: function() {
        return normalizePathSep;
      }
    });
    function normalizePathSep(path) {
      return path.replace(/\\/g, "/");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js
var require_denormalize_page_path = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "denormalizePagePath", {
      enumerable: true,
      get: function() {
        return denormalizePagePath;
      }
    });
    var _utils = require_utils5();
    var _normalizepathsep = require_normalize_path_sep();
    function denormalizePagePath(page) {
      let _page = (0, _normalizepathsep.normalizePathSep)(page);
      return _page.startsWith("/index/") && !(0, _utils.isDynamicRoute)(_page) ? _page.slice(6) : _page !== "/index" ? _page : "/";
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/escape-path-delimiters.js
var require_escape_path_delimiters = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/escape-path-delimiters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return escapePathDelimiters;
      }
    });
    function escapePathDelimiters(segment, escapeEncoded) {
      return segment.replace(new RegExp("([/#?]" + (escapeEncoded ? "|%(2f|23|3f|5c)" : "") + ")", "gi"), (char) => encodeURIComponent(char));
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/compiled/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/compiled/path-to-regexp/index.js"(exports, module) {
    (() => {
      "use strict";
      if (typeof __nccwpck_require__ !== "undefined")
        __nccwpck_require__.ab = "/";
      var e = {};
      (() => {
        var r = e;
        Object.defineProperty(r, "__esModule", { value: true });
        function lexer(e2) {
          var r2 = [];
          var n = 0;
          while (n < e2.length) {
            var t = e2[n];
            if (t === "*" || t === "+" || t === "?") {
              r2.push({ type: "MODIFIER", index: n, value: e2[n++] });
              continue;
            }
            if (t === "\\") {
              r2.push({ type: "ESCAPED_CHAR", index: n++, value: e2[n++] });
              continue;
            }
            if (t === "{") {
              r2.push({ type: "OPEN", index: n, value: e2[n++] });
              continue;
            }
            if (t === "}") {
              r2.push({ type: "CLOSE", index: n, value: e2[n++] });
              continue;
            }
            if (t === ":") {
              var i = "";
              var a = n + 1;
              while (a < e2.length) {
                var o = e2.charCodeAt(a);
                if (o >= 48 && o <= 57 || o >= 65 && o <= 90 || o >= 97 && o <= 122 || o === 95) {
                  i += e2[a++];
                  continue;
                }
                break;
              }
              if (!i)
                throw new TypeError("Missing parameter name at " + n);
              r2.push({ type: "NAME", index: n, value: i });
              n = a;
              continue;
            }
            if (t === "(") {
              var f = 1;
              var u = "";
              var a = n + 1;
              if (e2[a] === "?") {
                throw new TypeError('Pattern cannot start with "?" at ' + a);
              }
              while (a < e2.length) {
                if (e2[a] === "\\") {
                  u += e2[a++] + e2[a++];
                  continue;
                }
                if (e2[a] === ")") {
                  f--;
                  if (f === 0) {
                    a++;
                    break;
                  }
                } else if (e2[a] === "(") {
                  f++;
                  if (e2[a + 1] !== "?") {
                    throw new TypeError("Capturing groups are not allowed at " + a);
                  }
                }
                u += e2[a++];
              }
              if (f)
                throw new TypeError("Unbalanced pattern at " + n);
              if (!u)
                throw new TypeError("Missing pattern at " + n);
              r2.push({ type: "PATTERN", index: n, value: u });
              n = a;
              continue;
            }
            r2.push({ type: "CHAR", index: n, value: e2[n++] });
          }
          r2.push({ type: "END", index: n, value: "" });
          return r2;
        }
        function parse(e2, r2) {
          if (r2 === void 0) {
            r2 = {};
          }
          var n = lexer(e2);
          var t = r2.prefixes, i = t === void 0 ? "./" : t;
          var a = "[^" + escapeString(r2.delimiter || "/#?") + "]+?";
          var o = [];
          var f = 0;
          var u = 0;
          var p = "";
          var tryConsume = function(e3) {
            if (u < n.length && n[u].type === e3)
              return n[u++].value;
          };
          var mustConsume = function(e3) {
            var r3 = tryConsume(e3);
            if (r3 !== void 0)
              return r3;
            var t2 = n[u], i2 = t2.type, a2 = t2.index;
            throw new TypeError("Unexpected " + i2 + " at " + a2 + ", expected " + e3);
          };
          var consumeText = function() {
            var e3 = "";
            var r3;
            while (r3 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
              e3 += r3;
            }
            return e3;
          };
          while (u < n.length) {
            var v = tryConsume("CHAR");
            var c = tryConsume("NAME");
            var s = tryConsume("PATTERN");
            if (c || s) {
              var d = v || "";
              if (i.indexOf(d) === -1) {
                p += d;
                d = "";
              }
              if (p) {
                o.push(p);
                p = "";
              }
              o.push({ name: c || f++, prefix: d, suffix: "", pattern: s || a, modifier: tryConsume("MODIFIER") || "" });
              continue;
            }
            var g = v || tryConsume("ESCAPED_CHAR");
            if (g) {
              p += g;
              continue;
            }
            if (p) {
              o.push(p);
              p = "";
            }
            var x = tryConsume("OPEN");
            if (x) {
              var d = consumeText();
              var l = tryConsume("NAME") || "";
              var h = tryConsume("PATTERN") || "";
              var m = consumeText();
              mustConsume("CLOSE");
              o.push({ name: l || (h ? f++ : ""), pattern: l && !h ? a : h, prefix: d, suffix: m, modifier: tryConsume("MODIFIER") || "" });
              continue;
            }
            mustConsume("END");
          }
          return o;
        }
        r.parse = parse;
        function compile(e2, r2) {
          return tokensToFunction(parse(e2, r2), r2);
        }
        r.compile = compile;
        function tokensToFunction(e2, r2) {
          if (r2 === void 0) {
            r2 = {};
          }
          var n = flags(r2);
          var t = r2.encode, i = t === void 0 ? function(e3) {
            return e3;
          } : t, a = r2.validate, o = a === void 0 ? true : a;
          var f = e2.map(function(e3) {
            if (typeof e3 === "object") {
              return new RegExp("^(?:" + e3.pattern + ")$", n);
            }
          });
          return function(r3) {
            var n2 = "";
            for (var t2 = 0; t2 < e2.length; t2++) {
              var a2 = e2[t2];
              if (typeof a2 === "string") {
                n2 += a2;
                continue;
              }
              var u = r3 ? r3[a2.name] : void 0;
              var p = a2.modifier === "?" || a2.modifier === "*";
              var v = a2.modifier === "*" || a2.modifier === "+";
              if (Array.isArray(u)) {
                if (!v) {
                  throw new TypeError('Expected "' + a2.name + '" to not repeat, but got an array');
                }
                if (u.length === 0) {
                  if (p)
                    continue;
                  throw new TypeError('Expected "' + a2.name + '" to not be empty');
                }
                for (var c = 0; c < u.length; c++) {
                  var s = i(u[c], a2);
                  if (o && !f[t2].test(s)) {
                    throw new TypeError('Expected all "' + a2.name + '" to match "' + a2.pattern + '", but got "' + s + '"');
                  }
                  n2 += a2.prefix + s + a2.suffix;
                }
                continue;
              }
              if (typeof u === "string" || typeof u === "number") {
                var s = i(String(u), a2);
                if (o && !f[t2].test(s)) {
                  throw new TypeError('Expected "' + a2.name + '" to match "' + a2.pattern + '", but got "' + s + '"');
                }
                n2 += a2.prefix + s + a2.suffix;
                continue;
              }
              if (p)
                continue;
              var d = v ? "an array" : "a string";
              throw new TypeError('Expected "' + a2.name + '" to be ' + d);
            }
            return n2;
          };
        }
        r.tokensToFunction = tokensToFunction;
        function match(e2, r2) {
          var n = [];
          var t = pathToRegexp(e2, n, r2);
          return regexpToFunction(t, n, r2);
        }
        r.match = match;
        function regexpToFunction(e2, r2, n) {
          if (n === void 0) {
            n = {};
          }
          var t = n.decode, i = t === void 0 ? function(e3) {
            return e3;
          } : t;
          return function(n2) {
            var t2 = e2.exec(n2);
            if (!t2)
              return false;
            var a = t2[0], o = t2.index;
            var f = /* @__PURE__ */ Object.create(null);
            var _loop_1 = function(e3) {
              if (t2[e3] === void 0)
                return "continue";
              var n3 = r2[e3 - 1];
              if (n3.modifier === "*" || n3.modifier === "+") {
                f[n3.name] = t2[e3].split(n3.prefix + n3.suffix).map(function(e4) {
                  return i(e4, n3);
                });
              } else {
                f[n3.name] = i(t2[e3], n3);
              }
            };
            for (var u = 1; u < t2.length; u++) {
              _loop_1(u);
            }
            return { path: a, index: o, params: f };
          };
        }
        r.regexpToFunction = regexpToFunction;
        function escapeString(e2) {
          return e2.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
        }
        function flags(e2) {
          return e2 && e2.sensitive ? "" : "i";
        }
        function regexpToRegexp(e2, r2) {
          if (!r2)
            return e2;
          var n = e2.source.match(/\((?!\?)/g);
          if (n) {
            for (var t = 0; t < n.length; t++) {
              r2.push({ name: t, prefix: "", suffix: "", modifier: "", pattern: "" });
            }
          }
          return e2;
        }
        function arrayToRegexp(e2, r2, n) {
          var t = e2.map(function(e3) {
            return pathToRegexp(e3, r2, n).source;
          });
          return new RegExp("(?:" + t.join("|") + ")", flags(n));
        }
        function stringToRegexp(e2, r2, n) {
          return tokensToRegexp(parse(e2, n), r2, n);
        }
        function tokensToRegexp(e2, r2, n) {
          if (n === void 0) {
            n = {};
          }
          var t = n.strict, i = t === void 0 ? false : t, a = n.start, o = a === void 0 ? true : a, f = n.end, u = f === void 0 ? true : f, p = n.encode, v = p === void 0 ? function(e3) {
            return e3;
          } : p;
          var c = "[" + escapeString(n.endsWith || "") + "]|$";
          var s = "[" + escapeString(n.delimiter || "/#?") + "]";
          var d = o ? "^" : "";
          for (var g = 0, x = e2; g < x.length; g++) {
            var l = x[g];
            if (typeof l === "string") {
              d += escapeString(v(l));
            } else {
              var h = escapeString(v(l.prefix));
              var m = escapeString(v(l.suffix));
              if (l.pattern) {
                if (r2)
                  r2.push(l);
                if (h || m) {
                  if (l.modifier === "+" || l.modifier === "*") {
                    var E = l.modifier === "*" ? "?" : "";
                    d += "(?:" + h + "((?:" + l.pattern + ")(?:" + m + h + "(?:" + l.pattern + "))*)" + m + ")" + E;
                  } else {
                    d += "(?:" + h + "(" + l.pattern + ")" + m + ")" + l.modifier;
                  }
                } else {
                  d += "(" + l.pattern + ")" + l.modifier;
                }
              } else {
                d += "(?:" + h + m + ")" + l.modifier;
              }
            }
          }
          if (u) {
            if (!i)
              d += s + "?";
            d += !n.endsWith ? "$" : "(?=" + c + ")";
          } else {
            var T = e2[e2.length - 1];
            var y = typeof T === "string" ? s.indexOf(T[T.length - 1]) > -1 : T === void 0;
            if (!i) {
              d += "(?:" + s + "(?=" + c + "))?";
            }
            if (!y) {
              d += "(?=" + s + "|" + c + ")";
            }
          }
          return new RegExp(d, flags(n));
        }
        r.tokensToRegexp = tokensToRegexp;
        function pathToRegexp(e2, r2, n) {
          if (e2 instanceof RegExp)
            return regexpToRegexp(e2, r2);
          if (Array.isArray(e2))
            return arrayToRegexp(e2, r2, n);
          return stringToRegexp(e2, r2, n);
        }
        r.pathToRegexp = pathToRegexp;
      })();
      module.exports = e;
    })();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/path-match.js
var require_path_match = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/path-match.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getPathMatch", {
      enumerable: true,
      get: function() {
        return getPathMatch;
      }
    });
    var _pathtoregexp = require_path_to_regexp();
    function getPathMatch(path, options) {
      const keys = [];
      const regexp = (0, _pathtoregexp.pathToRegexp)(path, keys, {
        delimiter: "/",
        sensitive: typeof (options == null ? void 0 : options.sensitive) === "boolean" ? options.sensitive : false,
        strict: options == null ? void 0 : options.strict
      });
      const matcher = (0, _pathtoregexp.regexpToFunction)((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);
      return (pathname, params) => {
        if (typeof pathname !== "string")
          return false;
        const match = matcher(pathname);
        if (!match)
          return false;
        if (options == null ? void 0 : options.removeUnnamedParams) {
          for (const key of keys) {
            if (typeof key.name === "number") {
              delete match.params[key.name];
            }
          }
        }
        return {
          ...params,
          ...match.params
        };
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/prepare-destination.js
var require_prepare_destination = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/prepare-destination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      compileNonPath: function() {
        return compileNonPath;
      },
      matchHas: function() {
        return matchHas;
      },
      prepareDestination: function() {
        return prepareDestination;
      }
    });
    var _pathtoregexp = require_path_to_regexp();
    var _escaperegexp = require_escape_regexp();
    var _parseurl = require_parse_url();
    var _interceptionroutes = require_interception_routes();
    var _approuterheaders = require_app_router_headers();
    var _getcookieparser = require_get_cookie_parser();
    function getSafeParamName(paramName) {
      let newParamName = "";
      for (let i = 0; i < paramName.length; i++) {
        const charCode = paramName.charCodeAt(i);
        if (charCode > 64 && charCode < 91 || // A-Z
        charCode > 96 && charCode < 123) {
          newParamName += paramName[i];
        }
      }
      return newParamName;
    }
    function escapeSegment(str, segmentName) {
      return str.replace(new RegExp(":" + (0, _escaperegexp.escapeStringRegexp)(segmentName), "g"), "__ESC_COLON_" + segmentName);
    }
    function unescapeSegments(str) {
      return str.replace(/__ESC_COLON_/gi, ":");
    }
    function matchHas(req, query, has, missing) {
      if (has === void 0)
        has = [];
      if (missing === void 0)
        missing = [];
      const params = {};
      const hasMatch = (hasItem) => {
        let value;
        let key = hasItem.key;
        switch (hasItem.type) {
          case "header": {
            key = key.toLowerCase();
            value = req.headers[key];
            break;
          }
          case "cookie": {
            if ("cookies" in req) {
              value = req.cookies[hasItem.key];
            } else {
              const cookies = (0, _getcookieparser.getCookieParser)(req.headers)();
              value = cookies[hasItem.key];
            }
            break;
          }
          case "query": {
            value = query[key];
            break;
          }
          case "host": {
            const { host } = (req == null ? void 0 : req.headers) || {};
            const hostname = host == null ? void 0 : host.split(":", 1)[0].toLowerCase();
            value = hostname;
            break;
          }
          default: {
            break;
          }
        }
        if (!hasItem.value && value) {
          params[getSafeParamName(key)] = value;
          return true;
        } else if (value) {
          const matcher = new RegExp("^" + hasItem.value + "$");
          const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);
          if (matches) {
            if (Array.isArray(matches)) {
              if (matches.groups) {
                Object.keys(matches.groups).forEach((groupKey) => {
                  params[groupKey] = matches.groups[groupKey];
                });
              } else if (hasItem.type === "host" && matches[0]) {
                params.host = matches[0];
              }
            }
            return true;
          }
        }
        return false;
      };
      const allMatch = has.every((item) => hasMatch(item)) && !missing.some((item) => hasMatch(item));
      if (allMatch) {
        return params;
      }
      return false;
    }
    function compileNonPath(value, params) {
      if (!value.includes(":")) {
        return value;
      }
      for (const key of Object.keys(params)) {
        if (value.includes(":" + key)) {
          value = value.replace(new RegExp(":" + key + "\\*", "g"), ":" + key + "--ESCAPED_PARAM_ASTERISKS").replace(new RegExp(":" + key + "\\?", "g"), ":" + key + "--ESCAPED_PARAM_QUESTION").replace(new RegExp(":" + key + "\\+", "g"), ":" + key + "--ESCAPED_PARAM_PLUS").replace(new RegExp(":" + key + "(?!\\w)", "g"), "--ESCAPED_PARAM_COLON" + key);
        }
      }
      value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, "\\$1").replace(/--ESCAPED_PARAM_PLUS/g, "+").replace(/--ESCAPED_PARAM_COLON/g, ":").replace(/--ESCAPED_PARAM_QUESTION/g, "?").replace(/--ESCAPED_PARAM_ASTERISKS/g, "*");
      return (0, _pathtoregexp.compile)("/" + value, {
        validate: false
      })(params).slice(1);
    }
    function prepareDestination(args) {
      const query = Object.assign({}, args.query);
      delete query.__nextLocale;
      delete query.__nextDefaultLocale;
      delete query.__nextDataReq;
      delete query.__nextInferredLocaleFromDefault;
      delete query[_approuterheaders.NEXT_RSC_UNION_QUERY];
      let escapedDestination = args.destination;
      for (const param of Object.keys({
        ...args.params,
        ...query
      })) {
        escapedDestination = param ? escapeSegment(escapedDestination, param) : escapedDestination;
      }
      const parsedDestination = (0, _parseurl.parseUrl)(escapedDestination);
      const destQuery = parsedDestination.query;
      const destPath = unescapeSegments("" + parsedDestination.pathname + (parsedDestination.hash || ""));
      const destHostname = unescapeSegments(parsedDestination.hostname || "");
      const destPathParamKeys = [];
      const destHostnameParamKeys = [];
      (0, _pathtoregexp.pathToRegexp)(destPath, destPathParamKeys);
      (0, _pathtoregexp.pathToRegexp)(destHostname, destHostnameParamKeys);
      const destParams = [];
      destPathParamKeys.forEach((key) => destParams.push(key.name));
      destHostnameParamKeys.forEach((key) => destParams.push(key.name));
      const destPathCompiler = (0, _pathtoregexp.compile)(
        destPath,
        // we don't validate while compiling the destination since we should
        // have already validated before we got to this point and validating
        // breaks compiling destinations with named pattern params from the source
        // e.g. /something:hello(.*) -> /another/:hello is broken with validation
        // since compile validation is meant for reversing and not for inserting
        // params from a separate path-regex into another
        {
          validate: false
        }
      );
      const destHostnameCompiler = (0, _pathtoregexp.compile)(destHostname, {
        validate: false
      });
      for (const [key, strOrArray] of Object.entries(destQuery)) {
        if (Array.isArray(strOrArray)) {
          destQuery[key] = strOrArray.map((value) => compileNonPath(unescapeSegments(value), args.params));
        } else if (typeof strOrArray === "string") {
          destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);
        }
      }
      let paramKeys = Object.keys(args.params).filter((name) => name !== "nextInternalLocale");
      if (args.appendParamsToQuery && !paramKeys.some((key) => destParams.includes(key))) {
        for (const key of paramKeys) {
          if (!(key in destQuery)) {
            destQuery[key] = args.params[key];
          }
        }
      }
      let newUrl;
      if ((0, _interceptionroutes.isInterceptionRouteAppPath)(destPath)) {
        for (const segment of destPath.split("/")) {
          const marker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
          if (marker) {
            if (marker === "(..)(..)") {
              args.params["0"] = "(..)";
              args.params["1"] = "(..)";
            } else {
              args.params["0"] = marker;
            }
            break;
          }
        }
      }
      try {
        newUrl = destPathCompiler(args.params);
        const [pathname, hash] = newUrl.split("#", 2);
        parsedDestination.hostname = destHostnameCompiler(args.params);
        parsedDestination.pathname = pathname;
        parsedDestination.hash = (hash ? "#" : "") + (hash || "");
        delete parsedDestination.search;
      } catch (err) {
        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
          throw new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match");
        }
        throw err;
      }
      parsedDestination.query = {
        ...query,
        ...parsedDestination.query
      };
      return {
        newUrl,
        destQuery,
        parsedDestination
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/server-utils.js
var require_server_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/server-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getUtils: function() {
        return getUtils;
      },
      interpolateDynamicPath: function() {
        return interpolateDynamicPath;
      },
      normalizeDynamicRouteParams: function() {
        return normalizeDynamicRouteParams;
      },
      normalizeVercelUrl: function() {
        return normalizeVercelUrl;
      }
    });
    var _url = require("url");
    var _normalizelocalepath = require_normalize_locale_path();
    var _pathmatch = require_path_match();
    var _routeregex = require_route_regex();
    var _routematcher = require_route_matcher();
    var _preparedestination = require_prepare_destination();
    var _removetrailingslash = require_remove_trailing_slash();
    var _apppaths = require_app_paths();
    var _constants = require_constants();
    function normalizeVercelUrl(req, trustQuery, paramKeys, pageIsDynamic, defaultRouteRegex) {
      if (pageIsDynamic && trustQuery && defaultRouteRegex) {
        const _parsedUrl = (0, _url.parse)(req.url, true);
        delete _parsedUrl.search;
        for (const key of Object.keys(_parsedUrl.query)) {
          const isNextQueryPrefix = key !== _constants.NEXT_QUERY_PARAM_PREFIX && key.startsWith(_constants.NEXT_QUERY_PARAM_PREFIX);
          const isNextInterceptionMarkerPrefix = key !== _constants.NEXT_INTERCEPTION_MARKER_PREFIX && key.startsWith(_constants.NEXT_INTERCEPTION_MARKER_PREFIX);
          if (isNextQueryPrefix || isNextInterceptionMarkerPrefix || (paramKeys || Object.keys(defaultRouteRegex.groups)).includes(key)) {
            delete _parsedUrl.query[key];
          }
        }
        req.url = (0, _url.format)(_parsedUrl);
      }
    }
    function interpolateDynamicPath(pathname, params, defaultRouteRegex) {
      if (!defaultRouteRegex)
        return pathname;
      for (const param of Object.keys(defaultRouteRegex.groups)) {
        const { optional, repeat } = defaultRouteRegex.groups[param];
        let builtParam = `[${repeat ? "..." : ""}${param}]`;
        if (optional) {
          builtParam = `[${builtParam}]`;
        }
        let paramValue;
        const value = params[param];
        if (Array.isArray(value)) {
          paramValue = value.map((v) => v && encodeURIComponent(v)).join("/");
        } else if (value) {
          paramValue = encodeURIComponent(value);
        } else {
          paramValue = "";
        }
        pathname = pathname.replaceAll(builtParam, paramValue);
      }
      return pathname;
    }
    function normalizeDynamicRouteParams(params, ignoreOptional, defaultRouteRegex, defaultRouteMatches) {
      let hasValidParams = true;
      if (!defaultRouteRegex)
        return {
          params,
          hasValidParams: false
        };
      params = Object.keys(defaultRouteRegex.groups).reduce((prev, key) => {
        let value = params[key];
        if (typeof value === "string") {
          value = (0, _apppaths.normalizeRscURL)(value);
        }
        if (Array.isArray(value)) {
          value = value.map((val) => {
            if (typeof val === "string") {
              val = (0, _apppaths.normalizeRscURL)(val);
            }
            return val;
          });
        }
        const defaultValue = defaultRouteMatches[key];
        const isOptional = defaultRouteRegex.groups[key].optional;
        const isDefaultValue = Array.isArray(defaultValue) ? defaultValue.some((defaultVal) => {
          return Array.isArray(value) ? value.some((val) => val.includes(defaultVal)) : value == null ? void 0 : value.includes(defaultVal);
        }) : value == null ? void 0 : value.includes(defaultValue);
        if (isDefaultValue || typeof value === "undefined" && !(isOptional && ignoreOptional)) {
          hasValidParams = false;
        }
        if (isOptional && (!value || Array.isArray(value) && value.length === 1 && // fallback optional catch-all SSG pages have
        // [[...paramName]] for the root path on Vercel
        (value[0] === "index" || value[0] === `[[...${key}]]`))) {
          value = void 0;
          delete params[key];
        }
        if (value && typeof value === "string" && defaultRouteRegex.groups[key].repeat) {
          value = value.split("/");
        }
        if (value) {
          prev[key] = value;
        }
        return prev;
      }, {});
      return {
        params,
        hasValidParams
      };
    }
    function getUtils({ page, i18n, basePath, rewrites, pageIsDynamic, trailingSlash, caseSensitive }) {
      let defaultRouteRegex;
      let dynamicRouteMatcher;
      let defaultRouteMatches;
      if (pageIsDynamic) {
        defaultRouteRegex = (0, _routeregex.getNamedRouteRegex)(page, false);
        dynamicRouteMatcher = (0, _routematcher.getRouteMatcher)(defaultRouteRegex);
        defaultRouteMatches = dynamicRouteMatcher(page);
      }
      function handleRewrites(req, parsedUrl) {
        const rewriteParams = {};
        let fsPathname = parsedUrl.pathname;
        const matchesPage = () => {
          const fsPathnameNoSlash = (0, _removetrailingslash.removeTrailingSlash)(fsPathname || "");
          return fsPathnameNoSlash === (0, _removetrailingslash.removeTrailingSlash)(page) || (dynamicRouteMatcher == null ? void 0 : dynamicRouteMatcher(fsPathnameNoSlash));
        };
        const checkRewrite = (rewrite) => {
          const matcher = (0, _pathmatch.getPathMatch)(rewrite.source + (trailingSlash ? "(/)?" : ""), {
            removeUnnamedParams: true,
            strict: true,
            sensitive: !!caseSensitive
          });
          let params = matcher(parsedUrl.pathname);
          if ((rewrite.has || rewrite.missing) && params) {
            const hasParams = (0, _preparedestination.matchHas)(req, parsedUrl.query, rewrite.has, rewrite.missing);
            if (hasParams) {
              Object.assign(params, hasParams);
            } else {
              params = false;
            }
          }
          if (params) {
            const { parsedDestination, destQuery } = (0, _preparedestination.prepareDestination)({
              appendParamsToQuery: true,
              destination: rewrite.destination,
              params,
              query: parsedUrl.query
            });
            if (parsedDestination.protocol) {
              return true;
            }
            Object.assign(rewriteParams, destQuery, params);
            Object.assign(parsedUrl.query, parsedDestination.query);
            delete parsedDestination.query;
            Object.assign(parsedUrl, parsedDestination);
            fsPathname = parsedUrl.pathname;
            if (basePath) {
              fsPathname = fsPathname.replace(new RegExp(`^${basePath}`), "") || "/";
            }
            if (i18n) {
              const destLocalePathResult = (0, _normalizelocalepath.normalizeLocalePath)(fsPathname, i18n.locales);
              fsPathname = destLocalePathResult.pathname;
              parsedUrl.query.nextInternalLocale = destLocalePathResult.detectedLocale || params.nextInternalLocale;
            }
            if (fsPathname === page) {
              return true;
            }
            if (pageIsDynamic && dynamicRouteMatcher) {
              const dynamicParams = dynamicRouteMatcher(fsPathname);
              if (dynamicParams) {
                parsedUrl.query = {
                  ...parsedUrl.query,
                  ...dynamicParams
                };
                return true;
              }
            }
          }
          return false;
        };
        for (const rewrite of rewrites.beforeFiles || []) {
          checkRewrite(rewrite);
        }
        if (fsPathname !== page) {
          let finished = false;
          for (const rewrite of rewrites.afterFiles || []) {
            finished = checkRewrite(rewrite);
            if (finished)
              break;
          }
          if (!finished && !matchesPage()) {
            for (const rewrite of rewrites.fallback || []) {
              finished = checkRewrite(rewrite);
              if (finished)
                break;
            }
          }
        }
        return rewriteParams;
      }
      function getParamsFromRouteMatches(req, renderOpts, detectedLocale) {
        return (0, _routematcher.getRouteMatcher)(function() {
          const { groups, routeKeys } = defaultRouteRegex;
          return {
            re: {
              // Simulate a RegExp match from the \`req.url\` input
              exec: (str) => {
                const obj = Object.fromEntries(new URLSearchParams(str));
                const matchesHasLocale = i18n && detectedLocale && obj["1"] === detectedLocale;
                for (const key of Object.keys(obj)) {
                  const value = obj[key];
                  if (key !== _constants.NEXT_QUERY_PARAM_PREFIX && key.startsWith(_constants.NEXT_QUERY_PARAM_PREFIX)) {
                    const normalizedKey = key.substring(_constants.NEXT_QUERY_PARAM_PREFIX.length);
                    obj[normalizedKey] = value;
                    delete obj[key];
                  }
                }
                const routeKeyNames = Object.keys(routeKeys || {});
                const filterLocaleItem = (val) => {
                  if (i18n) {
                    const isCatchAll = Array.isArray(val);
                    const _val = isCatchAll ? val[0] : val;
                    if (typeof _val === "string" && i18n.locales.some((item) => {
                      if (item.toLowerCase() === _val.toLowerCase()) {
                        detectedLocale = item;
                        renderOpts.locale = detectedLocale;
                        return true;
                      }
                      return false;
                    })) {
                      if (isCatchAll) {
                        val.splice(0, 1);
                      }
                      return isCatchAll ? val.length === 0 : true;
                    }
                  }
                  return false;
                };
                if (routeKeyNames.every((name) => obj[name])) {
                  return routeKeyNames.reduce((prev, keyName) => {
                    const paramName = routeKeys == null ? void 0 : routeKeys[keyName];
                    if (paramName && !filterLocaleItem(obj[keyName])) {
                      prev[groups[paramName].pos] = obj[keyName];
                    }
                    return prev;
                  }, {});
                }
                return Object.keys(obj).reduce((prev, key) => {
                  if (!filterLocaleItem(obj[key])) {
                    let normalizedKey = key;
                    if (matchesHasLocale) {
                      normalizedKey = parseInt(key, 10) - 1 + "";
                    }
                    return Object.assign(prev, {
                      [normalizedKey]: obj[key]
                    });
                  }
                  return prev;
                }, {});
              }
            },
            groups
          };
        }())(req.headers["x-now-route-matches"]);
      }
      return {
        handleRewrites,
        defaultRouteRegex,
        dynamicRouteMatcher,
        defaultRouteMatches,
        getParamsFromRouteMatches,
        normalizeDynamicRouteParams: (params, ignoreOptional) => normalizeDynamicRouteParams(params, ignoreOptional, defaultRouteRegex, defaultRouteMatches),
        normalizeVercelUrl: (req, trustQuery, paramKeys) => normalizeVercelUrl(req, trustQuery, paramKeys, pageIsDynamic, defaultRouteRegex),
        interpolateDynamicPath: (pathname, params) => interpolateDynamicPath(pathname, params, defaultRouteRegex)
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/is-plain-object.js
var require_is_plain_object = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/is-plain-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getObjectClassLabel: function() {
        return getObjectClassLabel;
      },
      isPlainObject: function() {
        return isPlainObject;
      }
    });
    function getObjectClassLabel(value) {
      return Object.prototype.toString.call(value);
    }
    function isPlainObject(value) {
      if (getObjectClassLabel(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype.hasOwnProperty("isPrototypeOf");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/is-error.js
var require_is_error = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/is-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      /**
      * Checks whether the given value is a NextError.
      * This can be used to print a more detailed error message with properties like `code` & `digest`.
      */
      default: function() {
        return isError;
      },
      getProperError: function() {
        return getProperError;
      }
    });
    var _isplainobject = require_is_plain_object();
    function isError(err) {
      return typeof err === "object" && err !== null && "name" in err && "message" in err;
    }
    function getProperError(err) {
      if (isError(err)) {
        return err;
      }
      if (false) {
        if (typeof err === "undefined") {
          return new Error("An undefined error was thrown, see here for more info: https://nextjs.org/docs/messages/threw-undefined");
        }
        if (err === null) {
          return new Error("A null error was thrown, see here for more info: https://nextjs.org/docs/messages/threw-undefined");
        }
      }
      return new Error((0, _isplainobject.isPlainObject)(err) ? JSON.stringify(err) : err + "");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/locale-route-normalizer.js
var require_locale_route_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/locale-route-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "LocaleRouteNormalizer", {
      enumerable: true,
      get: function() {
        return LocaleRouteNormalizer;
      }
    });
    var LocaleRouteNormalizer = class {
      constructor(provider) {
        this.provider = provider;
      }
      /**
      * Normalizes the pathname by removing the locale prefix if any.
      *
      * @param pathname The pathname to normalize.
      * @returns The pathname without the locale prefix (if any).
      */
      normalize(pathname) {
        const match = this.provider.analyze(pathname);
        return match.pathname;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/route-matcher.js
var require_route_matcher2 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "RouteMatcher", {
      enumerable: true,
      get: function() {
        return RouteMatcher;
      }
    });
    var _utils = require_utils5();
    var _routematcher = require_route_matcher();
    var _routeregex = require_route_regex();
    var RouteMatcher = class {
      constructor(definition) {
        this.definition = definition;
        if ((0, _utils.isDynamicRoute)(definition.pathname)) {
          this.dynamic = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(definition.pathname));
        }
      }
      /**
      * Identity returns the identity part of the matcher. This is used to compare
      * a unique matcher to another. This is also used when sorting dynamic routes,
      * so it must contain the pathname part.
      */
      get identity() {
        return this.definition.pathname;
      }
      get isDynamic() {
        return this.dynamic !== void 0;
      }
      match(pathname) {
        const result = this.test(pathname);
        if (!result)
          return null;
        return {
          definition: this.definition,
          params: result.params
        };
      }
      test(pathname) {
        if (this.dynamic) {
          const params = this.dynamic(pathname);
          if (!params)
            return null;
          return {
            params
          };
        }
        if (pathname === this.definition.pathname) {
          return {};
        }
        return null;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/locale-route-matcher.js
var require_locale_route_matcher = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/locale-route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "LocaleRouteMatcher", {
      enumerable: true,
      get: function() {
        return LocaleRouteMatcher;
      }
    });
    var _routematcher = require_route_matcher2();
    var LocaleRouteMatcher = class extends _routematcher.RouteMatcher {
      /**
      * Identity returns the identity part of the matcher. This is used to compare
      * a unique matcher to another. This is also used when sorting dynamic routes,
      * so it must contain the pathname part as well.
      */
      get identity() {
        var _this_definition_i18n;
        return `${this.definition.pathname}?__nextLocale=${(_this_definition_i18n = this.definition.i18n) == null ? void 0 : _this_definition_i18n.locale}`;
      }
      /**
      * Match will attempt to match the given pathname against this route while
      * also taking into account the locale information.
      *
      * @param pathname The pathname to match against.
      * @param options The options to use when matching.
      * @returns The match result, or `null` if there was no match.
      */
      match(pathname, options) {
        var _options_i18n, _this_definition_i18n;
        const result = this.test(pathname, options);
        if (!result)
          return null;
        return {
          definition: this.definition,
          params: result.params,
          detectedLocale: (options == null ? void 0 : (_options_i18n = options.i18n) == null ? void 0 : _options_i18n.detectedLocale) ?? ((_this_definition_i18n = this.definition.i18n) == null ? void 0 : _this_definition_i18n.locale)
        };
      }
      /**
      * Test will attempt to match the given pathname against this route while
      * also taking into account the locale information.
      *
      * @param pathname The pathname to match against.
      * @param options The options to use when matching.
      * @returns The match result, or `null` if there was no match.
      */
      test(pathname, options) {
        if (this.definition.i18n && (options == null ? void 0 : options.i18n)) {
          if (this.definition.i18n.locale && options.i18n.detectedLocale && this.definition.i18n.locale !== options.i18n.detectedLocale) {
            return null;
          }
          return super.test(options.i18n.pathname);
        }
        return super.test(pathname);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-managers/default-route-matcher-manager.js
var require_default_route_matcher_manager = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-managers/default-route-matcher-manager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DefaultRouteMatcherManager", {
      enumerable: true,
      get: function() {
        return DefaultRouteMatcherManager;
      }
    });
    var _utils = require_utils5();
    var _localeroutematcher = require_locale_route_matcher();
    var _ensureleadingslash = require_ensure_leading_slash();
    var _detachedpromise = require_detached_promise();
    var DefaultRouteMatcherManager = class {
      /**
      * When this value changes, it indicates that a change has been introduced
      * that requires recompilation.
      */
      get compilationID() {
        return this.providers.length;
      }
      async waitTillReady() {
        if (this.waitTillReadyPromise) {
          await this.waitTillReadyPromise;
          delete this.waitTillReadyPromise;
        }
      }
      async reload() {
        const { promise, resolve, reject } = new _detachedpromise.DetachedPromise();
        this.waitTillReadyPromise = promise;
        const compilationID = this.compilationID;
        try {
          const matchers = [];
          const providersMatchers = await Promise.all(this.providers.map((provider) => provider.matchers()));
          const all = /* @__PURE__ */ new Map();
          const duplicates = {};
          for (const providerMatchers of providersMatchers) {
            for (const matcher of providerMatchers) {
              if (matcher.duplicated)
                delete matcher.duplicated;
              const duplicate = all.get(matcher.definition.pathname);
              if (duplicate) {
                const others = duplicates[matcher.definition.pathname] ?? [
                  duplicate
                ];
                others.push(matcher);
                duplicates[matcher.definition.pathname] = others;
                duplicate.duplicated = others;
                matcher.duplicated = others;
              }
              matchers.push(matcher);
              all.set(matcher.definition.pathname, matcher);
            }
          }
          this.matchers.duplicates = duplicates;
          if (this.previousMatchers.length === matchers.length && this.previousMatchers.every((cachedMatcher, index) => cachedMatcher === matchers[index])) {
            return;
          }
          this.previousMatchers = matchers;
          this.matchers.static = matchers.filter((matcher) => !matcher.isDynamic);
          const dynamic = matchers.filter((matcher) => matcher.isDynamic);
          const reference = /* @__PURE__ */ new Map();
          const pathnames = new Array();
          for (let index = 0; index < dynamic.length; index++) {
            const pathname = dynamic[index].definition.pathname;
            const indexes = reference.get(pathname) ?? [];
            indexes.push(index);
            if (indexes.length === 1)
              reference.set(pathname, indexes);
            else
              continue;
            pathnames.push(pathname);
          }
          const sorted = (0, _utils.getSortedRoutes)(pathnames);
          const sortedDynamicMatchers = [];
          for (const pathname of sorted) {
            const indexes = reference.get(pathname);
            if (!Array.isArray(indexes)) {
              throw new Error("Invariant: expected to find identity in indexes map");
            }
            const dynamicMatches = indexes.map((index) => dynamic[index]);
            sortedDynamicMatchers.push(...dynamicMatches);
          }
          this.matchers.dynamic = sortedDynamicMatchers;
          if (this.compilationID !== compilationID) {
            throw new Error("Invariant: expected compilation to finish before new matchers were added, possible missing await");
          }
        } catch (err) {
          reject(err);
        } finally {
          this.lastCompilationID = compilationID;
          resolve();
        }
      }
      push(provider) {
        this.providers.push(provider);
      }
      async test(pathname, options) {
        const match = await this.match(pathname, options);
        return match !== null;
      }
      async match(pathname, options) {
        for await (const match of this.matchAll(pathname, options)) {
          return match;
        }
        return null;
      }
      /**
      * This is a point for other managers to override to inject other checking
      * behavior like duplicate route checking on a per-request basis.
      *
      * @param pathname the pathname to validate against
      * @param matcher the matcher to validate/test with
      * @returns the match if found
      */
      validate(pathname, matcher, options) {
        var _options_i18n;
        if (matcher instanceof _localeroutematcher.LocaleRouteMatcher) {
          return matcher.match(pathname, options);
        }
        if ((_options_i18n = options.i18n) == null ? void 0 : _options_i18n.inferredFromDefault) {
          return matcher.match(options.i18n.pathname);
        }
        return matcher.match(pathname);
      }
      async *matchAll(pathname, options) {
        if (this.lastCompilationID !== this.compilationID) {
          throw new Error("Invariant: expected routes to have been loaded before match");
        }
        pathname = (0, _ensureleadingslash.ensureLeadingSlash)(pathname);
        if (!(0, _utils.isDynamicRoute)(pathname)) {
          for (const matcher of this.matchers.static) {
            const match = this.validate(pathname, matcher, options);
            if (!match)
              continue;
            yield match;
          }
        }
        if (options == null ? void 0 : options.skipDynamic)
          return null;
        for (const matcher of this.matchers.dynamic) {
          const match = this.validate(pathname, matcher, options);
          if (!match)
            continue;
          yield match;
        }
        return null;
      }
      constructor() {
        this.providers = [];
        this.matchers = {
          static: [],
          dynamic: [],
          duplicates: {}
        };
        this.lastCompilationID = this.compilationID;
        this.previousMatchers = [];
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/is-app-page-route.js
var require_is_app_page_route = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/is-app-page-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isAppPageRoute", {
      enumerable: true,
      get: function() {
        return isAppPageRoute;
      }
    });
    function isAppPageRoute(route) {
      return route.endsWith("/page");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/normalizers.js
var require_normalizers = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/normalizers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Normalizers", {
      enumerable: true,
      get: function() {
        return Normalizers;
      }
    });
    var Normalizers = class {
      constructor(normalizers = []) {
        this.normalizers = normalizers;
      }
      push(normalizer) {
        this.normalizers.push(normalizer);
      }
      normalize(pathname) {
        return this.normalizers.reduce((normalized, normalizer) => normalizer.normalize(normalized), pathname);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/isomorphic/path.js
var require_path = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/isomorphic/path.js"(exports, module) {
    "use strict";
    var path;
    if (false) {
      path = null;
    } else {
      path = require("path");
    }
    module.exports = path;
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/prefixing-normalizer.js
var require_prefixing_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/prefixing-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PrefixingNormalizer", {
      enumerable: true,
      get: function() {
        return PrefixingNormalizer;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require_path());
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var PrefixingNormalizer = class {
      constructor(...prefixes) {
        this.prefix = _path.default.posix.join(...prefixes);
      }
      normalize(pathname) {
        return _path.default.posix.join(this.prefix, pathname);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/normalize-page-path.js
var require_normalize_page_path = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/normalize-page-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizePagePath", {
      enumerable: true,
      get: function() {
        return normalizePagePath;
      }
    });
    var _ensureleadingslash = require_ensure_leading_slash();
    var _utils = require_utils5();
    var _utils1 = require_utils3();
    function normalizePagePath(page) {
      const normalized = /^\/index(\/|$)/.test(page) && !(0, _utils.isDynamicRoute)(page) ? "/index" + page : page === "/" ? "/index" : (0, _ensureleadingslash.ensureLeadingSlash)(page);
      if (true) {
        const { posix } = require("path");
        const resolvedPage = posix.normalize(normalized);
        if (resolvedPage !== normalized) {
          throw new _utils1.NormalizeError("Requested and resolved page mismatch: " + normalized + " " + resolvedPage);
        }
      }
      return normalized;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/app-bundle-path-normalizer.js
var require_app_bundle_path_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/app-bundle-path-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      AppBundlePathNormalizer: function() {
        return AppBundlePathNormalizer;
      },
      DevAppBundlePathNormalizer: function() {
        return DevAppBundlePathNormalizer;
      }
    });
    var _normalizers = require_normalizers();
    var _prefixingnormalizer = require_prefixing_normalizer();
    var _normalizepagepath = require_normalize_page_path();
    var AppBundlePathNormalizer = class extends _prefixingnormalizer.PrefixingNormalizer {
      constructor() {
        super("app");
      }
      normalize(page) {
        return super.normalize((0, _normalizepagepath.normalizePagePath)(page));
      }
    };
    var DevAppBundlePathNormalizer = class extends _normalizers.Normalizers {
      constructor(pageNormalizer) {
        super([
          // This should normalize the filename to a page.
          pageNormalizer,
          // Normalize the app page to a pathname.
          new AppBundlePathNormalizer()
        ]);
      }
      normalize(filename) {
        return super.normalize(filename);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/app-filename-normalizer.js
var require_app_filename_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/app-filename-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AppFilenameNormalizer", {
      enumerable: true,
      get: function() {
        return AppFilenameNormalizer;
      }
    });
    var _constants = require_constants3();
    var _prefixingnormalizer = require_prefixing_normalizer();
    var AppFilenameNormalizer = class extends _prefixingnormalizer.PrefixingNormalizer {
      constructor(distDir) {
        super(distDir, _constants.SERVER_DIRECTORY);
      }
      normalize(manifestFilename) {
        return super.normalize(manifestFilename);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/page-types.js
var require_page_types = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/page-types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PAGE_TYPES", {
      enumerable: true,
      get: function() {
        return PAGE_TYPES;
      }
    });
    var PAGE_TYPES;
    (function(PAGE_TYPES2) {
      PAGE_TYPES2["PAGES"] = "pages";
      PAGE_TYPES2["ROOT"] = "root";
      PAGE_TYPES2["APP"] = "app";
    })(PAGE_TYPES || (PAGE_TYPES = {}));
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/remove-page-path-tail.js
var require_remove_page_path_tail = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/remove-page-path-tail.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removePagePathTail", {
      enumerable: true,
      get: function() {
        return removePagePathTail;
      }
    });
    var _normalizepathsep = require_normalize_path_sep();
    function removePagePathTail(pagePath, options) {
      pagePath = (0, _normalizepathsep.normalizePathSep)(pagePath).replace(new RegExp("\\.+(?:" + options.extensions.join("|") + ")$"), "");
      if (options.keepIndex !== true) {
        pagePath = pagePath.replace(/\/index$/, "") || "/";
      }
      return pagePath;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/metadata/is-metadata-route.js
var require_is_metadata_route = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/metadata/is-metadata-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      STATIC_METADATA_IMAGES: function() {
        return STATIC_METADATA_IMAGES;
      },
      getExtensionRegexString: function() {
        return getExtensionRegexString;
      },
      isMetadataRoute: function() {
        return isMetadataRoute;
      },
      isMetadataRouteFile: function() {
        return isMetadataRouteFile;
      },
      isStaticMetadataRoute: function() {
        return isStaticMetadataRoute;
      },
      isStaticMetadataRouteFile: function() {
        return isStaticMetadataRouteFile;
      }
    });
    var _normalizepathsep = require_normalize_path_sep();
    var STATIC_METADATA_IMAGES = {
      icon: {
        filename: "icon",
        extensions: [
          "ico",
          "jpg",
          "jpeg",
          "png",
          "svg"
        ]
      },
      apple: {
        filename: "apple-icon",
        extensions: [
          "jpg",
          "jpeg",
          "png"
        ]
      },
      favicon: {
        filename: "favicon",
        extensions: [
          "ico"
        ]
      },
      openGraph: {
        filename: "opengraph-image",
        extensions: [
          "jpg",
          "jpeg",
          "png",
          "gif"
        ]
      },
      twitter: {
        filename: "twitter-image",
        extensions: [
          "jpg",
          "jpeg",
          "png",
          "gif"
        ]
      }
    };
    var defaultExtensions = [
      "js",
      "jsx",
      "ts",
      "tsx"
    ];
    var getExtensionRegexString = (staticExtensions, dynamicExtensions) => {
      if (!dynamicExtensions) {
        return `\\.(?:${staticExtensions.join("|")})`;
      }
      return `(?:\\.(${staticExtensions.join("|")})|((\\[\\])?\\.(${dynamicExtensions.join("|")})))`;
    };
    function isMetadataRouteFile(appDirRelativePath, pageExtensions, withExtension) {
      const metadataRouteFilesRegex = [
        new RegExp(`^[\\\\/]robots${withExtension ? `${getExtensionRegexString(pageExtensions.concat("txt"), null)}$` : ""}`),
        new RegExp(`^[\\\\/]manifest${withExtension ? `${getExtensionRegexString(pageExtensions.concat("webmanifest", "json"), null)}$` : ""}`),
        new RegExp(`^[\\\\/]favicon\\.ico$`),
        new RegExp(`[\\\\/]sitemap${withExtension ? `${getExtensionRegexString([
          "xml"
        ], pageExtensions)}$` : ""}`),
        new RegExp(`[\\\\/]${STATIC_METADATA_IMAGES.icon.filename}\\d?${withExtension ? `${getExtensionRegexString(STATIC_METADATA_IMAGES.icon.extensions, pageExtensions)}$` : ""}`),
        new RegExp(`[\\\\/]${STATIC_METADATA_IMAGES.apple.filename}\\d?${withExtension ? `${getExtensionRegexString(STATIC_METADATA_IMAGES.apple.extensions, pageExtensions)}$` : ""}`),
        new RegExp(`[\\\\/]${STATIC_METADATA_IMAGES.openGraph.filename}\\d?${withExtension ? `${getExtensionRegexString(STATIC_METADATA_IMAGES.openGraph.extensions, pageExtensions)}$` : ""}`),
        new RegExp(`[\\\\/]${STATIC_METADATA_IMAGES.twitter.filename}\\d?${withExtension ? `${getExtensionRegexString(STATIC_METADATA_IMAGES.twitter.extensions, pageExtensions)}$` : ""}`)
      ];
      const normalizedAppDirRelativePath = (0, _normalizepathsep.normalizePathSep)(appDirRelativePath);
      return metadataRouteFilesRegex.some((r) => r.test(normalizedAppDirRelativePath));
    }
    function isStaticMetadataRouteFile(appDirRelativePath) {
      return isMetadataRouteFile(appDirRelativePath, [], true);
    }
    function isStaticMetadataRoute(page) {
      return page === "/robots" || page === "/manifest" || isStaticMetadataRouteFile(page);
    }
    function isMetadataRoute(route) {
      let page = route.replace(/^\/?app\//, "").replace(/\/route$/, "");
      if (page[0] !== "/")
        page = "/" + page;
      return !page.endsWith("/page") && isMetadataRouteFile(page, defaultExtensions, false);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/hash.js
var require_hash = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/hash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      djb2Hash: function() {
        return djb2Hash;
      },
      hexHash: function() {
        return hexHash;
      }
    });
    function djb2Hash(str) {
      let hash = 5381;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) + hash + char & 4294967295;
      }
      return hash >>> 0;
    }
    function hexHash(str) {
      return djb2Hash(str).toString(36).slice(0, 5);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/metadata/get-metadata-route.js
var require_get_metadata_route = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/metadata/get-metadata-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      fillMetadataSegment: function() {
        return fillMetadataSegment;
      },
      normalizeMetadataPageToRoute: function() {
        return normalizeMetadataPageToRoute;
      },
      normalizeMetadataRoute: function() {
        return normalizeMetadataRoute;
      }
    });
    var _ismetadataroute = require_is_metadata_route();
    var _path = /* @__PURE__ */ _interop_require_default(require_path());
    var _serverutils = require_server_utils();
    var _routeregex = require_route_regex();
    var _hash = require_hash();
    var _apppaths = require_app_paths();
    var _normalizepathsep = require_normalize_path_sep();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function getMetadataRouteSuffix(page) {
      let suffix = "";
      if (page.includes("(") && page.includes(")") || page.includes("@")) {
        suffix = (0, _hash.djb2Hash)(page).toString(36).slice(0, 6);
      }
      return suffix;
    }
    function fillMetadataSegment(segment, params, imageSegment) {
      const pathname = (0, _apppaths.normalizeAppPath)(segment);
      const routeRegex = (0, _routeregex.getNamedRouteRegex)(pathname, false);
      const route = (0, _serverutils.interpolateDynamicPath)(pathname, params, routeRegex);
      const suffix = getMetadataRouteSuffix(segment);
      const routeSuffix = suffix ? `-${suffix}` : "";
      const { name, ext } = _path.default.parse(imageSegment);
      return (0, _normalizepathsep.normalizePathSep)(_path.default.join(route, `${name}${routeSuffix}${ext}`));
    }
    function normalizeMetadataRoute(page) {
      if (!(0, _ismetadataroute.isMetadataRoute)(page)) {
        return page;
      }
      let route = page;
      let suffix = "";
      if (page === "/robots") {
        route += ".txt";
      } else if (page === "/manifest") {
        route += ".webmanifest";
      } else {
        const pathnamePrefix = page.slice(0, -(_path.default.basename(page).length + 1));
        suffix = getMetadataRouteSuffix(pathnamePrefix);
      }
      if (!route.endsWith("/route")) {
        const { dir, name: baseName, ext } = _path.default.parse(route);
        route = _path.default.posix.join(dir, `${baseName}${suffix ? `-${suffix}` : ""}${ext}`, "route");
      }
      return route;
    }
    function normalizeMetadataPageToRoute(page, isDynamic) {
      const isRoute = page.endsWith("/route");
      const routePagePath = isRoute ? page.slice(0, -"/route".length) : page;
      const metadataRouteExtension = routePagePath.endsWith("/sitemap") ? ".xml" : "";
      const mapped = isDynamic ? `${routePagePath}/[__metadata_id__]` : `${routePagePath}${metadataRouteExtension}`;
      return mapped + (isRoute ? "/route" : "");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/absolute-path-to-page.js
var require_absolute_path_to_page = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/page-path/absolute-path-to-page.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "absolutePathToPage", {
      enumerable: true,
      get: function() {
        return absolutePathToPage;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _ensureleadingslash = require_ensure_leading_slash();
    var _normalizepathsep = require_normalize_path_sep();
    var _path = /* @__PURE__ */ _interop_require_default._(require_path());
    var _removepagepathtail = require_remove_page_path_tail();
    var _getmetadataroute = require_get_metadata_route();
    function absolutePathToPage(pagePath, options) {
      const isAppDir = options.pagesType === "app";
      const page = (0, _removepagepathtail.removePagePathTail)((0, _normalizepathsep.normalizePathSep)((0, _ensureleadingslash.ensureLeadingSlash)(_path.default.relative(options.dir, pagePath))), {
        extensions: options.extensions,
        keepIndex: options.keepIndex
      });
      return isAppDir ? (0, _getmetadataroute.normalizeMetadataRoute)(page) : page;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/absolute-filename-normalizer.js
var require_absolute_filename_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/absolute-filename-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AbsoluteFilenameNormalizer", {
      enumerable: true,
      get: function() {
        return AbsoluteFilenameNormalizer;
      }
    });
    var _absolutepathtopage = require_absolute_path_to_page();
    var AbsoluteFilenameNormalizer = class {
      /**
      *
      * @param dir the directory for which the files should be made relative to
      * @param extensions the extensions the file could have
      * @param keepIndex when `true` the trailing `/index` is _not_ removed
      */
      constructor(dir, extensions, pagesType) {
        this.dir = dir;
        this.extensions = extensions;
        this.pagesType = pagesType;
      }
      normalize(filename) {
        return (0, _absolutepathtopage.absolutePathToPage)(filename, {
          extensions: this.extensions,
          keepIndex: false,
          dir: this.dir,
          pagesType: this.pagesType
        });
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/app-page-normalizer.js
var require_app_page_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/app-page-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DevAppPageNormalizer", {
      enumerable: true,
      get: function() {
        return DevAppPageNormalizer;
      }
    });
    var _pagetypes = require_page_types();
    var _absolutefilenamenormalizer = require_absolute_filename_normalizer();
    var DevAppPageNormalizer = class extends _absolutefilenamenormalizer.AbsoluteFilenameNormalizer {
      constructor(appDir, extensions) {
        super(appDir, extensions, _pagetypes.PAGE_TYPES.APP);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/wrap-normalizer-fn.js
var require_wrap_normalizer_fn = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/wrap-normalizer-fn.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "wrapNormalizerFn", {
      enumerable: true,
      get: function() {
        return wrapNormalizerFn;
      }
    });
    function wrapNormalizerFn(fn) {
      return {
        normalize: fn
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/underscore-normalizer.js
var require_underscore_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/underscore-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "UnderscoreNormalizer", {
      enumerable: true,
      get: function() {
        return UnderscoreNormalizer;
      }
    });
    var UnderscoreNormalizer = class {
      normalize(pathname) {
        return pathname.replace(/%5F/g, "_");
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/app-pathname-normalizer.js
var require_app_pathname_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/app-pathname-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      AppPathnameNormalizer: function() {
        return AppPathnameNormalizer;
      },
      DevAppPathnameNormalizer: function() {
        return DevAppPathnameNormalizer;
      }
    });
    var _apppaths = require_app_paths();
    var _normalizers = require_normalizers();
    var _wrapnormalizerfn = require_wrap_normalizer_fn();
    var _underscorenormalizer = require_underscore_normalizer();
    var AppPathnameNormalizer = class extends _normalizers.Normalizers {
      constructor() {
        super([
          // The pathname to match should have the trailing `/page` and other route
          // group information stripped from it.
          (0, _wrapnormalizerfn.wrapNormalizerFn)(_apppaths.normalizeAppPath),
          // The page should have the `%5F` characters replaced with `_` characters.
          new _underscorenormalizer.UnderscoreNormalizer()
        ]);
      }
      normalize(page) {
        return super.normalize(page);
      }
    };
    var DevAppPathnameNormalizer = class extends _normalizers.Normalizers {
      constructor(pageNormalizer) {
        super([
          // This should normalize the filename to a page.
          pageNormalizer,
          // Normalize the app page to a pathname.
          new AppPathnameNormalizer()
        ]);
      }
      normalize(filename) {
        return super.normalize(filename);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/index.js
var require_app = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/app/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      AppNormalizers: function() {
        return AppNormalizers;
      },
      DevAppNormalizers: function() {
        return DevAppNormalizers;
      }
    });
    var _appbundlepathnormalizer = require_app_bundle_path_normalizer();
    var _appfilenamenormalizer = require_app_filename_normalizer();
    var _apppagenormalizer = require_app_page_normalizer();
    var _apppathnamenormalizer = require_app_pathname_normalizer();
    var AppNormalizers = class {
      constructor(distDir) {
        this.filename = new _appfilenamenormalizer.AppFilenameNormalizer(distDir);
        this.pathname = new _apppathnamenormalizer.AppPathnameNormalizer();
        this.bundlePath = new _appbundlepathnormalizer.AppBundlePathNormalizer();
      }
    };
    var DevAppNormalizers = class {
      constructor(appDir, extensions) {
        this.page = new _apppagenormalizer.DevAppPageNormalizer(appDir, extensions);
        this.pathname = new _apppathnamenormalizer.DevAppPathnameNormalizer(this.page);
        this.bundlePath = new _appbundlepathnormalizer.DevAppBundlePathNormalizer(this.page);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/app-page-route-matcher.js
var require_app_page_route_matcher = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/app-page-route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AppPageRouteMatcher", {
      enumerable: true,
      get: function() {
        return AppPageRouteMatcher;
      }
    });
    var _routematcher = require_route_matcher2();
    var AppPageRouteMatcher = class extends _routematcher.RouteMatcher {
      get identity() {
        return `${this.definition.pathname}?__nextPage=${this.definition.page}`;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/helpers/cached-route-matcher-provider.js
var require_cached_route_matcher_provider = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/helpers/cached-route-matcher-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "CachedRouteMatcherProvider", {
      enumerable: true,
      get: function() {
        return CachedRouteMatcherProvider;
      }
    });
    var CachedRouteMatcherProvider = class {
      constructor(loader) {
        this.loader = loader;
        this.cached = [];
      }
      async matchers() {
        const data = await this.loader.load();
        if (!data)
          return [];
        if (this.data && this.loader.compare(this.data, data))
          return this.cached;
        this.data = data;
        const matchers = await this.transform(data);
        this.cached = matchers;
        return matchers;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/manifest-route-matcher-provider.js
var require_manifest_route_matcher_provider = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/manifest-route-matcher-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ManifestRouteMatcherProvider", {
      enumerable: true,
      get: function() {
        return ManifestRouteMatcherProvider;
      }
    });
    var _cachedroutematcherprovider = require_cached_route_matcher_provider();
    var ManifestRouteMatcherProvider = class extends _cachedroutematcherprovider.CachedRouteMatcherProvider {
      constructor(manifestName, manifestLoader) {
        super({
          load: async () => manifestLoader.load(manifestName),
          compare: (left, right) => left === right
        });
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/app-page-route-matcher-provider.js
var require_app_page_route_matcher_provider = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/app-page-route-matcher-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AppPageRouteMatcherProvider", {
      enumerable: true,
      get: function() {
        return AppPageRouteMatcherProvider;
      }
    });
    var _isapppageroute = require_is_app_page_route();
    var _constants = require_constants3();
    var _app = require_app();
    var _routekind = require_route_kind();
    var _apppageroutematcher = require_app_page_route_matcher();
    var _manifestroutematcherprovider = require_manifest_route_matcher_provider();
    var AppPageRouteMatcherProvider = class extends _manifestroutematcherprovider.ManifestRouteMatcherProvider {
      constructor(distDir, manifestLoader) {
        super(_constants.APP_PATHS_MANIFEST, manifestLoader);
        this.normalizers = new _app.AppNormalizers(distDir);
      }
      async transform(manifest) {
        const pages = Object.keys(manifest).filter((page) => (0, _isapppageroute.isAppPageRoute)(page));
        const allAppPaths = {};
        for (const page of pages) {
          const pathname = this.normalizers.pathname.normalize(page);
          if (pathname in allAppPaths)
            allAppPaths[pathname].push(page);
          else
            allAppPaths[pathname] = [
              page
            ];
        }
        const matchers = [];
        for (const [pathname, appPaths] of Object.entries(allAppPaths)) {
          const page = appPaths[0];
          const filename = this.normalizers.filename.normalize(manifest[page]);
          const bundlePath = this.normalizers.bundlePath.normalize(page);
          matchers.push(new _apppageroutematcher.AppPageRouteMatcher({
            kind: _routekind.RouteKind.APP_PAGE,
            pathname,
            page,
            bundlePath,
            filename,
            appPaths
          }));
        }
        return matchers;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/is-app-route-route.js
var require_is_app_route_route = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/is-app-route-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isAppRouteRoute", {
      enumerable: true,
      get: function() {
        return isAppRouteRoute;
      }
    });
    function isAppRouteRoute(route) {
      return route.endsWith("/route");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/app-route-route-matcher.js
var require_app_route_route_matcher = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/app-route-route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AppRouteRouteMatcher", {
      enumerable: true,
      get: function() {
        return AppRouteRouteMatcher;
      }
    });
    var _routematcher = require_route_matcher2();
    var AppRouteRouteMatcher = class extends _routematcher.RouteMatcher {
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/app-route-route-matcher-provider.js
var require_app_route_route_matcher_provider = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/app-route-route-matcher-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AppRouteRouteMatcherProvider", {
      enumerable: true,
      get: function() {
        return AppRouteRouteMatcherProvider;
      }
    });
    var _isapprouteroute = require_is_app_route_route();
    var _constants = require_constants3();
    var _routekind = require_route_kind();
    var _approuteroutematcher = require_app_route_route_matcher();
    var _manifestroutematcherprovider = require_manifest_route_matcher_provider();
    var _app = require_app();
    var AppRouteRouteMatcherProvider = class extends _manifestroutematcherprovider.ManifestRouteMatcherProvider {
      constructor(distDir, manifestLoader) {
        super(_constants.APP_PATHS_MANIFEST, manifestLoader);
        this.normalizers = new _app.AppNormalizers(distDir);
      }
      async transform(manifest) {
        const pages = Object.keys(manifest).filter((page) => (0, _isapprouteroute.isAppRouteRoute)(page));
        const matchers = [];
        for (const page of pages) {
          const filename = this.normalizers.filename.normalize(manifest[page]);
          const pathname = this.normalizers.pathname.normalize(page);
          const bundlePath = this.normalizers.bundlePath.normalize(page);
          matchers.push(new _approuteroutematcher.AppRouteRouteMatcher({
            kind: _routekind.RouteKind.APP_ROUTE,
            pathname,
            page,
            bundlePath,
            filename
          }));
        }
        return matchers;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/is-api-route.js
var require_is_api_route = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/is-api-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isAPIRoute", {
      enumerable: true,
      get: function() {
        return isAPIRoute;
      }
    });
    function isAPIRoute(value) {
      return value === "/api" || Boolean(value == null ? void 0 : value.startsWith("/api/"));
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/pages-api-route-matcher.js
var require_pages_api_route_matcher = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/pages-api-route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      PagesAPILocaleRouteMatcher: function() {
        return PagesAPILocaleRouteMatcher;
      },
      PagesAPIRouteMatcher: function() {
        return PagesAPIRouteMatcher;
      }
    });
    var _localeroutematcher = require_locale_route_matcher();
    var _routematcher = require_route_matcher2();
    var PagesAPIRouteMatcher = class extends _routematcher.RouteMatcher {
    };
    var PagesAPILocaleRouteMatcher = class extends _localeroutematcher.LocaleRouteMatcher {
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/pages-bundle-path-normalizer.js
var require_pages_bundle_path_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/pages-bundle-path-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      DevPagesBundlePathNormalizer: function() {
        return DevPagesBundlePathNormalizer;
      },
      PagesBundlePathNormalizer: function() {
        return PagesBundlePathNormalizer;
      }
    });
    var _normalizepagepath = require_normalize_page_path();
    var _normalizers = require_normalizers();
    var _prefixingnormalizer = require_prefixing_normalizer();
    var _wrapnormalizerfn = require_wrap_normalizer_fn();
    var PagesBundlePathNormalizer = class extends _normalizers.Normalizers {
      constructor() {
        super([
          // The bundle path should have the trailing `/index` stripped from
          // it.
          (0, _wrapnormalizerfn.wrapNormalizerFn)(_normalizepagepath.normalizePagePath),
          // The page should prefixed with `pages/`.
          new _prefixingnormalizer.PrefixingNormalizer("pages")
        ]);
      }
      normalize(page) {
        return super.normalize(page);
      }
    };
    var DevPagesBundlePathNormalizer = class extends _normalizers.Normalizers {
      constructor(pagesNormalizer) {
        super([
          // This should normalize the filename to a page.
          pagesNormalizer,
          // Normalize the app page to a pathname.
          new PagesBundlePathNormalizer()
        ]);
      }
      normalize(filename) {
        return super.normalize(filename);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/pages-filename-normalizer.js
var require_pages_filename_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/pages-filename-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PagesFilenameNormalizer", {
      enumerable: true,
      get: function() {
        return PagesFilenameNormalizer;
      }
    });
    var _constants = require_constants3();
    var _prefixingnormalizer = require_prefixing_normalizer();
    var PagesFilenameNormalizer = class extends _prefixingnormalizer.PrefixingNormalizer {
      constructor(distDir) {
        super(distDir, _constants.SERVER_DIRECTORY);
      }
      normalize(manifestFilename) {
        return super.normalize(manifestFilename);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/pages-page-normalizer.js
var require_pages_page_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/pages-page-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DevPagesPageNormalizer", {
      enumerable: true,
      get: function() {
        return DevPagesPageNormalizer;
      }
    });
    var _pagetypes = require_page_types();
    var _absolutefilenamenormalizer = require_absolute_filename_normalizer();
    var DevPagesPageNormalizer = class extends _absolutefilenamenormalizer.AbsoluteFilenameNormalizer {
      constructor(pagesDir, extensions) {
        super(pagesDir, extensions, _pagetypes.PAGE_TYPES.PAGES);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/pages-pathname-normalizer.js
var require_pages_pathname_normalizer = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/pages-pathname-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DevPagesPathnameNormalizer", {
      enumerable: true,
      get: function() {
        return DevPagesPathnameNormalizer;
      }
    });
    var _pagetypes = require_page_types();
    var _absolutefilenamenormalizer = require_absolute_filename_normalizer();
    var DevPagesPathnameNormalizer = class extends _absolutefilenamenormalizer.AbsoluteFilenameNormalizer {
      constructor(pagesDir, extensions) {
        super(pagesDir, extensions, _pagetypes.PAGE_TYPES.PAGES);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/index.js
var require_pages = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/built/pages/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      DevPagesNormalizers: function() {
        return DevPagesNormalizers;
      },
      PagesNormalizers: function() {
        return PagesNormalizers;
      }
    });
    var _pagesbundlepathnormalizer = require_pages_bundle_path_normalizer();
    var _pagesfilenamenormalizer = require_pages_filename_normalizer();
    var _pagespagenormalizer = require_pages_page_normalizer();
    var _pagespathnamenormalizer = require_pages_pathname_normalizer();
    var PagesNormalizers = class {
      constructor(distDir) {
        this.filename = new _pagesfilenamenormalizer.PagesFilenameNormalizer(distDir);
        this.bundlePath = new _pagesbundlepathnormalizer.PagesBundlePathNormalizer();
      }
    };
    var DevPagesNormalizers = class {
      constructor(pagesDir, extensions) {
        this.page = new _pagespagenormalizer.DevPagesPageNormalizer(pagesDir, extensions);
        this.pathname = new _pagespathnamenormalizer.DevPagesPathnameNormalizer(pagesDir, extensions);
        this.bundlePath = new _pagesbundlepathnormalizer.DevPagesBundlePathNormalizer(this.page);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/pages-api-route-matcher-provider.js
var require_pages_api_route_matcher_provider = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/pages-api-route-matcher-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PagesAPIRouteMatcherProvider", {
      enumerable: true,
      get: function() {
        return PagesAPIRouteMatcherProvider;
      }
    });
    var _isapiroute = require_is_api_route();
    var _constants = require_constants3();
    var _routekind = require_route_kind();
    var _pagesapiroutematcher = require_pages_api_route_matcher();
    var _manifestroutematcherprovider = require_manifest_route_matcher_provider();
    var _pages = require_pages();
    var PagesAPIRouteMatcherProvider = class extends _manifestroutematcherprovider.ManifestRouteMatcherProvider {
      constructor(distDir, manifestLoader, i18nProvider) {
        super(_constants.PAGES_MANIFEST, manifestLoader);
        this.i18nProvider = i18nProvider;
        this.normalizers = new _pages.PagesNormalizers(distDir);
      }
      async transform(manifest) {
        const pathnames = Object.keys(manifest).filter((pathname) => (0, _isapiroute.isAPIRoute)(pathname));
        const matchers = [];
        for (const page of pathnames) {
          if (this.i18nProvider) {
            const { detectedLocale, pathname } = this.i18nProvider.analyze(page);
            matchers.push(new _pagesapiroutematcher.PagesAPILocaleRouteMatcher({
              kind: _routekind.RouteKind.PAGES_API,
              pathname,
              page,
              bundlePath: this.normalizers.bundlePath.normalize(page),
              filename: this.normalizers.filename.normalize(manifest[page]),
              i18n: {
                locale: detectedLocale
              }
            }));
          } else {
            matchers.push(new _pagesapiroutematcher.PagesAPIRouteMatcher({
              kind: _routekind.RouteKind.PAGES_API,
              // In `pages/`, the page is the same as the pathname.
              pathname: page,
              page,
              bundlePath: this.normalizers.bundlePath.normalize(page),
              filename: this.normalizers.filename.normalize(manifest[page])
            }));
          }
        }
        return matchers;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/pages-route-matcher.js
var require_pages_route_matcher = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matchers/pages-route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      PagesLocaleRouteMatcher: function() {
        return PagesLocaleRouteMatcher;
      },
      PagesRouteMatcher: function() {
        return PagesRouteMatcher;
      }
    });
    var _localeroutematcher = require_locale_route_matcher();
    var _routematcher = require_route_matcher2();
    var PagesRouteMatcher = class extends _routematcher.RouteMatcher {
    };
    var PagesLocaleRouteMatcher = class extends _localeroutematcher.LocaleRouteMatcher {
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/pages-route-matcher-provider.js
var require_pages_route_matcher_provider = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/pages-route-matcher-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PagesRouteMatcherProvider", {
      enumerable: true,
      get: function() {
        return PagesRouteMatcherProvider;
      }
    });
    var _isapiroute = require_is_api_route();
    var _constants = require_constants3();
    var _routekind = require_route_kind();
    var _pagesroutematcher = require_pages_route_matcher();
    var _manifestroutematcherprovider = require_manifest_route_matcher_provider();
    var _pages = require_pages();
    var PagesRouteMatcherProvider = class extends _manifestroutematcherprovider.ManifestRouteMatcherProvider {
      constructor(distDir, manifestLoader, i18nProvider) {
        super(_constants.PAGES_MANIFEST, manifestLoader);
        this.i18nProvider = i18nProvider;
        this.normalizers = new _pages.PagesNormalizers(distDir);
      }
      async transform(manifest) {
        const pathnames = Object.keys(manifest).filter((pathname) => !(0, _isapiroute.isAPIRoute)(pathname)).filter((pathname) => {
          var _this_i18nProvider;
          const normalized = ((_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.analyze(pathname).pathname) ?? pathname;
          if (_constants.BLOCKED_PAGES.includes(normalized))
            return false;
          return true;
        });
        const matchers = [];
        for (const page of pathnames) {
          if (this.i18nProvider) {
            const { detectedLocale, pathname } = this.i18nProvider.analyze(page);
            matchers.push(new _pagesroutematcher.PagesLocaleRouteMatcher({
              kind: _routekind.RouteKind.PAGES,
              pathname,
              page,
              bundlePath: this.normalizers.bundlePath.normalize(page),
              filename: this.normalizers.filename.normalize(manifest[page]),
              i18n: {
                locale: detectedLocale
              }
            }));
          } else {
            matchers.push(new _pagesroutematcher.PagesRouteMatcher({
              kind: _routekind.RouteKind.PAGES,
              // In `pages/`, the page is the same as the pathname.
              pathname: page,
              page,
              bundlePath: this.normalizers.bundlePath.normalize(page),
              filename: this.normalizers.filename.normalize(manifest[page])
            }));
          }
        }
        return matchers;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/helpers/manifest-loaders/server-manifest-loader.js
var require_server_manifest_loader = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matcher-providers/helpers/manifest-loaders/server-manifest-loader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ServerManifestLoader", {
      enumerable: true,
      get: function() {
        return ServerManifestLoader;
      }
    });
    var ServerManifestLoader = class {
      constructor(getter) {
        this.getter = getter;
      }
      load(name) {
        return this.getter(name);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/i18n-provider.js
var require_i18n_provider = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/i18n-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "I18NProvider", {
      enumerable: true,
      get: function() {
        return I18NProvider;
      }
    });
    var I18NProvider = class {
      constructor(config) {
        var _config_domains;
        this.config = config;
        if (!config.locales.length) {
          throw new Error("Invariant: No locales provided");
        }
        this.lowerCaseLocales = config.locales.map((locale) => locale.toLowerCase());
        this.lowerCaseDomains = (_config_domains = config.domains) == null ? void 0 : _config_domains.map((domainLocale) => {
          var _domainLocale_locales;
          const domain = domainLocale.domain.toLowerCase();
          return {
            defaultLocale: domainLocale.defaultLocale.toLowerCase(),
            hostname: domain.split(":", 1)[0],
            domain,
            locales: (_domainLocale_locales = domainLocale.locales) == null ? void 0 : _domainLocale_locales.map((locale) => locale.toLowerCase()),
            http: domainLocale.http
          };
        });
      }
      /**
      * Detects the domain locale from the hostname and the detected locale if
      * provided.
      *
      * @param hostname The hostname to detect the domain locale from, this must be lowercased.
      * @param detectedLocale The detected locale to use if the hostname does not match.
      * @returns The domain locale if found, `undefined` otherwise.
      */
      detectDomainLocale(hostname, detectedLocale) {
        if (!hostname || !this.lowerCaseDomains || !this.config.domains)
          return;
        if (detectedLocale)
          detectedLocale = detectedLocale.toLowerCase();
        for (let i = 0; i < this.lowerCaseDomains.length; i++) {
          var _domainLocale_locales;
          const domainLocale = this.lowerCaseDomains[i];
          if (
            // We assume that the hostname is already lowercased.
            domainLocale.hostname === hostname || ((_domainLocale_locales = domainLocale.locales) == null ? void 0 : _domainLocale_locales.some((locale) => locale === detectedLocale))
          ) {
            return this.config.domains[i];
          }
        }
        return;
      }
      /**
      * Pulls the pre-computed locale and inference results from the query
      * object.
      *
      * @param pathname the pathname that could contain a locale prefix
      * @param query the query object
      * @returns the locale analysis result
      */
      fromQuery(pathname, query) {
        const detectedLocale = query.__nextLocale;
        if (detectedLocale) {
          const analysis = this.analyze(pathname);
          if (analysis.detectedLocale) {
            if (analysis.detectedLocale !== detectedLocale) {
              throw new Error(`Invariant: The detected locale does not match the locale in the query. Expected to find '${detectedLocale}' in '${pathname}' but found '${analysis.detectedLocale}'}`);
            }
            pathname = analysis.pathname;
          }
        }
        return {
          pathname,
          detectedLocale,
          inferredFromDefault: query.__nextInferredLocaleFromDefault === "1"
        };
      }
      /**
      * Validates that the locale is valid.
      *
      * @param locale The locale to validate.
      * @returns `true` if the locale is valid, `false` otherwise.
      */
      validate(locale) {
        return this.lowerCaseLocales.includes(locale.toLowerCase());
      }
      /**
      * Validates that the locales in the query object are valid.
      *
      * @param query The query object to validate.
      * @returns `true` if the locale is valid, `false` otherwise.
      */
      validateQuery(query) {
        if (query.__nextLocale && !this.validate(query.__nextLocale)) {
          return false;
        }
        if (query.__nextDefaultLocale && !this.validate(query.__nextDefaultLocale)) {
          return false;
        }
        return true;
      }
      /**
      * Analyzes the pathname for a locale and returns the pathname without it.
      *
      * @param pathname The pathname that could contain a locale prefix.
      * @param options The options to use when matching the locale.
      * @returns The matched locale and the pathname without the locale prefix
      *          (if any).
      */
      analyze(pathname, options = {}) {
        let detectedLocale = options.defaultLocale;
        let inferredFromDefault = typeof detectedLocale === "string";
        const segments = pathname.split("/", 2);
        if (!segments[1])
          return {
            detectedLocale,
            pathname,
            inferredFromDefault
          };
        const segment = segments[1].toLowerCase();
        const index = this.lowerCaseLocales.indexOf(segment);
        if (index < 0)
          return {
            detectedLocale,
            pathname,
            inferredFromDefault
          };
        detectedLocale = this.config.locales[index];
        inferredFromDefault = false;
        pathname = pathname.slice(detectedLocale.length + 1) || "/";
        return {
          detectedLocale,
          pathname,
          inferredFromDefault
        };
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/send-response.js
var require_send_response = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/send-response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "sendResponse", {
      enumerable: true,
      get: function() {
        return sendResponse;
      }
    });
    var _helpers = require_helpers();
    var _pipereadable = require_pipe_readable();
    var _utils = require_utils();
    async function sendResponse(req, res, response, waitUntil) {
      if ((0, _helpers.isNodeNextResponse)(res)) {
        var _response_headers;
        res.statusCode = response.status;
        res.statusMessage = response.statusText;
        const headersWithMultipleValuesAllowed = [
          "set-cookie",
          "www-authenticate",
          "proxy-authenticate"
        ];
        (_response_headers = response.headers) == null ? void 0 : _response_headers.forEach((value, name) => {
          if (name.toLowerCase() === "set-cookie") {
            for (const cookie of (0, _utils.splitCookiesString)(value)) {
              res.appendHeader(name, cookie);
            }
          } else {
            const isHeaderPresent = typeof res.getHeader(name) !== "undefined";
            if (headersWithMultipleValuesAllowed.includes(name.toLowerCase()) || !isHeaderPresent) {
              res.appendHeader(name, value);
            }
          }
        });
        const { originalResponse } = res;
        if (response.body && req.method !== "HEAD") {
          await (0, _pipereadable.pipeToNodeResponse)(response.body, originalResponse, waitUntil);
        } else {
          originalResponse.end();
        }
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/match-next-data-pathname.js
var require_match_next_data_pathname = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/match-next-data-pathname.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "matchNextDataPathname", {
      enumerable: true,
      get: function() {
        return matchNextDataPathname;
      }
    });
    var _pathmatch = require_path_match();
    var matcher = (0, _pathmatch.getPathMatch)("/_next/data/:path*");
    function matchNextDataPathname(pathname) {
      if (typeof pathname !== "string")
        return false;
      return matcher(pathname);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/get-route-from-asset-path.js
var require_get_route_from_asset_path = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/get-route-from-asset-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(
      exports,
      // "asset path" being its javascript file, data file, prerendered html,...
      "default",
      {
        enumerable: true,
        get: function() {
          return getRouteFromAssetPath;
        }
      }
    );
    var _isdynamic = require_is_dynamic();
    function getRouteFromAssetPath(assetPath, ext) {
      if (ext === void 0)
        ext = "";
      assetPath = assetPath.replace(/\\/g, "/");
      assetPath = ext && assetPath.endsWith(ext) ? assetPath.slice(0, -ext.length) : assetPath;
      if (assetPath.startsWith("/index/") && !(0, _isdynamic.isDynamicRoute)(assetPath)) {
        assetPath = assetPath.slice(6);
      } else if (assetPath === "/index") {
        assetPath = "/";
      }
      return assetPath;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/suffix.js
var require_suffix = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/suffix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "SuffixPathnameNormalizer", {
      enumerable: true,
      get: function() {
        return SuffixPathnameNormalizer;
      }
    });
    var SuffixPathnameNormalizer = class {
      constructor(suffix) {
        this.suffix = suffix;
      }
      match(pathname) {
        if (!pathname.endsWith(this.suffix))
          return false;
        return true;
      }
      normalize(pathname, matched) {
        if (!matched && !this.match(pathname))
          return pathname;
        return pathname.substring(0, pathname.length - this.suffix.length);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/rsc.js
var require_rsc = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/rsc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "RSCPathnameNormalizer", {
      enumerable: true,
      get: function() {
        return RSCPathnameNormalizer;
      }
    });
    var _constants = require_constants();
    var _suffix = require_suffix();
    var RSCPathnameNormalizer = class extends _suffix.SuffixPathnameNormalizer {
      constructor() {
        super(_constants.RSC_SUFFIX);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/prefix.js
var require_prefix = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PrefixPathnameNormalizer", {
      enumerable: true,
      get: function() {
        return PrefixPathnameNormalizer;
      }
    });
    var PrefixPathnameNormalizer = class {
      constructor(prefix) {
        this.prefix = prefix;
        if (prefix.endsWith("/")) {
          throw new Error(`PrefixPathnameNormalizer: prefix "${prefix}" should not end with a slash`);
        }
      }
      match(pathname) {
        if (pathname !== this.prefix && !pathname.startsWith(this.prefix + "/")) {
          return false;
        }
        return true;
      }
      normalize(pathname, matched) {
        if (!matched && !this.match(pathname))
          return pathname;
        if (pathname.length === this.prefix.length) {
          return "/";
        }
        return pathname.substring(this.prefix.length);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/postponed.js
var require_postponed = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/postponed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PostponedPathnameNormalizer", {
      enumerable: true,
      get: function() {
        return PostponedPathnameNormalizer;
      }
    });
    var _denormalizepagepath = require_denormalize_page_path();
    var _prefix = require_prefix();
    var prefix = "/_next/postponed/resume";
    var PostponedPathnameNormalizer = class extends _prefix.PrefixPathnameNormalizer {
      constructor() {
        super(prefix);
      }
      normalize(pathname, matched) {
        if (!matched && !this.match(pathname))
          return pathname;
        pathname = super.normalize(pathname, true);
        return (0, _denormalizepagepath.denormalizePagePath)(pathname);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/strip-flight-headers.js
var require_strip_flight_headers = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/strip-flight-headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "stripFlightHeaders", {
      enumerable: true,
      get: function() {
        return stripFlightHeaders;
      }
    });
    var _approuterheaders = require_app_router_headers();
    function stripFlightHeaders(headers) {
      for (const header of _approuterheaders.FLIGHT_HEADERS) {
        delete headers[header.toLowerCase()];
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-modules/checks.js
var require_checks = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-modules/checks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      isAppPageRouteModule: function() {
        return isAppPageRouteModule;
      },
      isAppRouteRouteModule: function() {
        return isAppRouteRouteModule;
      },
      isPagesAPIRouteModule: function() {
        return isPagesAPIRouteModule;
      },
      isPagesRouteModule: function() {
        return isPagesRouteModule;
      }
    });
    var _routekind = require_route_kind();
    function isAppRouteRouteModule(routeModule) {
      return routeModule.definition.kind === _routekind.RouteKind.APP_ROUTE;
    }
    function isAppPageRouteModule(routeModule) {
      return routeModule.definition.kind === _routekind.RouteKind.APP_PAGE;
    }
    function isPagesRouteModule(routeModule) {
      return routeModule.definition.kind === _routekind.RouteKind.PAGES;
    }
    function isPagesAPIRouteModule(routeModule) {
      return routeModule.definition.kind === _routekind.RouteKind.PAGES_API;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/prefetch-rsc.js
var require_prefetch_rsc = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/prefetch-rsc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PrefetchRSCPathnameNormalizer", {
      enumerable: true,
      get: function() {
        return PrefetchRSCPathnameNormalizer;
      }
    });
    var _constants = require_constants();
    var _suffix = require_suffix();
    var PrefetchRSCPathnameNormalizer = class extends _suffix.SuffixPathnameNormalizer {
      constructor() {
        super(_constants.RSC_PREFETCH_SUFFIX);
      }
      match(pathname) {
        if (pathname === "/__index" + _constants.RSC_PREFETCH_SUFFIX) {
          return true;
        }
        return super.match(pathname);
      }
      normalize(pathname, matched) {
        if (pathname === "/__index" + _constants.RSC_PREFETCH_SUFFIX) {
          return "/";
        }
        return super.normalize(pathname, matched);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/next-data.js
var require_next_data = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/normalizers/request/next-data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NextDataPathnameNormalizer", {
      enumerable: true,
      get: function() {
        return NextDataPathnameNormalizer;
      }
    });
    var _denormalizepagepath = require_denormalize_page_path();
    var _prefix = require_prefix();
    var _suffix = require_suffix();
    var NextDataPathnameNormalizer = class {
      constructor(buildID) {
        this.suffix = new _suffix.SuffixPathnameNormalizer(".json");
        if (!buildID) {
          throw new Error("Invariant: buildID is required");
        }
        this.prefix = new _prefix.PrefixPathnameNormalizer(`/_next/data/${buildID}`);
      }
      match(pathname) {
        return this.prefix.match(pathname) && this.suffix.match(pathname);
      }
      normalize(pathname, matched) {
        if (!matched && !this.match(pathname))
          return pathname;
        pathname = this.prefix.normalize(pathname, true);
        pathname = this.suffix.normalize(pathname, true);
        return (0, _denormalizepagepath.denormalizePagePath)(pathname);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/server-action-request-meta.js
var require_server_action_request_meta = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/server-action-request-meta.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getIsServerAction: function() {
        return getIsServerAction;
      },
      getServerActionRequestMetadata: function() {
        return getServerActionRequestMetadata;
      }
    });
    var _approuterheaders = require_app_router_headers();
    function getServerActionRequestMetadata(req) {
      let actionId;
      let contentType;
      if (req.headers instanceof Headers) {
        actionId = req.headers.get(_approuterheaders.ACTION_HEADER.toLowerCase()) ?? null;
        contentType = req.headers.get("content-type");
      } else {
        actionId = req.headers[_approuterheaders.ACTION_HEADER.toLowerCase()] ?? null;
        contentType = req.headers["content-type"] ?? null;
      }
      const isURLEncodedAction = Boolean(req.method === "POST" && contentType === "application/x-www-form-urlencoded");
      const isMultipartAction = Boolean(req.method === "POST" && (contentType == null ? void 0 : contentType.startsWith("multipart/form-data")));
      const isFetchAction = Boolean(actionId !== void 0 && typeof actionId === "string" && req.method === "POST");
      const isServerAction = Boolean(isFetchAction || isURLEncodedAction || isMultipartAction);
      return {
        actionId,
        isURLEncodedAction,
        isMultipartAction,
        isFetchAction,
        isServerAction
      };
    }
    function getIsServerAction(req) {
      return getServerActionRequestMetadata(req).isServerAction;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/to-route.js
var require_to_route = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/to-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "toRoute", {
      enumerable: true,
      get: function() {
        return toRoute;
      }
    });
    function toRoute(pathname) {
      return pathname.replace(/(?:\/index)?\/?$/, "") || "/";
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/patch-set-header.js
var require_patch_set_header = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/patch-set-header.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "patchSetHeaderWithCookieSupport", {
      enumerable: true,
      get: function() {
        return patchSetHeaderWithCookieSupport;
      }
    });
    var _requestmeta = require_request_meta();
    function patchSetHeaderWithCookieSupport(req, res) {
      const setHeader = res.setHeader.bind(res);
      res.setHeader = (name, value) => {
        if ("headersSent" in res && res.headersSent) {
          return res;
        }
        if (name.toLowerCase() === "set-cookie") {
          const middlewareValue = (0, _requestmeta.getRequestMeta)(req, "middlewareCookie");
          if (!middlewareValue || !Array.isArray(value) || !value.every((item, idx) => item === middlewareValue[idx])) {
            value = [
              // TODO: (wyattjoh) find out why this is called multiple times resulting in duplicate cookies being added
              .../* @__PURE__ */ new Set([
                ...middlewareValue || [],
                ...typeof value === "string" ? [
                  value
                ] : Array.isArray(value) ? value : []
              ])
            ];
          }
        }
        return setHeader(name, value);
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/experimental/ppr.js
var require_ppr = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/experimental/ppr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      checkIsAppPPREnabled: function() {
        return checkIsAppPPREnabled;
      },
      checkIsRoutePPREnabled: function() {
        return checkIsRoutePPREnabled;
      }
    });
    function checkIsAppPPREnabled(config) {
      if (typeof config === "undefined")
        return false;
      if (typeof config === "boolean")
        return config;
      if (config === "incremental")
        return true;
      return false;
    }
    function checkIsRoutePPREnabled(config, appConfig) {
      if (typeof config === "undefined")
        return false;
      if (typeof config === "boolean")
        return config;
      if (config === "incremental" && appConfig.experimental_ppr === true) {
        return true;
      }
      return false;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/after/builtin-request-context.js
var require_builtin_request_context = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/after/builtin-request-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      createLocalRequestContext: function() {
        return createLocalRequestContext;
      },
      getBuiltinRequestContext: function() {
        return getBuiltinRequestContext;
      }
    });
    var _asynclocalstorage = require_async_local_storage();
    function getBuiltinRequestContext() {
      const _globalThis = globalThis;
      const ctx = _globalThis[NEXT_REQUEST_CONTEXT_SYMBOL] ?? _globalThis[VERCEL_REQUEST_CONTEXT_SYMBOL];
      return ctx == null ? void 0 : ctx.get();
    }
    var NEXT_REQUEST_CONTEXT_SYMBOL = Symbol.for("@next/request-context");
    var VERCEL_REQUEST_CONTEXT_SYMBOL = Symbol.for("@vercel/request-context");
    function createLocalRequestContext() {
      const storage = (0, _asynclocalstorage.createAsyncLocalStorage)();
      return {
        get: () => storage.getStore(),
        run: (value, callback) => storage.run(value, callback)
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/fetch-event.js
var require_fetch_event = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/fetch-event.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      NextFetchEvent: function() {
        return NextFetchEvent;
      },
      getWaitUntilPromiseFromEvent: function() {
        return getWaitUntilPromiseFromEvent;
      }
    });
    var _error = require_error();
    var responseSymbol = Symbol("response");
    var passThroughSymbol = Symbol("passThrough");
    var waitUntilSymbol = Symbol("waitUntil");
    var FetchEvent = class {
      constructor(_request, waitUntil) {
        this[passThroughSymbol] = false;
        this[waitUntilSymbol] = waitUntil ? {
          kind: "external",
          function: waitUntil
        } : {
          kind: "internal",
          promises: []
        };
      }
      // TODO: is this dead code? NextFetchEvent never lets this get called
      respondWith(response) {
        if (!this[responseSymbol]) {
          this[responseSymbol] = Promise.resolve(response);
        }
      }
      // TODO: is this dead code? passThroughSymbol is unused
      passThroughOnException() {
        this[passThroughSymbol] = true;
      }
      waitUntil(promise) {
        if (this[waitUntilSymbol].kind === "external") {
          const waitUntil = this[waitUntilSymbol].function;
          return waitUntil(promise);
        } else {
          this[waitUntilSymbol].promises.push(promise);
        }
      }
    };
    function getWaitUntilPromiseFromEvent(event) {
      return event[waitUntilSymbol].kind === "internal" ? Promise.all(event[waitUntilSymbol].promises).then(() => {
      }) : void 0;
    }
    var NextFetchEvent = class extends FetchEvent {
      constructor(params) {
        var _params_context;
        super(params.request, (_params_context = params.context) == null ? void 0 : _params_context.waitUntil);
        this.sourcePage = params.page;
      }
      /**
      * @deprecated The `request` is now the first parameter and the API is now async.
      *
      * Read more: https://nextjs.org/docs/messages/middleware-new-signature
      */
      get request() {
        throw new _error.PageSignatureError({
          page: this.sourcePage
        });
      }
      /**
      * @deprecated Using `respondWith` is no longer needed.
      *
      * Read more: https://nextjs.org/docs/messages/middleware-new-signature
      */
      respondWith() {
        throw new _error.PageSignatureError({
          page: this.sourcePage
        });
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/response.js
var require_response = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/response.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NextResponse", {
      enumerable: true,
      get: function() {
        return NextResponse;
      }
    });
    var _cookies = require_cookies2();
    var _nexturl = require_next_url();
    var _utils = require_utils();
    var _reflect = require_reflect();
    var _cookies1 = require_cookies2();
    var INTERNALS = Symbol("internal response");
    var REDIRECTS = /* @__PURE__ */ new Set([
      301,
      302,
      303,
      307,
      308
    ]);
    function handleMiddlewareField(init, headers) {
      var _init_request;
      if (init == null ? void 0 : (_init_request = init.request) == null ? void 0 : _init_request.headers) {
        if (!(init.request.headers instanceof Headers)) {
          throw new Error("request.headers must be an instance of Headers");
        }
        const keys = [];
        for (const [key, value] of init.request.headers) {
          headers.set("x-middleware-request-" + key, value);
          keys.push(key);
        }
        headers.set("x-middleware-override-headers", keys.join(","));
      }
    }
    var NextResponse = class extends Response {
      constructor(body, init = {}) {
        super(body, init);
        const headers = this.headers;
        const cookies = new _cookies1.ResponseCookies(headers);
        const cookiesProxy = new Proxy(cookies, {
          get(target, prop, receiver) {
            switch (prop) {
              case "delete":
              case "set": {
                return (...args) => {
                  const result = Reflect.apply(target[prop], target, args);
                  const newHeaders = new Headers(headers);
                  if (result instanceof _cookies1.ResponseCookies) {
                    headers.set("x-middleware-set-cookie", result.getAll().map((cookie) => (0, _cookies.stringifyCookie)(cookie)).join(","));
                  }
                  handleMiddlewareField(init, newHeaders);
                  return result;
                };
              }
              default:
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
          }
        });
        this[INTERNALS] = {
          cookies: cookiesProxy,
          url: init.url ? new _nexturl.NextURL(init.url, {
            headers: (0, _utils.toNodeOutgoingHttpHeaders)(headers),
            nextConfig: init.nextConfig
          }) : void 0
        };
      }
      [Symbol.for("edge-runtime.inspect.custom")]() {
        return {
          cookies: this.cookies,
          url: this.url,
          // rest of props come from Response
          body: this.body,
          bodyUsed: this.bodyUsed,
          headers: Object.fromEntries(this.headers),
          ok: this.ok,
          redirected: this.redirected,
          status: this.status,
          statusText: this.statusText,
          type: this.type
        };
      }
      get cookies() {
        return this[INTERNALS].cookies;
      }
      static json(body, init) {
        const response = Response.json(body, init);
        return new NextResponse(response.body, response);
      }
      static redirect(url, init) {
        const status = typeof init === "number" ? init : (init == null ? void 0 : init.status) ?? 307;
        if (!REDIRECTS.has(status)) {
          throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
        }
        const initObj = typeof init === "object" ? init : {};
        const headers = new Headers(initObj == null ? void 0 : initObj.headers);
        headers.set("Location", (0, _utils.validateURL)(url));
        return new NextResponse(null, {
          ...initObj,
          headers,
          status
        });
      }
      static rewrite(destination, init) {
        const headers = new Headers(init == null ? void 0 : init.headers);
        headers.set("x-middleware-rewrite", (0, _utils.validateURL)(destination));
        handleMiddlewareField(init, headers);
        return new NextResponse(null, {
          ...init,
          headers
        });
      }
      static next(init) {
        const headers = new Headers(init == null ? void 0 : init.headers);
        headers.set("x-middleware-next", "1");
        handleMiddlewareField(init, headers);
        return new NextResponse(null, {
          ...init,
          headers
        });
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/relativize-url.js
var require_relativize_url = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/relativize-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "relativizeURL", {
      enumerable: true,
      get: function() {
        return relativizeURL;
      }
    });
    function relativizeURL(url, base) {
      const baseURL = typeof base === "string" ? new URL(base) : base;
      const relative = new URL(url, base);
      const origin = baseURL.protocol + "//" + baseURL.host;
      return relative.protocol + "//" + relative.host === origin ? relative.toString().replace(origin, "") : relative.toString();
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/internal-utils.js
var require_internal_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/internal-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      stripInternalQueries: function() {
        return stripInternalQueries;
      },
      stripInternalSearchParams: function() {
        return stripInternalSearchParams;
      }
    });
    var _approuterheaders = require_app_router_headers();
    var INTERNAL_QUERY_NAMES = [
      "__nextFallback",
      "__nextLocale",
      "__nextInferredLocaleFromDefault",
      "__nextDefaultLocale",
      "__nextIsNotFound",
      _approuterheaders.NEXT_RSC_UNION_QUERY
    ];
    var EDGE_EXTENDED_INTERNAL_QUERY_NAMES = [
      "__nextDataReq"
    ];
    function stripInternalQueries(query) {
      for (const name of INTERNAL_QUERY_NAMES) {
        delete query[name];
      }
    }
    function stripInternalSearchParams(url, isEdge) {
      const isStringUrl = typeof url === "string";
      const instance = isStringUrl ? new URL(url) : url;
      for (const name of INTERNAL_QUERY_NAMES) {
        instance.searchParams.delete(name);
      }
      if (isEdge) {
        for (const name of EDGE_EXTENDED_INTERNAL_QUERY_NAMES) {
          instance.searchParams.delete(name);
        }
      }
      return isStringUrl ? instance.toString() : instance;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/globals.js
var require_globals = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/globals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      edgeInstrumentationOnRequestError: function() {
        return edgeInstrumentationOnRequestError;
      },
      ensureInstrumentationRegistered: function() {
        return ensureInstrumentationRegistered;
      },
      getEdgeInstrumentationModule: function() {
        return getEdgeInstrumentationModule;
      }
    });
    async function getEdgeInstrumentationModule() {
      const instrumentation = "_ENTRIES" in globalThis && _ENTRIES.middleware_instrumentation && await _ENTRIES.middleware_instrumentation;
      return instrumentation;
    }
    var instrumentationModulePromise = null;
    async function registerInstrumentation() {
      if (process.env.NEXT_PHASE === "phase-production-build")
        return;
      if (!instrumentationModulePromise) {
        instrumentationModulePromise = getEdgeInstrumentationModule();
      }
      const instrumentation = await instrumentationModulePromise;
      if (instrumentation == null ? void 0 : instrumentation.register) {
        try {
          await instrumentation.register();
        } catch (err) {
          err.message = `An error occurred while loading instrumentation hook: ${err.message}`;
          throw err;
        }
      }
    }
    async function edgeInstrumentationOnRequestError(...args) {
      const instrumentation = await getEdgeInstrumentationModule();
      try {
        var _instrumentation_onRequestError;
        await (instrumentation == null ? void 0 : (_instrumentation_onRequestError = instrumentation.onRequestError) == null ? void 0 : _instrumentation_onRequestError.call(instrumentation, ...args));
      } catch (err) {
        console.error("Error in instrumentation.onRequestError:", err);
      }
    }
    var registerInstrumentationPromise = null;
    function ensureInstrumentationRegistered() {
      if (!registerInstrumentationPromise) {
        registerInstrumentationPromise = registerInstrumentation();
      }
      return registerInstrumentationPromise;
    }
    function getUnsupportedModuleErrorMessage(module1) {
      return `The edge runtime does not support Node.js '${module1}' module.
Learn More: https://nextjs.org/docs/messages/node-module-in-edge-runtime`;
    }
    function __import_unsupported(moduleName) {
      const proxy = new Proxy(function() {
      }, {
        get(_obj, prop) {
          if (prop === "then") {
            return {};
          }
          throw new Error(getUnsupportedModuleErrorMessage(moduleName));
        },
        construct() {
          throw new Error(getUnsupportedModuleErrorMessage(moduleName));
        },
        apply(_target, _this, args) {
          if (typeof args[0] === "function") {
            return args[0](proxy);
          }
          throw new Error(getUnsupportedModuleErrorMessage(moduleName));
        }
      });
      return new Proxy({}, {
        get: () => proxy
      });
    }
    function enhanceGlobals() {
      if (process !== global.process) {
        process.env = global.process.env;
        global.process = process;
      }
      Object.defineProperty(globalThis, "__import_unsupported", {
        value: __import_unsupported,
        enumerable: false,
        configurable: false
      });
      void ensureInstrumentationRegistered();
    }
    enhanceGlobals();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js
var require_request_cookies = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/spec-extension/adapters/request-cookies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      MutableRequestCookiesAdapter: function() {
        return MutableRequestCookiesAdapter;
      },
      ReadonlyRequestCookiesError: function() {
        return ReadonlyRequestCookiesError;
      },
      RequestCookiesAdapter: function() {
        return RequestCookiesAdapter;
      },
      appendMutableCookies: function() {
        return appendMutableCookies;
      },
      areCookiesMutableInCurrentPhase: function() {
        return areCookiesMutableInCurrentPhase;
      },
      getModifiedCookieValues: function() {
        return getModifiedCookieValues;
      },
      responseCookiesToRequestCookies: function() {
        return responseCookiesToRequestCookies;
      },
      wrapWithMutableAccessCheck: function() {
        return wrapWithMutableAccessCheck;
      }
    });
    var _cookies = require_cookies2();
    var _reflect = require_reflect();
    var _workasyncstorageexternal = require_work_async_storage_external();
    var _workunitasyncstorageexternal = require_work_unit_async_storage_external();
    var ReadonlyRequestCookiesError = class extends Error {
      constructor() {
        super("Cookies can only be modified in a Server Action or Route Handler. Read more: https://nextjs.org/docs/app/api-reference/functions/cookies#cookiessetname-value-options");
      }
      static callable() {
        throw new ReadonlyRequestCookiesError();
      }
    };
    var RequestCookiesAdapter = class {
      static seal(cookies) {
        return new Proxy(cookies, {
          get(target, prop, receiver) {
            switch (prop) {
              case "clear":
              case "delete":
              case "set":
                return ReadonlyRequestCookiesError.callable;
              default:
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
          }
        });
      }
    };
    var SYMBOL_MODIFY_COOKIE_VALUES = Symbol.for("next.mutated.cookies");
    function getModifiedCookieValues(cookies) {
      const modified = cookies[SYMBOL_MODIFY_COOKIE_VALUES];
      if (!modified || !Array.isArray(modified) || modified.length === 0) {
        return [];
      }
      return modified;
    }
    function appendMutableCookies(headers, mutableCookies) {
      const modifiedCookieValues = getModifiedCookieValues(mutableCookies);
      if (modifiedCookieValues.length === 0) {
        return false;
      }
      const resCookies = new _cookies.ResponseCookies(headers);
      const returnedCookies = resCookies.getAll();
      for (const cookie of modifiedCookieValues) {
        resCookies.set(cookie);
      }
      for (const cookie of returnedCookies) {
        resCookies.set(cookie);
      }
      return true;
    }
    var MutableRequestCookiesAdapter = class {
      static wrap(cookies, onUpdateCookies) {
        const responseCookies = new _cookies.ResponseCookies(new Headers());
        for (const cookie of cookies.getAll()) {
          responseCookies.set(cookie);
        }
        let modifiedValues = [];
        const modifiedCookies = /* @__PURE__ */ new Set();
        const updateResponseCookies = () => {
          const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
          if (workStore) {
            workStore.pathWasRevalidated = true;
          }
          const allCookies = responseCookies.getAll();
          modifiedValues = allCookies.filter((c) => modifiedCookies.has(c.name));
          if (onUpdateCookies) {
            const serializedCookies = [];
            for (const cookie of modifiedValues) {
              const tempCookies = new _cookies.ResponseCookies(new Headers());
              tempCookies.set(cookie);
              serializedCookies.push(tempCookies.toString());
            }
            onUpdateCookies(serializedCookies);
          }
        };
        const wrappedCookies = new Proxy(responseCookies, {
          get(target, prop, receiver) {
            switch (prop) {
              case SYMBOL_MODIFY_COOKIE_VALUES:
                return modifiedValues;
              case "delete":
                return function(...args) {
                  modifiedCookies.add(typeof args[0] === "string" ? args[0] : args[0].name);
                  try {
                    target.delete(...args);
                    return wrappedCookies;
                  } finally {
                    updateResponseCookies();
                  }
                };
              case "set":
                return function(...args) {
                  modifiedCookies.add(typeof args[0] === "string" ? args[0] : args[0].name);
                  try {
                    target.set(...args);
                    return wrappedCookies;
                  } finally {
                    updateResponseCookies();
                  }
                };
              default:
                return _reflect.ReflectAdapter.get(target, prop, receiver);
            }
          }
        });
        return wrappedCookies;
      }
    };
    function wrapWithMutableAccessCheck(responseCookies) {
      const wrappedCookies = new Proxy(responseCookies, {
        get(target, prop, receiver) {
          switch (prop) {
            case "delete":
              return function(...args) {
                ensureCookiesAreStillMutable("cookies().delete");
                target.delete(...args);
                return wrappedCookies;
              };
            case "set":
              return function(...args) {
                ensureCookiesAreStillMutable("cookies().set");
                target.set(...args);
                return wrappedCookies;
              };
            default:
              return _reflect.ReflectAdapter.get(target, prop, receiver);
          }
        }
      });
      return wrappedCookies;
    }
    function areCookiesMutableInCurrentPhase(requestStore) {
      return requestStore.phase === "action";
    }
    function ensureCookiesAreStillMutable(callingExpression) {
      const requestStore = (0, _workunitasyncstorageexternal.getExpectedRequestStore)(callingExpression);
      if (!areCookiesMutableInCurrentPhase(requestStore)) {
        throw new ReadonlyRequestCookiesError();
      }
    }
    function responseCookiesToRequestCookies(responseCookies) {
      const requestCookies = new _cookies.RequestCookies(new Headers());
      for (const cookie of responseCookies.getAll()) {
        requestCookies.set(cookie);
      }
      return requestCookies;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/async-storage/draft-mode-provider.js
var require_draft_mode_provider = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/async-storage/draft-mode-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "DraftModeProvider", {
      enumerable: true,
      get: function() {
        return DraftModeProvider;
      }
    });
    var _apiutils = require_api_utils();
    var DraftModeProvider = class {
      constructor(previewProps, req, cookies, mutableCookies) {
        var _cookies_get;
        const isOnDemandRevalidate = previewProps && (0, _apiutils.checkIsOnDemandRevalidate)(req, previewProps).isOnDemandRevalidate;
        const cookieValue = (_cookies_get = cookies.get(_apiutils.COOKIE_NAME_PRERENDER_BYPASS)) == null ? void 0 : _cookies_get.value;
        this.isEnabled = Boolean(!isOnDemandRevalidate && cookieValue && previewProps && (cookieValue === previewProps.previewModeId || // In dev mode, the cookie can be actual hash value preview id but the preview props can still be `development-id`.
        false));
        this._previewModeId = previewProps == null ? void 0 : previewProps.previewModeId;
        this._mutableCookies = mutableCookies;
      }
      enable() {
        if (!this._previewModeId) {
          throw new Error("Invariant: previewProps missing previewModeId this should never happen");
        }
        this._mutableCookies.set({
          name: _apiutils.COOKIE_NAME_PRERENDER_BYPASS,
          value: this._previewModeId,
          httpOnly: true,
          sameSite: true ? "none" : "lax",
          secure: true,
          path: "/"
        });
      }
      disable() {
        this._mutableCookies.set({
          name: _apiutils.COOKIE_NAME_PRERENDER_BYPASS,
          value: "",
          httpOnly: true,
          sameSite: true ? "none" : "lax",
          secure: true,
          path: "/",
          expires: /* @__PURE__ */ new Date(0)
        });
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/async-storage/request-store.js
var require_request_store = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/async-storage/request-store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      createRequestStoreForAPI: function() {
        return createRequestStoreForAPI;
      },
      createRequestStoreForRender: function() {
        return createRequestStoreForRender;
      },
      synchronizeMutableCookies: function() {
        return synchronizeMutableCookies;
      }
    });
    var _approuterheaders = require_app_router_headers();
    var _headers = require_headers();
    var _requestcookies = require_request_cookies();
    var _cookies = require_cookies2();
    var _draftmodeprovider = require_draft_mode_provider();
    var _utils = require_utils();
    function getHeaders(headers) {
      const cleaned = _headers.HeadersAdapter.from(headers);
      for (const header of _approuterheaders.FLIGHT_HEADERS) {
        cleaned.delete(header.toLowerCase());
      }
      return _headers.HeadersAdapter.seal(cleaned);
    }
    function getMutableCookies(headers, onUpdateCookies) {
      const cookies = new _cookies.RequestCookies(_headers.HeadersAdapter.from(headers));
      return _requestcookies.MutableRequestCookiesAdapter.wrap(cookies, onUpdateCookies);
    }
    function mergeMiddlewareCookies(req, existingCookies) {
      if ("x-middleware-set-cookie" in req.headers && typeof req.headers["x-middleware-set-cookie"] === "string") {
        const setCookieValue = req.headers["x-middleware-set-cookie"];
        const responseHeaders = new Headers();
        for (const cookie of (0, _utils.splitCookiesString)(setCookieValue)) {
          responseHeaders.append("set-cookie", cookie);
        }
        const responseCookies = new _cookies.ResponseCookies(responseHeaders);
        for (const cookie of responseCookies.getAll()) {
          existingCookies.set(cookie);
        }
      }
    }
    function createRequestStoreForRender(req, res, url, implicitTags, onUpdateCookies, previewProps, isHmrRefresh, serverComponentsHmrCache) {
      return createRequestStoreImpl(
        // Pages start in render phase by default
        "render",
        req,
        res,
        url,
        implicitTags,
        onUpdateCookies,
        previewProps,
        isHmrRefresh,
        serverComponentsHmrCache
      );
    }
    function createRequestStoreForAPI(req, url, implicitTags, onUpdateCookies, previewProps) {
      return createRequestStoreImpl(
        // API routes start in action phase by default
        "action",
        req,
        void 0,
        url,
        implicitTags,
        onUpdateCookies,
        previewProps,
        false,
        void 0
      );
    }
    function createRequestStoreImpl(phase, req, res, url, implicitTags, onUpdateCookies, previewProps, isHmrRefresh, serverComponentsHmrCache) {
      function defaultOnUpdateCookies(cookies) {
        if (res) {
          res.setHeader("Set-Cookie", cookies);
        }
      }
      const cache = {};
      return {
        type: "request",
        phase,
        implicitTags: implicitTags ?? [],
        // Rather than just using the whole `url` here, we pull the parts we want
        // to ensure we don't use parts of the URL that we shouldn't. This also
        // lets us avoid requiring an empty string for `search` in the type.
        url: {
          pathname: url.pathname,
          search: url.search ?? ""
        },
        get headers() {
          if (!cache.headers) {
            cache.headers = getHeaders(req.headers);
          }
          return cache.headers;
        },
        get cookies() {
          if (!cache.cookies) {
            const requestCookies = new _cookies.RequestCookies(_headers.HeadersAdapter.from(req.headers));
            mergeMiddlewareCookies(req, requestCookies);
            cache.cookies = _requestcookies.RequestCookiesAdapter.seal(requestCookies);
          }
          return cache.cookies;
        },
        set cookies(value) {
          cache.cookies = value;
        },
        get mutableCookies() {
          if (!cache.mutableCookies) {
            const mutableCookies = getMutableCookies(req.headers, onUpdateCookies || (res ? defaultOnUpdateCookies : void 0));
            mergeMiddlewareCookies(req, mutableCookies);
            cache.mutableCookies = mutableCookies;
          }
          return cache.mutableCookies;
        },
        get userspaceMutableCookies() {
          if (!cache.userspaceMutableCookies) {
            const userspaceMutableCookies = (0, _requestcookies.wrapWithMutableAccessCheck)(this.mutableCookies);
            cache.userspaceMutableCookies = userspaceMutableCookies;
          }
          return cache.userspaceMutableCookies;
        },
        get draftMode() {
          if (!cache.draftMode) {
            cache.draftMode = new _draftmodeprovider.DraftModeProvider(previewProps, req, this.cookies, this.mutableCookies);
          }
          return cache.draftMode;
        },
        isHmrRefresh,
        serverComponentsHmrCache: serverComponentsHmrCache || globalThis.__serverComponentsHmrCache
      };
    }
    function synchronizeMutableCookies(store) {
      store.cookies = _requestcookies.RequestCookiesAdapter.seal((0, _requestcookies.responseCookiesToRequestCookies)(store.mutableCookies));
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/compiled/p-queue/index.js
var require_p_queue = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/compiled/p-queue/index.js"(exports, module) {
    (() => {
      "use strict";
      var e = { 993: (e2) => {
        var t2 = Object.prototype.hasOwnProperty, n2 = "~";
        function Events() {
        }
        if (Object.create) {
          Events.prototype = /* @__PURE__ */ Object.create(null);
          if (!new Events().__proto__)
            n2 = false;
        }
        function EE(e3, t3, n3) {
          this.fn = e3;
          this.context = t3;
          this.once = n3 || false;
        }
        function addListener(e3, t3, r, i, s) {
          if (typeof r !== "function") {
            throw new TypeError("The listener must be a function");
          }
          var o = new EE(r, i || e3, s), u = n2 ? n2 + t3 : t3;
          if (!e3._events[u])
            e3._events[u] = o, e3._eventsCount++;
          else if (!e3._events[u].fn)
            e3._events[u].push(o);
          else
            e3._events[u] = [e3._events[u], o];
          return e3;
        }
        function clearEvent(e3, t3) {
          if (--e3._eventsCount === 0)
            e3._events = new Events();
          else
            delete e3._events[t3];
        }
        function EventEmitter() {
          this._events = new Events();
          this._eventsCount = 0;
        }
        EventEmitter.prototype.eventNames = function eventNames() {
          var e3 = [], r, i;
          if (this._eventsCount === 0)
            return e3;
          for (i in r = this._events) {
            if (t2.call(r, i))
              e3.push(n2 ? i.slice(1) : i);
          }
          if (Object.getOwnPropertySymbols) {
            return e3.concat(Object.getOwnPropertySymbols(r));
          }
          return e3;
        };
        EventEmitter.prototype.listeners = function listeners(e3) {
          var t3 = n2 ? n2 + e3 : e3, r = this._events[t3];
          if (!r)
            return [];
          if (r.fn)
            return [r.fn];
          for (var i = 0, s = r.length, o = new Array(s); i < s; i++) {
            o[i] = r[i].fn;
          }
          return o;
        };
        EventEmitter.prototype.listenerCount = function listenerCount(e3) {
          var t3 = n2 ? n2 + e3 : e3, r = this._events[t3];
          if (!r)
            return 0;
          if (r.fn)
            return 1;
          return r.length;
        };
        EventEmitter.prototype.emit = function emit(e3, t3, r, i, s, o) {
          var u = n2 ? n2 + e3 : e3;
          if (!this._events[u])
            return false;
          var a = this._events[u], l = arguments.length, c, h;
          if (a.fn) {
            if (a.once)
              this.removeListener(e3, a.fn, void 0, true);
            switch (l) {
              case 1:
                return a.fn.call(a.context), true;
              case 2:
                return a.fn.call(a.context, t3), true;
              case 3:
                return a.fn.call(a.context, t3, r), true;
              case 4:
                return a.fn.call(a.context, t3, r, i), true;
              case 5:
                return a.fn.call(a.context, t3, r, i, s), true;
              case 6:
                return a.fn.call(a.context, t3, r, i, s, o), true;
            }
            for (h = 1, c = new Array(l - 1); h < l; h++) {
              c[h - 1] = arguments[h];
            }
            a.fn.apply(a.context, c);
          } else {
            var _ = a.length, f;
            for (h = 0; h < _; h++) {
              if (a[h].once)
                this.removeListener(e3, a[h].fn, void 0, true);
              switch (l) {
                case 1:
                  a[h].fn.call(a[h].context);
                  break;
                case 2:
                  a[h].fn.call(a[h].context, t3);
                  break;
                case 3:
                  a[h].fn.call(a[h].context, t3, r);
                  break;
                case 4:
                  a[h].fn.call(a[h].context, t3, r, i);
                  break;
                default:
                  if (!c)
                    for (f = 1, c = new Array(l - 1); f < l; f++) {
                      c[f - 1] = arguments[f];
                    }
                  a[h].fn.apply(a[h].context, c);
              }
            }
          }
          return true;
        };
        EventEmitter.prototype.on = function on(e3, t3, n3) {
          return addListener(this, e3, t3, n3, false);
        };
        EventEmitter.prototype.once = function once(e3, t3, n3) {
          return addListener(this, e3, t3, n3, true);
        };
        EventEmitter.prototype.removeListener = function removeListener(e3, t3, r, i) {
          var s = n2 ? n2 + e3 : e3;
          if (!this._events[s])
            return this;
          if (!t3) {
            clearEvent(this, s);
            return this;
          }
          var o = this._events[s];
          if (o.fn) {
            if (o.fn === t3 && (!i || o.once) && (!r || o.context === r)) {
              clearEvent(this, s);
            }
          } else {
            for (var u = 0, a = [], l = o.length; u < l; u++) {
              if (o[u].fn !== t3 || i && !o[u].once || r && o[u].context !== r) {
                a.push(o[u]);
              }
            }
            if (a.length)
              this._events[s] = a.length === 1 ? a[0] : a;
            else
              clearEvent(this, s);
          }
          return this;
        };
        EventEmitter.prototype.removeAllListeners = function removeAllListeners(e3) {
          var t3;
          if (e3) {
            t3 = n2 ? n2 + e3 : e3;
            if (this._events[t3])
              clearEvent(this, t3);
          } else {
            this._events = new Events();
            this._eventsCount = 0;
          }
          return this;
        };
        EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
        EventEmitter.prototype.addListener = EventEmitter.prototype.on;
        EventEmitter.prefixed = n2;
        EventEmitter.EventEmitter = EventEmitter;
        if (true) {
          e2.exports = EventEmitter;
        }
      }, 213: (e2) => {
        e2.exports = (e3, t2) => {
          t2 = t2 || (() => {
          });
          return e3.then((e4) => new Promise((e5) => {
            e5(t2());
          }).then(() => e4), (e4) => new Promise((e5) => {
            e5(t2());
          }).then(() => {
            throw e4;
          }));
        };
      }, 574: (e2, t2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        function lowerBound(e3, t3, n2) {
          let r = 0;
          let i = e3.length;
          while (i > 0) {
            const s = i / 2 | 0;
            let o = r + s;
            if (n2(e3[o], t3) <= 0) {
              r = ++o;
              i -= s + 1;
            } else {
              i = s;
            }
          }
          return r;
        }
        t2["default"] = lowerBound;
      }, 821: (e2, t2, n2) => {
        Object.defineProperty(t2, "__esModule", { value: true });
        const r = n2(574);
        class PriorityQueue {
          constructor() {
            this._queue = [];
          }
          enqueue(e3, t3) {
            t3 = Object.assign({ priority: 0 }, t3);
            const n3 = { priority: t3.priority, run: e3 };
            if (this.size && this._queue[this.size - 1].priority >= t3.priority) {
              this._queue.push(n3);
              return;
            }
            const i = r.default(this._queue, n3, (e4, t4) => t4.priority - e4.priority);
            this._queue.splice(i, 0, n3);
          }
          dequeue() {
            const e3 = this._queue.shift();
            return e3 === null || e3 === void 0 ? void 0 : e3.run;
          }
          filter(e3) {
            return this._queue.filter((t3) => t3.priority === e3.priority).map((e4) => e4.run);
          }
          get size() {
            return this._queue.length;
          }
        }
        t2["default"] = PriorityQueue;
      }, 816: (e2, t2, n2) => {
        const r = n2(213);
        class TimeoutError extends Error {
          constructor(e3) {
            super(e3);
            this.name = "TimeoutError";
          }
        }
        const pTimeout = (e3, t3, n3) => new Promise((i, s) => {
          if (typeof t3 !== "number" || t3 < 0) {
            throw new TypeError("Expected `milliseconds` to be a positive number");
          }
          if (t3 === Infinity) {
            i(e3);
            return;
          }
          const o = setTimeout(() => {
            if (typeof n3 === "function") {
              try {
                i(n3());
              } catch (e4) {
                s(e4);
              }
              return;
            }
            const r2 = typeof n3 === "string" ? n3 : `Promise timed out after ${t3} milliseconds`;
            const o2 = n3 instanceof Error ? n3 : new TimeoutError(r2);
            if (typeof e3.cancel === "function") {
              e3.cancel();
            }
            s(o2);
          }, t3);
          r(e3.then(i, s), () => {
            clearTimeout(o);
          });
        });
        e2.exports = pTimeout;
        e2.exports["default"] = pTimeout;
        e2.exports.TimeoutError = TimeoutError;
      } };
      var t = {};
      function __nccwpck_require__2(n2) {
        var r = t[n2];
        if (r !== void 0) {
          return r.exports;
        }
        var i = t[n2] = { exports: {} };
        var s = true;
        try {
          e[n2](i, i.exports, __nccwpck_require__2);
          s = false;
        } finally {
          if (s)
            delete t[n2];
        }
        return i.exports;
      }
      if (typeof __nccwpck_require__2 !== "undefined")
        __nccwpck_require__2.ab = "/";
      var n = {};
      (() => {
        var e2 = n;
        Object.defineProperty(e2, "__esModule", { value: true });
        const t2 = __nccwpck_require__2(993);
        const r = __nccwpck_require__2(816);
        const i = __nccwpck_require__2(821);
        const empty = () => {
        };
        const s = new r.TimeoutError();
        class PQueue extends t2 {
          constructor(e3) {
            var t3, n2, r2, s2;
            super();
            this._intervalCount = 0;
            this._intervalEnd = 0;
            this._pendingCount = 0;
            this._resolveEmpty = empty;
            this._resolveIdle = empty;
            e3 = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: i.default }, e3);
            if (!(typeof e3.intervalCap === "number" && e3.intervalCap >= 1)) {
              throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(n2 = (t3 = e3.intervalCap) === null || t3 === void 0 ? void 0 : t3.toString()) !== null && n2 !== void 0 ? n2 : ""}\` (${typeof e3.intervalCap})`);
            }
            if (e3.interval === void 0 || !(Number.isFinite(e3.interval) && e3.interval >= 0)) {
              throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(s2 = (r2 = e3.interval) === null || r2 === void 0 ? void 0 : r2.toString()) !== null && s2 !== void 0 ? s2 : ""}\` (${typeof e3.interval})`);
            }
            this._carryoverConcurrencyCount = e3.carryoverConcurrencyCount;
            this._isIntervalIgnored = e3.intervalCap === Infinity || e3.interval === 0;
            this._intervalCap = e3.intervalCap;
            this._interval = e3.interval;
            this._queue = new e3.queueClass();
            this._queueClass = e3.queueClass;
            this.concurrency = e3.concurrency;
            this._timeout = e3.timeout;
            this._throwOnTimeout = e3.throwOnTimeout === true;
            this._isPaused = e3.autoStart === false;
          }
          get _doesIntervalAllowAnother() {
            return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
          }
          get _doesConcurrentAllowAnother() {
            return this._pendingCount < this._concurrency;
          }
          _next() {
            this._pendingCount--;
            this._tryToStartAnother();
            this.emit("next");
          }
          _resolvePromises() {
            this._resolveEmpty();
            this._resolveEmpty = empty;
            if (this._pendingCount === 0) {
              this._resolveIdle();
              this._resolveIdle = empty;
              this.emit("idle");
            }
          }
          _onResumeInterval() {
            this._onInterval();
            this._initializeIntervalIfNeeded();
            this._timeoutId = void 0;
          }
          _isIntervalPaused() {
            const e3 = Date.now();
            if (this._intervalId === void 0) {
              const t3 = this._intervalEnd - e3;
              if (t3 < 0) {
                this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
              } else {
                if (this._timeoutId === void 0) {
                  this._timeoutId = setTimeout(() => {
                    this._onResumeInterval();
                  }, t3);
                }
                return true;
              }
            }
            return false;
          }
          _tryToStartAnother() {
            if (this._queue.size === 0) {
              if (this._intervalId) {
                clearInterval(this._intervalId);
              }
              this._intervalId = void 0;
              this._resolvePromises();
              return false;
            }
            if (!this._isPaused) {
              const e3 = !this._isIntervalPaused();
              if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
                const t3 = this._queue.dequeue();
                if (!t3) {
                  return false;
                }
                this.emit("active");
                t3();
                if (e3) {
                  this._initializeIntervalIfNeeded();
                }
                return true;
              }
            }
            return false;
          }
          _initializeIntervalIfNeeded() {
            if (this._isIntervalIgnored || this._intervalId !== void 0) {
              return;
            }
            this._intervalId = setInterval(() => {
              this._onInterval();
            }, this._interval);
            this._intervalEnd = Date.now() + this._interval;
          }
          _onInterval() {
            if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
              clearInterval(this._intervalId);
              this._intervalId = void 0;
            }
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
            this._processQueue();
          }
          _processQueue() {
            while (this._tryToStartAnother()) {
            }
          }
          get concurrency() {
            return this._concurrency;
          }
          set concurrency(e3) {
            if (!(typeof e3 === "number" && e3 >= 1)) {
              throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${e3}\` (${typeof e3})`);
            }
            this._concurrency = e3;
            this._processQueue();
          }
          async add(e3, t3 = {}) {
            return new Promise((n2, i2) => {
              const run = async () => {
                this._pendingCount++;
                this._intervalCount++;
                try {
                  const o = this._timeout === void 0 && t3.timeout === void 0 ? e3() : r.default(Promise.resolve(e3()), t3.timeout === void 0 ? this._timeout : t3.timeout, () => {
                    if (t3.throwOnTimeout === void 0 ? this._throwOnTimeout : t3.throwOnTimeout) {
                      i2(s);
                    }
                    return void 0;
                  });
                  n2(await o);
                } catch (e4) {
                  i2(e4);
                }
                this._next();
              };
              this._queue.enqueue(run, t3);
              this._tryToStartAnother();
              this.emit("add");
            });
          }
          async addAll(e3, t3) {
            return Promise.all(e3.map(async (e4) => this.add(e4, t3)));
          }
          start() {
            if (!this._isPaused) {
              return this;
            }
            this._isPaused = false;
            this._processQueue();
            return this;
          }
          pause() {
            this._isPaused = true;
          }
          clear() {
            this._queue = new this._queueClass();
          }
          async onEmpty() {
            if (this._queue.size === 0) {
              return;
            }
            return new Promise((e3) => {
              const t3 = this._resolveEmpty;
              this._resolveEmpty = () => {
                t3();
                e3();
              };
            });
          }
          async onIdle() {
            if (this._pendingCount === 0 && this._queue.size === 0) {
              return;
            }
            return new Promise((e3) => {
              const t3 = this._resolveIdle;
              this._resolveIdle = () => {
                t3();
                e3();
              };
            });
          }
          get size() {
            return this._queue.size;
          }
          sizeBy(e3) {
            return this._queue.filter(e3).length;
          }
          get pending() {
            return this._pendingCount;
          }
          get isPaused() {
            return this._isPaused;
          }
          get timeout() {
            return this._timeout;
          }
          set timeout(e3) {
            this._timeout = e3;
          }
        }
        e2["default"] = PQueue;
      })();
      module.exports = n;
    })();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/after/revalidation-utils.js
var require_revalidation_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/after/revalidation-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "withExecuteRevalidates", {
      enumerable: true,
      get: function() {
        return withExecuteRevalidates;
      }
    });
    async function withExecuteRevalidates(store, callback) {
      if (!store) {
        return callback();
      }
      const savedRevalidationState = cloneRevalidationState(store);
      try {
        return await callback();
      } finally {
        const newRevalidates = diffRevalidationState(savedRevalidationState, cloneRevalidationState(store));
        await executeRevalidates(store, newRevalidates);
      }
    }
    function cloneRevalidationState(store) {
      return {
        revalidatedTags: store.revalidatedTags ? [
          ...store.revalidatedTags
        ] : [],
        pendingRevalidates: {
          ...store.pendingRevalidates
        },
        pendingRevalidateWrites: store.pendingRevalidateWrites ? [
          ...store.pendingRevalidateWrites
        ] : []
      };
    }
    function diffRevalidationState(prev, curr) {
      const prevTags = new Set(prev.revalidatedTags);
      const prevRevalidateWrites = new Set(prev.pendingRevalidateWrites);
      return {
        revalidatedTags: curr.revalidatedTags.filter((tag) => !prevTags.has(tag)),
        pendingRevalidates: Object.fromEntries(Object.entries(curr.pendingRevalidates).filter(([key]) => !(key in prev.pendingRevalidates))),
        pendingRevalidateWrites: curr.pendingRevalidateWrites.filter((promise) => !prevRevalidateWrites.has(promise))
      };
    }
    async function executeRevalidates(workStore, { revalidatedTags, pendingRevalidates, pendingRevalidateWrites }) {
      var _workStore_incrementalCache;
      return Promise.all([
        (_workStore_incrementalCache = workStore.incrementalCache) == null ? void 0 : _workStore_incrementalCache.revalidateTag(revalidatedTags),
        ...Object.values(pendingRevalidates),
        ...pendingRevalidateWrites
      ]);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/after/after-context.js
var require_after_context = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/after/after-context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "AfterContext", {
      enumerable: true,
      get: function() {
        return AfterContext;
      }
    });
    var _pqueue = /* @__PURE__ */ _interop_require_default(require_p_queue());
    var _invarianterror = require_invariant_error();
    var _isthenable = require_is_thenable();
    var _workasyncstorageexternal = require_work_async_storage_external();
    var _revalidationutils = require_revalidation_utils();
    var _asynclocalstorage = require_async_local_storage();
    var _workunitasyncstorageexternal = require_work_unit_async_storage_external();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var AfterContext = class {
      constructor({ waitUntil, onClose, onTaskError }) {
        this.workUnitStores = /* @__PURE__ */ new Set();
        this.waitUntil = waitUntil;
        this.onClose = onClose;
        this.onTaskError = onTaskError;
        this.callbackQueue = new _pqueue.default();
        this.callbackQueue.pause();
      }
      after(task) {
        if ((0, _isthenable.isThenable)(task)) {
          if (!this.waitUntil) {
            errorWaitUntilNotAvailable();
          }
          this.waitUntil(task.catch((error) => this.reportTaskError(error)));
        } else if (typeof task === "function") {
          this.addCallback(task);
        } else {
          throw new Error("`unstable_after()`: Argument must be a promise or a function");
        }
      }
      addCallback(callback) {
        if (!this.waitUntil) {
          errorWaitUntilNotAvailable();
        }
        if (!this.onClose) {
          throw new _invarianterror.InvariantError("unstable_after: Missing `onClose` implementation");
        }
        const workUnitStore = _workunitasyncstorageexternal.workUnitAsyncStorage.getStore();
        if (!workUnitStore) {
          throw new _invarianterror.InvariantError("Missing workUnitStore in AfterContext.addCallback");
        }
        this.workUnitStores.add(workUnitStore);
        if (!this.runCallbacksOnClosePromise) {
          this.runCallbacksOnClosePromise = this.runCallbacksOnClose();
          this.waitUntil(this.runCallbacksOnClosePromise);
        }
        const wrappedCallback = (0, _asynclocalstorage.bindSnapshot)(async () => {
          try {
            await callback();
          } catch (error) {
            this.reportTaskError(error);
          }
        });
        this.callbackQueue.add(wrappedCallback);
      }
      async runCallbacksOnClose() {
        await new Promise((resolve) => this.onClose(resolve));
        return this.runCallbacks();
      }
      async runCallbacks() {
        if (this.callbackQueue.size === 0)
          return;
        for (const workUnitStore of this.workUnitStores) {
          workUnitStore.phase = "after";
        }
        const workStore = _workasyncstorageexternal.workAsyncStorage.getStore();
        if (!workStore) {
          throw new _invarianterror.InvariantError("Missing workStore in AfterContext.runCallbacks");
        }
        return (0, _revalidationutils.withExecuteRevalidates)(workStore, () => {
          this.callbackQueue.start();
          return this.callbackQueue.onIdle();
        });
      }
      reportTaskError(error) {
        console.error("An error occurred in a function passed to `unstable_after()`:", error);
        if (this.onTaskError) {
          try {
            this.onTaskError == null ? void 0 : this.onTaskError.call(this, error);
          } catch (handlerError) {
            console.error(new _invarianterror.InvariantError("`onTaskError` threw while handling an error thrown from an `unstable_after` task", {
              cause: handlerError
            }));
          }
        }
      }
    };
    function errorWaitUntilNotAvailable() {
      throw new Error("`unstable_after()` will not work correctly, because `waitUntil` is not available in the current environment.");
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/async-storage/with-work-store.js
var require_with_work_store = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/async-storage/with-work-store.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "withWorkStore", {
      enumerable: true,
      get: function() {
        return withWorkStore;
      }
    });
    var _aftercontext = require_after_context();
    var _apppaths = require_app_paths();
    var withWorkStore = (storage, { page, fallbackRouteParams, renderOpts, requestEndedState, isPrefetchRequest }, callback) => {
      const isStaticGeneration = !renderOpts.supportsDynamicResponse && !renderOpts.isDraftMode && !renderOpts.isServerAction;
      const store = {
        isStaticGeneration,
        page,
        fallbackRouteParams,
        route: (0, _apppaths.normalizeAppPath)(page),
        incrementalCache: (
          // we fallback to a global incremental cache for edge-runtime locally
          // so that it can access the fs cache without mocks
          renderOpts.incrementalCache || globalThis.__incrementalCache
        ),
        cacheLifeProfiles: renderOpts.cacheLifeProfiles,
        isRevalidate: renderOpts.isRevalidate,
        isPrerendering: renderOpts.nextExport,
        fetchCache: renderOpts.fetchCache,
        isOnDemandRevalidate: renderOpts.isOnDemandRevalidate,
        isDraftMode: renderOpts.isDraftMode,
        requestEndedState,
        isPrefetchRequest,
        buildId: renderOpts.buildId,
        reactLoadableManifest: (renderOpts == null ? void 0 : renderOpts.reactLoadableManifest) || {},
        assetPrefix: (renderOpts == null ? void 0 : renderOpts.assetPrefix) || "",
        afterContext: createAfterContext(renderOpts)
      };
      renderOpts.store = store;
      return storage.run(store, callback, store);
    };
    function createAfterContext(renderOpts) {
      var _renderOpts_experimental;
      const isAfterEnabled = (renderOpts == null ? void 0 : (_renderOpts_experimental = renderOpts.experimental) == null ? void 0 : _renderOpts_experimental.after) ?? false;
      if (!isAfterEnabled) {
        return void 0;
      }
      const { waitUntil, onClose, onAfterTaskError } = renderOpts;
      return new _aftercontext.AfterContext({
        waitUntil,
        onClose,
        onTaskError: onAfterTaskError
      });
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/web-on-close.js
var require_web_on_close = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/web-on-close.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      CloseController: function() {
        return CloseController;
      },
      trackBodyConsumed: function() {
        return trackBodyConsumed;
      },
      trackStreamConsumed: function() {
        return trackStreamConsumed;
      }
    });
    function trackBodyConsumed(body, onEnd) {
      if (typeof body === "string") {
        const generator = async function* generate() {
          const encoder = new TextEncoder();
          yield encoder.encode(body);
          onEnd();
        };
        return generator();
      } else {
        return trackStreamConsumed(body, onEnd);
      }
    }
    function trackStreamConsumed(stream, onEnd) {
      const closePassThrough = new TransformStream({
        flush: () => {
          return onEnd();
        }
      });
      return stream.pipeThrough(closePassThrough);
    }
    var CloseController = class {
      onClose(callback) {
        if (this.isClosed) {
          throw new Error("Cannot subscribe to a closed CloseController");
        }
        this.target.addEventListener("close", callback);
        this.listeners++;
      }
      dispatchClose() {
        if (this.isClosed) {
          throw new Error("Cannot close a CloseController multiple times");
        }
        if (this.listeners > 0) {
          this.target.dispatchEvent(new Event("close"));
        }
        this.isClosed = true;
      }
      constructor() {
        this.target = new EventTarget();
        this.listeners = 0;
        this.isClosed = false;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/get-edge-preview-props.js
var require_get_edge_preview_props = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/get-edge-preview-props.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getEdgePreviewProps", {
      enumerable: true,
      get: function() {
        return getEdgePreviewProps;
      }
    });
    function getEdgePreviewProps() {
      return {
        previewModeId: true ? process.env.__NEXT_PREVIEW_MODE_ID : "development-id",
        previewModeSigningKey: process.env.__NEXT_PREVIEW_MODE_SIGNING_KEY || "",
        previewModeEncryptionKey: process.env.__NEXT_PREVIEW_MODE_ENCRYPTION_KEY || ""
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/context.js
var require_context = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getTestReqInfo: function() {
        return getTestReqInfo;
      },
      withRequest: function() {
        return withRequest;
      }
    });
    var _nodeasync_hooks = require("node:async_hooks");
    var testStorage = new _nodeasync_hooks.AsyncLocalStorage();
    function extractTestInfoFromRequest(req, reader) {
      const proxyPortHeader = reader.header(req, "next-test-proxy-port");
      if (!proxyPortHeader) {
        return void 0;
      }
      const url = reader.url(req);
      const proxyPort = Number(proxyPortHeader);
      const testData = reader.header(req, "next-test-data") || "";
      return {
        url,
        proxyPort,
        testData
      };
    }
    function withRequest(req, reader, fn) {
      const testReqInfo = extractTestInfoFromRequest(req, reader);
      if (!testReqInfo) {
        return fn();
      }
      return testStorage.run(testReqInfo, fn);
    }
    function getTestReqInfo(req, reader) {
      const testReqInfo = testStorage.getStore();
      if (testReqInfo) {
        return testReqInfo;
      }
      if (req && reader) {
        return extractTestInfoFromRequest(req, reader);
      }
      return void 0;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/fetch.js
var require_fetch = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/fetch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      handleFetch: function() {
        return handleFetch;
      },
      interceptFetch: function() {
        return interceptFetch;
      },
      reader: function() {
        return reader;
      }
    });
    var _context = require_context();
    var reader = {
      url(req) {
        return req.url;
      },
      header(req, name) {
        return req.headers.get(name);
      }
    };
    function getTestStack() {
      let stack = (new Error().stack ?? "").split("\n");
      for (let i = 1; i < stack.length; i++) {
        if (stack[i].length > 0) {
          stack = stack.slice(i);
          break;
        }
      }
      stack = stack.filter((f) => !f.includes("/next/dist/"));
      stack = stack.slice(0, 5);
      stack = stack.map((s) => s.replace("webpack-internal:///(rsc)/", "").trim());
      return stack.join("    ");
    }
    async function buildProxyRequest(testData, request) {
      const { url, method, headers, body, cache, credentials, integrity, mode, redirect, referrer, referrerPolicy } = request;
      return {
        testData,
        api: "fetch",
        request: {
          url,
          method,
          headers: [
            ...Array.from(headers),
            [
              "next-test-stack",
              getTestStack()
            ]
          ],
          body: body ? Buffer.from(await request.arrayBuffer()).toString("base64") : null,
          cache,
          credentials,
          integrity,
          mode,
          redirect,
          referrer,
          referrerPolicy
        }
      };
    }
    function buildResponse(proxyResponse) {
      const { status, headers, body } = proxyResponse.response;
      return new Response(body ? Buffer.from(body, "base64") : null, {
        status,
        headers: new Headers(headers)
      });
    }
    async function handleFetch(originalFetch, request) {
      const testInfo = (0, _context.getTestReqInfo)(request, reader);
      if (!testInfo) {
        return originalFetch(request);
      }
      const { testData, proxyPort } = testInfo;
      const proxyRequest = await buildProxyRequest(testData, request);
      const resp = await originalFetch(`http://localhost:${proxyPort}`, {
        method: "POST",
        body: JSON.stringify(proxyRequest),
        next: {
          // @ts-ignore
          internal: true
        }
      });
      if (!resp.ok) {
        throw new Error(`Proxy request failed: ${resp.status}`);
      }
      const proxyResponse = await resp.json();
      const { api } = proxyResponse;
      switch (api) {
        case "continue":
          return originalFetch(request);
        case "abort":
        case "unhandled":
          throw new Error(`Proxy request aborted [${request.method} ${request.url}]`);
        default:
          break;
      }
      return buildResponse(proxyResponse);
    }
    function interceptFetch(originalFetch) {
      global.fetch = function testFetch(input, init) {
        var _init_next;
        if (init == null ? void 0 : (_init_next = init.next) == null ? void 0 : _init_next.internal) {
          return originalFetch(input, init);
        }
        return handleFetch(originalFetch, new Request(input, init));
      };
      return () => {
        global.fetch = originalFetch;
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/server-edge.js
var require_server_edge = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/server-edge.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      interceptTestApis: function() {
        return interceptTestApis;
      },
      wrapRequestHandler: function() {
        return wrapRequestHandler;
      }
    });
    var _context = require_context();
    var _fetch = require_fetch();
    function interceptTestApis() {
      return (0, _fetch.interceptFetch)(global.fetch);
    }
    function wrapRequestHandler(handler) {
      return (req, fn) => (0, _context.withRequest)(req, _fetch.reader, () => handler(req, fn));
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/adapter.js
var require_adapter = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/adapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      NextRequestHint: function() {
        return NextRequestHint;
      },
      adapter: function() {
        return adapter;
      }
    });
    var _error = require_error();
    var _utils = require_utils();
    var _fetchevent = require_fetch_event();
    var _request = require_request();
    var _response = require_response();
    var _relativizeurl = require_relativize_url();
    var _nexturl = require_next_url();
    var _internalutils = require_internal_utils();
    var _apppaths = require_app_paths();
    var _approuterheaders = require_app_router_headers();
    var _globals = require_globals();
    var _requeststore = require_request_store();
    var _workunitasyncstorageexternal = require_work_unit_async_storage_external();
    var _withworkstore = require_with_work_store();
    var _workasyncstorageexternal = require_work_async_storage_external();
    var _tracer = require_tracer();
    var _constants = require_constants2();
    var _webonclose = require_web_on_close();
    var _getedgepreviewprops = require_get_edge_preview_props();
    var _builtinrequestcontext = require_builtin_request_context();
    var NextRequestHint = class extends _request.NextRequest {
      constructor(params) {
        super(params.input, params.init);
        this.sourcePage = params.page;
      }
      get request() {
        throw new _error.PageSignatureError({
          page: this.sourcePage
        });
      }
      respondWith() {
        throw new _error.PageSignatureError({
          page: this.sourcePage
        });
      }
      waitUntil() {
        throw new _error.PageSignatureError({
          page: this.sourcePage
        });
      }
    };
    var headersGetter = {
      keys: (headers) => Array.from(headers.keys()),
      get: (headers, key) => headers.get(key) ?? void 0
    };
    var propagator = (request, fn) => {
      const tracer = (0, _tracer.getTracer)();
      return tracer.withPropagatedContext(request.headers, fn, headersGetter);
    };
    var testApisIntercepted = false;
    function ensureTestApisIntercepted() {
      if (!testApisIntercepted) {
        testApisIntercepted = true;
        if (process.env.NEXT_PRIVATE_TEST_PROXY === "true") {
          const { interceptTestApis, wrapRequestHandler } = require_server_edge();
          interceptTestApis();
          propagator = wrapRequestHandler(propagator);
        }
      }
    }
    async function adapter(params) {
      var _getBuiltinRequestContext;
      ensureTestApisIntercepted();
      await (0, _globals.ensureInstrumentationRegistered)();
      const isEdgeRendering = typeof self.__BUILD_MANIFEST !== "undefined";
      params.request.url = (0, _apppaths.normalizeRscURL)(params.request.url);
      const requestUrl = new _nexturl.NextURL(params.request.url, {
        headers: params.request.headers,
        nextConfig: params.request.nextConfig
      });
      const keys = [
        ...requestUrl.searchParams.keys()
      ];
      for (const key of keys) {
        const value = requestUrl.searchParams.getAll(key);
        (0, _utils.normalizeNextQueryParam)(key, (normalizedKey) => {
          requestUrl.searchParams.delete(normalizedKey);
          for (const val of value) {
            requestUrl.searchParams.append(normalizedKey, val);
          }
          requestUrl.searchParams.delete(key);
        });
      }
      const buildId = requestUrl.buildId;
      requestUrl.buildId = "";
      const isNextDataRequest = params.request.headers["x-nextjs-data"];
      if (isNextDataRequest && requestUrl.pathname === "/index") {
        requestUrl.pathname = "/";
      }
      const requestHeaders = (0, _utils.fromNodeOutgoingHttpHeaders)(params.request.headers);
      const flightHeaders = /* @__PURE__ */ new Map();
      if (!isEdgeRendering) {
        for (const header of _approuterheaders.FLIGHT_HEADERS) {
          const key = header.toLowerCase();
          const value = requestHeaders.get(key);
          if (value) {
            flightHeaders.set(key, value);
            requestHeaders.delete(key);
          }
        }
      }
      const normalizeUrl = process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE ? new URL(params.request.url) : requestUrl;
      const request = new NextRequestHint({
        page: params.page,
        // Strip internal query parameters off the request.
        input: (0, _internalutils.stripInternalSearchParams)(normalizeUrl, true).toString(),
        init: {
          body: params.request.body,
          headers: requestHeaders,
          method: params.request.method,
          nextConfig: params.request.nextConfig,
          signal: params.request.signal
        }
      });
      if (isNextDataRequest) {
        Object.defineProperty(request, "__isData", {
          enumerable: false,
          value: true
        });
      }
      if (!globalThis.__incrementalCache && params.IncrementalCache) {
        globalThis.__incrementalCache = new params.IncrementalCache({
          appDir: true,
          fetchCache: true,
          minimalMode: true,
          fetchCacheKeyPrefix: process.env.__NEXT_FETCH_CACHE_KEY_PREFIX,
          dev: false,
          requestHeaders: params.request.headers,
          requestProtocol: "https",
          getPrerenderManifest: () => {
            return {
              version: -1,
              routes: {},
              dynamicRoutes: {},
              notFoundRoutes: [],
              preview: (0, _getedgepreviewprops.getEdgePreviewProps)()
            };
          }
        });
      }
      const outerWaitUntil = params.request.waitUntil ?? ((_getBuiltinRequestContext = (0, _builtinrequestcontext.getBuiltinRequestContext)()) == null ? void 0 : _getBuiltinRequestContext.waitUntil);
      const event = new _fetchevent.NextFetchEvent({
        request,
        page: params.page,
        context: outerWaitUntil ? {
          waitUntil: outerWaitUntil
        } : void 0
      });
      let response;
      let cookiesFromResponse;
      response = await propagator(request, () => {
        const isMiddleware = params.page === "/middleware" || params.page === "/src/middleware";
        if (isMiddleware) {
          var _params_request_nextConfig_experimental, _params_request_nextConfig;
          const isAfterEnabled = ((_params_request_nextConfig = params.request.nextConfig) == null ? void 0 : (_params_request_nextConfig_experimental = _params_request_nextConfig.experimental) == null ? void 0 : _params_request_nextConfig_experimental.after) ?? !!process.env.__NEXT_AFTER;
          let waitUntil = void 0;
          let closeController = void 0;
          if (isAfterEnabled) {
            waitUntil = event.waitUntil.bind(event);
            closeController = new _webonclose.CloseController();
          }
          return (0, _tracer.getTracer)().trace(_constants.MiddlewareSpan.execute, {
            spanName: `middleware ${request.method} ${request.nextUrl.pathname}`,
            attributes: {
              "http.target": request.nextUrl.pathname,
              "http.method": request.method
            }
          }, async () => {
            try {
              var _params_request_nextConfig_experimental2, _params_request_nextConfig2;
              const onUpdateCookies = (cookies) => {
                cookiesFromResponse = cookies;
              };
              const previewProps = (0, _getedgepreviewprops.getEdgePreviewProps)();
              const requestStore = (0, _requeststore.createRequestStoreForAPI)(request, request.nextUrl, void 0, onUpdateCookies, previewProps);
              return await (0, _withworkstore.withWorkStore)(_workasyncstorageexternal.workAsyncStorage, {
                page: "/",
                fallbackRouteParams: null,
                renderOpts: {
                  cacheLifeProfiles: (_params_request_nextConfig2 = params.request.nextConfig) == null ? void 0 : (_params_request_nextConfig_experimental2 = _params_request_nextConfig2.experimental) == null ? void 0 : _params_request_nextConfig_experimental2.cacheLife,
                  experimental: {
                    after: isAfterEnabled,
                    isRoutePPREnabled: false,
                    dynamicIO: false
                  },
                  buildId: buildId ?? "",
                  supportsDynamicResponse: true,
                  waitUntil,
                  onClose: closeController ? closeController.onClose.bind(closeController) : void 0
                },
                requestEndedState: {
                  ended: false
                },
                isPrefetchRequest: request.headers.has(_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER)
              }, () => _workunitasyncstorageexternal.workUnitAsyncStorage.run(requestStore, params.handler, request, event));
            } finally {
              if (closeController) {
                setTimeout(() => {
                  closeController.dispatchClose();
                }, 0);
              }
            }
          });
        }
        return params.handler(request, event);
      });
      if (response && !(response instanceof Response)) {
        throw new TypeError("Expected an instance of Response to be returned");
      }
      if (response && cookiesFromResponse) {
        response.headers.set("set-cookie", cookiesFromResponse);
      }
      const rewrite = response == null ? void 0 : response.headers.get("x-middleware-rewrite");
      if (response && rewrite && !isEdgeRendering) {
        const rewriteUrl = new _nexturl.NextURL(rewrite, {
          forceLocale: true,
          headers: params.request.headers,
          nextConfig: params.request.nextConfig
        });
        if (!process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE) {
          if (rewriteUrl.host === request.nextUrl.host) {
            rewriteUrl.buildId = buildId || rewriteUrl.buildId;
            response.headers.set("x-middleware-rewrite", String(rewriteUrl));
          }
        }
        const relativizedRewrite = (0, _relativizeurl.relativizeURL)(String(rewriteUrl), String(requestUrl));
        if (isNextDataRequest && // if the rewrite is external and external rewrite
        // resolving config is enabled don't add this header
        // so the upstream app can set it instead
        !(process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE && relativizedRewrite.match(/http(s)?:\/\//))) {
          response.headers.set("x-nextjs-rewrite", relativizedRewrite);
        }
      }
      const redirect = response == null ? void 0 : response.headers.get("Location");
      if (response && redirect && !isEdgeRendering) {
        const redirectURL = new _nexturl.NextURL(redirect, {
          forceLocale: false,
          headers: params.request.headers,
          nextConfig: params.request.nextConfig
        });
        response = new Response(response.body, response);
        if (!process.env.__NEXT_NO_MIDDLEWARE_URL_NORMALIZE) {
          if (redirectURL.host === request.nextUrl.host) {
            redirectURL.buildId = buildId || redirectURL.buildId;
            response.headers.set("Location", String(redirectURL));
          }
        }
        if (isNextDataRequest) {
          response.headers.delete("Location");
          response.headers.set("x-nextjs-redirect", (0, _relativizeurl.relativizeURL)(String(redirectURL), String(requestUrl)));
        }
      }
      const finalResponse = response ? response : _response.NextResponse.next();
      const middlewareOverrideHeaders = finalResponse.headers.get("x-middleware-override-headers");
      const overwrittenHeaders = [];
      if (middlewareOverrideHeaders) {
        for (const [key, value] of flightHeaders) {
          finalResponse.headers.set(`x-middleware-request-${key}`, value);
          overwrittenHeaders.push(key);
        }
        if (overwrittenHeaders.length > 0) {
          finalResponse.headers.set("x-middleware-override-headers", middlewareOverrideHeaders + "," + overwrittenHeaders.join(","));
        }
      }
      return {
        response: finalResponse,
        waitUntil: (0, _fetchevent.getWaitUntilPromiseFromEvent)(event) ?? Promise.resolve(),
        fetchMetrics: request.fetchMetrics
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/instrumentation/utils.js
var require_utils7 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/instrumentation/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getRevalidateReason", {
      enumerable: true,
      get: function() {
        return getRevalidateReason;
      }
    });
    function getRevalidateReason(params) {
      if (params.isOnDemandRevalidate) {
        return "on-demand";
      }
      if (params.isRevalidate) {
        return "stale";
      }
      return void 0;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/fallback.js
var require_fallback = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/fallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      FallbackMode: function() {
        return FallbackMode;
      },
      fallbackModeToFallbackField: function() {
        return fallbackModeToFallbackField;
      },
      fallbackModeToStaticPathsResult: function() {
        return fallbackModeToStaticPathsResult;
      },
      parseFallbackField: function() {
        return parseFallbackField;
      },
      parseStaticPathsResult: function() {
        return parseStaticPathsResult;
      }
    });
    var FallbackMode;
    (function(FallbackMode2) {
      FallbackMode2["BLOCKING_STATIC_RENDER"] = "BLOCKING_STATIC_RENDER";
      FallbackMode2["PRERENDER"] = "PRERENDER";
      FallbackMode2["NOT_FOUND"] = "NOT_FOUND";
    })(FallbackMode || (FallbackMode = {}));
    function parseFallbackField(fallbackField) {
      if (typeof fallbackField === "string") {
        return "PRERENDER";
      } else if (fallbackField === null) {
        return "BLOCKING_STATIC_RENDER";
      } else if (fallbackField === false) {
        return "NOT_FOUND";
      } else if (fallbackField === void 0) {
        return void 0;
      } else {
        throw new Error(`Invalid fallback option: ${fallbackField}. Fallback option must be a string, null, undefined, or false.`);
      }
    }
    function fallbackModeToFallbackField(fallback, page) {
      switch (fallback) {
        case "BLOCKING_STATIC_RENDER":
          return null;
        case "NOT_FOUND":
          return false;
        case "PRERENDER":
          if (!page) {
            throw new Error(`Invariant: expected a page to be provided when fallback mode is "${fallback}"`);
          }
          return page;
        default:
          throw new Error(`Invalid fallback mode: ${fallback}`);
      }
    }
    function parseStaticPathsResult(result) {
      if (result === true) {
        return "PRERENDER";
      } else if (result === "blocking") {
        return "BLOCKING_STATIC_RENDER";
      } else {
        return "NOT_FOUND";
      }
    }
    function fallbackModeToStaticPathsResult(fallback) {
      switch (fallback) {
        case "PRERENDER":
          return true;
        case "BLOCKING_STATIC_RENDER":
          return "blocking";
        case "NOT_FOUND":
        default:
          return false;
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/prefetch-cache-scopes.js
var require_prefetch_cache_scopes = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/prefetch-cache-scopes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "PrefetchCacheScopes", {
      enumerable: true,
      get: function() {
        return PrefetchCacheScopes;
      }
    });
    var PrefetchCacheScopes = class {
      evict() {
        for (const [key, value] of this.cacheScopes) {
          if (value.timestamp < Date.now() - 3e4) {
            this.cacheScopes.delete(key);
          }
        }
      }
      // TODO: should this key include query params if so we need to
      // filter _rsc query
      get(url) {
        var _this_cacheScopes_get;
        setImmediate(() => this.evict());
        return (_this_cacheScopes_get = this.cacheScopes.get(url)) == null ? void 0 : _this_cacheScopes_get.cache;
      }
      set(url, cache) {
        setImmediate(() => this.evict());
        return this.cacheScopes.set(url, {
          cache,
          timestamp: Date.now()
        });
      }
      del(url) {
        this.cacheScopes.delete(url);
      }
      constructor() {
        this.cacheScopes = /* @__PURE__ */ new Map();
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/async-storage/cache-scope-instance.js
var require_cache_scope_instance = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/async-storage/cache-scope-instance.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "cacheScopeAsyncLocalStorage", {
      enumerable: true,
      get: function() {
        return cacheScopeAsyncLocalStorage;
      }
    });
    var _asynclocalstorage = require_async_local_storage();
    var cacheScopeAsyncLocalStorage = (0, _asynclocalstorage.createAsyncLocalStorage)();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/async-storage/cache-scope.external.js
var require_cache_scope_external = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/async-storage/cache-scope.external.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      cacheScopeAsyncLocalStorage: function() {
        return _cachescopeinstance.cacheScopeAsyncLocalStorage;
      },
      runWithCacheScope: function() {
        return runWithCacheScope;
      }
    });
    var _cachescopeinstance = require_cache_scope_instance();
    function runWithCacheScope(store, fn) {
      return _cachescopeinstance.cacheScopeAsyncLocalStorage.run({
        cache: store.cache || /* @__PURE__ */ new Map()
      }, fn);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/semver-noop.js
var require_semver_noop = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/semver-noop.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "satisfies", {
      enumerable: true,
      get: function() {
        return satisfies;
      }
    });
    function satisfies() {
      return true;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/compiled/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/compiled/jsonwebtoken/index.js"(exports, module) {
    (() => {
      var e = { 112: (e2, r2, t2) => {
        "use strict";
        var n = t2(300).Buffer;
        var a = t2(300).SlowBuffer;
        e2.exports = bufferEq;
        function bufferEq(e3, r3) {
          if (!n.isBuffer(e3) || !n.isBuffer(r3)) {
            return false;
          }
          if (e3.length !== r3.length) {
            return false;
          }
          var t3 = 0;
          for (var a2 = 0; a2 < e3.length; a2++) {
            t3 |= e3[a2] ^ r3[a2];
          }
          return t3 === 0;
        }
        bufferEq.install = function() {
          n.prototype.equal = a.prototype.equal = function equal(e3) {
            return bufferEq(this, e3);
          };
        };
        var i = n.prototype.equal;
        var s = a.prototype.equal;
        bufferEq.restore = function() {
          n.prototype.equal = i;
          a.prototype.equal = s;
        };
      }, 160: (e2, r2, t2) => {
        "use strict";
        var n = t2(911).Buffer;
        var a = t2(8);
        var i = 128, s = 0, o = 32, u = 16, l = 2, c = u | o | s << 6, f = l | s << 6;
        function base64Url(e3) {
          return e3.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        function signatureAsBuffer(e3) {
          if (n.isBuffer(e3)) {
            return e3;
          } else if ("string" === typeof e3) {
            return n.from(e3, "base64");
          }
          throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
        }
        function derToJose(e3, r3) {
          e3 = signatureAsBuffer(e3);
          var t3 = a(r3);
          var s2 = t3 + 1;
          var o2 = e3.length;
          var u2 = 0;
          if (e3[u2++] !== c) {
            throw new Error('Could not find expected "seq"');
          }
          var l2 = e3[u2++];
          if (l2 === (i | 1)) {
            l2 = e3[u2++];
          }
          if (o2 - u2 < l2) {
            throw new Error('"seq" specified length of "' + l2 + '", only "' + (o2 - u2) + '" remaining');
          }
          if (e3[u2++] !== f) {
            throw new Error('Could not find expected "int" for "r"');
          }
          var h = e3[u2++];
          if (o2 - u2 - 2 < h) {
            throw new Error('"r" specified length of "' + h + '", only "' + (o2 - u2 - 2) + '" available');
          }
          if (s2 < h) {
            throw new Error('"r" specified length of "' + h + '", max of "' + s2 + '" is acceptable');
          }
          var p = u2;
          u2 += h;
          if (e3[u2++] !== f) {
            throw new Error('Could not find expected "int" for "s"');
          }
          var d = e3[u2++];
          if (o2 - u2 !== d) {
            throw new Error('"s" specified length of "' + d + '", expected "' + (o2 - u2) + '"');
          }
          if (s2 < d) {
            throw new Error('"s" specified length of "' + d + '", max of "' + s2 + '" is acceptable');
          }
          var y = u2;
          u2 += d;
          if (u2 !== o2) {
            throw new Error('Expected to consume entire buffer, but "' + (o2 - u2) + '" bytes remain');
          }
          var g = t3 - h, v = t3 - d;
          var b = n.allocUnsafe(g + h + v + d);
          for (u2 = 0; u2 < g; ++u2) {
            b[u2] = 0;
          }
          e3.copy(b, u2, p + Math.max(-g, 0), p + h);
          u2 = t3;
          for (var m = u2; u2 < m + v; ++u2) {
            b[u2] = 0;
          }
          e3.copy(b, u2, y + Math.max(-v, 0), y + d);
          b = b.toString("base64");
          b = base64Url(b);
          return b;
        }
        function countPadding(e3, r3, t3) {
          var n2 = 0;
          while (r3 + n2 < t3 && e3[r3 + n2] === 0) {
            ++n2;
          }
          var a2 = e3[r3 + n2] >= i;
          if (a2) {
            --n2;
          }
          return n2;
        }
        function joseToDer(e3, r3) {
          e3 = signatureAsBuffer(e3);
          var t3 = a(r3);
          var s2 = e3.length;
          if (s2 !== t3 * 2) {
            throw new TypeError('"' + r3 + '" signatures must be "' + t3 * 2 + '" bytes, saw "' + s2 + '"');
          }
          var o2 = countPadding(e3, 0, t3);
          var u2 = countPadding(e3, t3, e3.length);
          var l2 = t3 - o2;
          var h = t3 - u2;
          var p = 1 + 1 + l2 + 1 + 1 + h;
          var d = p < i;
          var y = n.allocUnsafe((d ? 2 : 3) + p);
          var g = 0;
          y[g++] = c;
          if (d) {
            y[g++] = p;
          } else {
            y[g++] = i | 1;
            y[g++] = p & 255;
          }
          y[g++] = f;
          y[g++] = l2;
          if (o2 < 0) {
            y[g++] = 0;
            g += e3.copy(y, g, 0, t3);
          } else {
            g += e3.copy(y, g, o2, t3);
          }
          y[g++] = f;
          y[g++] = h;
          if (u2 < 0) {
            y[g++] = 0;
            e3.copy(y, g, t3);
          } else {
            e3.copy(y, g, t3 + u2);
          }
          return y;
        }
        e2.exports = { derToJose, joseToDer };
      }, 8: (e2) => {
        "use strict";
        function getParamSize(e3) {
          var r3 = (e3 / 8 | 0) + (e3 % 8 === 0 ? 0 : 1);
          return r3;
        }
        var r2 = { ES256: getParamSize(256), ES384: getParamSize(384), ES512: getParamSize(521) };
        function getParamBytesForAlg(e3) {
          var t2 = r2[e3];
          if (t2) {
            return t2;
          }
          throw new Error('Unknown algorithm "' + e3 + '"');
        }
        e2.exports = getParamBytesForAlg;
      }, 443: (e2, r2, t2) => {
        var n = t2(111);
        e2.exports = function(e3, r3) {
          r3 = r3 || {};
          var t3 = n.decode(e3, r3);
          if (!t3) {
            return null;
          }
          var a = t3.payload;
          if (typeof a === "string") {
            try {
              var i = JSON.parse(a);
              if (i !== null && typeof i === "object") {
                a = i;
              }
            } catch (e4) {
            }
          }
          if (r3.complete === true) {
            return { header: t3.header, payload: a, signature: t3.signature };
          }
          return a;
        };
      }, 773: (e2, r2, t2) => {
        e2.exports = { verify: t2(624), sign: t2(743), JsonWebTokenError: t2(131), NotBeforeError: t2(422), TokenExpiredError: t2(794) };
        Object.defineProperty(e2.exports, "decode", { enumerable: false, value: t2(443) });
      }, 131: (e2) => {
        var JsonWebTokenError = function(e3, r2) {
          Error.call(this, e3);
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
          }
          this.name = "JsonWebTokenError";
          this.message = e3;
          if (r2)
            this.inner = r2;
        };
        JsonWebTokenError.prototype = Object.create(Error.prototype);
        JsonWebTokenError.prototype.constructor = JsonWebTokenError;
        e2.exports = JsonWebTokenError;
      }, 422: (e2, r2, t2) => {
        var n = t2(131);
        var NotBeforeError = function(e3, r3) {
          n.call(this, e3);
          this.name = "NotBeforeError";
          this.date = r3;
        };
        NotBeforeError.prototype = Object.create(n.prototype);
        NotBeforeError.prototype.constructor = NotBeforeError;
        e2.exports = NotBeforeError;
      }, 794: (e2, r2, t2) => {
        var n = t2(131);
        var TokenExpiredError = function(e3, r3) {
          n.call(this, e3);
          this.name = "TokenExpiredError";
          this.expiredAt = r3;
        };
        TokenExpiredError.prototype = Object.create(n.prototype);
        TokenExpiredError.prototype.constructor = TokenExpiredError;
        e2.exports = TokenExpiredError;
      }, 186: (e2, r2, t2) => {
        const n = t2(521);
        e2.exports = n.satisfies(process.version, ">=15.7.0");
      }, 900: (e2, r2, t2) => {
        var n = t2(521);
        e2.exports = n.satisfies(process.version, "^6.12.0 || >=8.0.0");
      }, 444: (e2, r2, t2) => {
        const n = t2(521);
        e2.exports = n.satisfies(process.version, ">=16.9.0");
      }, 126: (e2, r2, t2) => {
        var n = t2(958);
        e2.exports = function(e3, r3) {
          var t3 = r3 || Math.floor(Date.now() / 1e3);
          if (typeof e3 === "string") {
            var a = n(e3);
            if (typeof a === "undefined") {
              return;
            }
            return Math.floor(t3 + a / 1e3);
          } else if (typeof e3 === "number") {
            return t3 + e3;
          } else {
            return;
          }
        };
      }, 253: (e2, r2, t2) => {
        const n = t2(186);
        const a = t2(444);
        const i = { ec: ["ES256", "ES384", "ES512"], rsa: ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"], "rsa-pss": ["PS256", "PS384", "PS512"] };
        const s = { ES256: "prime256v1", ES384: "secp384r1", ES512: "secp521r1" };
        e2.exports = function(e3, r3) {
          if (!e3 || !r3)
            return;
          const t3 = r3.asymmetricKeyType;
          if (!t3)
            return;
          const o = i[t3];
          if (!o) {
            throw new Error(`Unknown key type "${t3}".`);
          }
          if (!o.includes(e3)) {
            throw new Error(`"alg" parameter for "${t3}" key type must be one of: ${o.join(", ")}.`);
          }
          if (n) {
            switch (t3) {
              case "ec":
                const t4 = r3.asymmetricKeyDetails.namedCurve;
                const n2 = s[e3];
                if (t4 !== n2) {
                  throw new Error(`"alg" parameter "${e3}" requires curve "${n2}".`);
                }
                break;
              case "rsa-pss":
                if (a) {
                  const t5 = parseInt(e3.slice(-3), 10);
                  const { hashAlgorithm: n3, mgf1HashAlgorithm: a2, saltLength: i2 } = r3.asymmetricKeyDetails;
                  if (n3 !== `sha${t5}` || a2 !== n3) {
                    throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${e3}.`);
                  }
                  if (i2 !== void 0 && i2 > t5 >> 3) {
                    throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${e3}.`);
                  }
                }
                break;
            }
          }
        };
      }, 743: (e2, r2, t2) => {
        const n = t2(126);
        const a = t2(900);
        const i = t2(253);
        const s = t2(111);
        const { includes: o, isBoolean: u, isInteger: l, isNumber: c, isPlainObject: f, isString: h, once: p } = t2(788);
        const { KeyObject: d, createSecretKey: y, createPrivateKey: g } = t2(113);
        const v = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
        if (a) {
          v.splice(3, 0, "PS256", "PS384", "PS512");
        }
        const b = { expiresIn: { isValid: function(e3) {
          return l(e3) || h(e3) && e3;
        }, message: '"expiresIn" should be a number of seconds or string representing a timespan' }, notBefore: { isValid: function(e3) {
          return l(e3) || h(e3) && e3;
        }, message: '"notBefore" should be a number of seconds or string representing a timespan' }, audience: { isValid: function(e3) {
          return h(e3) || Array.isArray(e3);
        }, message: '"audience" must be a string or array' }, algorithm: { isValid: o.bind(null, v), message: '"algorithm" must be a valid string enum value' }, header: { isValid: f, message: '"header" must be an object' }, encoding: { isValid: h, message: '"encoding" must be a string' }, issuer: { isValid: h, message: '"issuer" must be a string' }, subject: { isValid: h, message: '"subject" must be a string' }, jwtid: { isValid: h, message: '"jwtid" must be a string' }, noTimestamp: { isValid: u, message: '"noTimestamp" must be a boolean' }, keyid: { isValid: h, message: '"keyid" must be a string' }, mutatePayload: { isValid: u, message: '"mutatePayload" must be a boolean' }, allowInsecureKeySizes: { isValid: u, message: '"allowInsecureKeySizes" must be a boolean' }, allowInvalidAsymmetricKeyTypes: { isValid: u, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' } };
        const m = { iat: { isValid: c, message: '"iat" should be a number of seconds' }, exp: { isValid: c, message: '"exp" should be a number of seconds' }, nbf: { isValid: c, message: '"nbf" should be a number of seconds' } };
        function validate(e3, r3, t3, n2) {
          if (!f(t3)) {
            throw new Error('Expected "' + n2 + '" to be a plain object.');
          }
          Object.keys(t3).forEach(function(a2) {
            const i2 = e3[a2];
            if (!i2) {
              if (!r3) {
                throw new Error('"' + a2 + '" is not allowed in "' + n2 + '"');
              }
              return;
            }
            if (!i2.isValid(t3[a2])) {
              throw new Error(i2.message);
            }
          });
        }
        function validateOptions(e3) {
          return validate(b, false, e3, "options");
        }
        function validatePayload(e3) {
          return validate(m, true, e3, "payload");
        }
        const _ = { audience: "aud", issuer: "iss", subject: "sub", jwtid: "jti" };
        const w = ["expiresIn", "notBefore", "noTimestamp", "audience", "issuer", "subject", "jwtid"];
        e2.exports = function(e3, r3, t3, a2) {
          if (typeof t3 === "function") {
            a2 = t3;
            t3 = {};
          } else {
            t3 = t3 || {};
          }
          const o2 = typeof e3 === "object" && !Buffer.isBuffer(e3);
          const u2 = Object.assign({ alg: t3.algorithm || "HS256", typ: o2 ? "JWT" : void 0, kid: t3.keyid }, t3.header);
          function failure(e4) {
            if (a2) {
              return a2(e4);
            }
            throw e4;
          }
          if (!r3 && t3.algorithm !== "none") {
            return failure(new Error("secretOrPrivateKey must have a value"));
          }
          if (r3 != null && !(r3 instanceof d)) {
            try {
              r3 = g(r3);
            } catch (e4) {
              try {
                r3 = y(typeof r3 === "string" ? Buffer.from(r3) : r3);
              } catch (e5) {
                return failure(new Error("secretOrPrivateKey is not valid key material"));
              }
            }
          }
          if (u2.alg.startsWith("HS") && r3.type !== "secret") {
            return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${u2.alg}`));
          } else if (/^(?:RS|PS|ES)/.test(u2.alg)) {
            if (r3.type !== "private") {
              return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${u2.alg}`));
            }
            if (!t3.allowInsecureKeySizes && !u2.alg.startsWith("ES") && r3.asymmetricKeyDetails !== void 0 && r3.asymmetricKeyDetails.modulusLength < 2048) {
              return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${u2.alg}`));
            }
          }
          if (typeof e3 === "undefined") {
            return failure(new Error("payload is required"));
          } else if (o2) {
            try {
              validatePayload(e3);
            } catch (e4) {
              return failure(e4);
            }
            if (!t3.mutatePayload) {
              e3 = Object.assign({}, e3);
            }
          } else {
            const r4 = w.filter(function(e4) {
              return typeof t3[e4] !== "undefined";
            });
            if (r4.length > 0) {
              return failure(new Error("invalid " + r4.join(",") + " option for " + typeof e3 + " payload"));
            }
          }
          if (typeof e3.exp !== "undefined" && typeof t3.expiresIn !== "undefined") {
            return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
          }
          if (typeof e3.nbf !== "undefined" && typeof t3.notBefore !== "undefined") {
            return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
          }
          try {
            validateOptions(t3);
          } catch (e4) {
            return failure(e4);
          }
          if (!t3.allowInvalidAsymmetricKeyTypes) {
            try {
              i(u2.alg, r3);
            } catch (e4) {
              return failure(e4);
            }
          }
          const l2 = e3.iat || Math.floor(Date.now() / 1e3);
          if (t3.noTimestamp) {
            delete e3.iat;
          } else if (o2) {
            e3.iat = l2;
          }
          if (typeof t3.notBefore !== "undefined") {
            try {
              e3.nbf = n(t3.notBefore, l2);
            } catch (e4) {
              return failure(e4);
            }
            if (typeof e3.nbf === "undefined") {
              return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
            }
          }
          if (typeof t3.expiresIn !== "undefined" && typeof e3 === "object") {
            try {
              e3.exp = n(t3.expiresIn, l2);
            } catch (e4) {
              return failure(e4);
            }
            if (typeof e3.exp === "undefined") {
              return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
            }
          }
          Object.keys(_).forEach(function(r4) {
            const n2 = _[r4];
            if (typeof t3[r4] !== "undefined") {
              if (typeof e3[n2] !== "undefined") {
                return failure(new Error('Bad "options.' + r4 + '" option. The payload already has an "' + n2 + '" property.'));
              }
              e3[n2] = t3[r4];
            }
          });
          const c2 = t3.encoding || "utf8";
          if (typeof a2 === "function") {
            a2 = a2 && p(a2);
            s.createSign({ header: u2, privateKey: r3, payload: e3, encoding: c2 }).once("error", a2).once("done", function(e4) {
              if (!t3.allowInsecureKeySizes && /^(?:RS|PS)/.test(u2.alg) && e4.length < 256) {
                return a2(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${u2.alg}`));
              }
              a2(null, e4);
            });
          } else {
            let n2 = s.sign({ header: u2, payload: e3, secret: r3, encoding: c2 });
            if (!t3.allowInsecureKeySizes && /^(?:RS|PS)/.test(u2.alg) && n2.length < 256) {
              throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${u2.alg}`);
            }
            return n2;
          }
        };
      }, 624: (e2, r2, t2) => {
        const n = t2(131);
        const a = t2(422);
        const i = t2(794);
        const s = t2(443);
        const o = t2(126);
        const u = t2(253);
        const l = t2(900);
        const c = t2(111);
        const { KeyObject: f, createSecretKey: h, createPublicKey: p } = t2(113);
        const d = ["RS256", "RS384", "RS512"];
        const y = ["ES256", "ES384", "ES512"];
        const g = ["RS256", "RS384", "RS512"];
        const v = ["HS256", "HS384", "HS512"];
        if (l) {
          d.splice(d.length, 0, "PS256", "PS384", "PS512");
          g.splice(g.length, 0, "PS256", "PS384", "PS512");
        }
        e2.exports = function(e3, r3, t3, l2) {
          if (typeof t3 === "function" && !l2) {
            l2 = t3;
            t3 = {};
          }
          if (!t3) {
            t3 = {};
          }
          t3 = Object.assign({}, t3);
          let b;
          if (l2) {
            b = l2;
          } else {
            b = function(e4, r4) {
              if (e4)
                throw e4;
              return r4;
            };
          }
          if (t3.clockTimestamp && typeof t3.clockTimestamp !== "number") {
            return b(new n("clockTimestamp must be a number"));
          }
          if (t3.nonce !== void 0 && (typeof t3.nonce !== "string" || t3.nonce.trim() === "")) {
            return b(new n("nonce must be a non-empty string"));
          }
          if (t3.allowInvalidAsymmetricKeyTypes !== void 0 && typeof t3.allowInvalidAsymmetricKeyTypes !== "boolean") {
            return b(new n("allowInvalidAsymmetricKeyTypes must be a boolean"));
          }
          const m = t3.clockTimestamp || Math.floor(Date.now() / 1e3);
          if (!e3) {
            return b(new n("jwt must be provided"));
          }
          if (typeof e3 !== "string") {
            return b(new n("jwt must be a string"));
          }
          const _ = e3.split(".");
          if (_.length !== 3) {
            return b(new n("jwt malformed"));
          }
          let w;
          try {
            w = s(e3, { complete: true });
          } catch (e4) {
            return b(e4);
          }
          if (!w) {
            return b(new n("invalid token"));
          }
          const S = w.header;
          let I;
          if (typeof r3 === "function") {
            if (!l2) {
              return b(new n("verify must be called asynchronous if secret or public key is provided as a callback"));
            }
            I = r3;
          } else {
            I = function(e4, t4) {
              return t4(null, r3);
            };
          }
          return I(S, function(r4, s2) {
            if (r4) {
              return b(new n("error in secret or public key callback: " + r4.message));
            }
            const l3 = _[2].trim() !== "";
            if (!l3 && s2) {
              return b(new n("jwt signature is required"));
            }
            if (l3 && !s2) {
              return b(new n("secret or public key must be provided"));
            }
            if (!l3 && !t3.algorithms) {
              return b(new n('please specify "none" in "algorithms" to verify unsigned tokens'));
            }
            if (s2 != null && !(s2 instanceof f)) {
              try {
                s2 = p(s2);
              } catch (e4) {
                try {
                  s2 = h(typeof s2 === "string" ? Buffer.from(s2) : s2);
                } catch (e5) {
                  return b(new n("secretOrPublicKey is not valid key material"));
                }
              }
            }
            if (!t3.algorithms) {
              if (s2.type === "secret") {
                t3.algorithms = v;
              } else if (["rsa", "rsa-pss"].includes(s2.asymmetricKeyType)) {
                t3.algorithms = g;
              } else if (s2.asymmetricKeyType === "ec") {
                t3.algorithms = y;
              } else {
                t3.algorithms = d;
              }
            }
            if (t3.algorithms.indexOf(w.header.alg) === -1) {
              return b(new n("invalid algorithm"));
            }
            if (S.alg.startsWith("HS") && s2.type !== "secret") {
              return b(new n(`secretOrPublicKey must be a symmetric key when using ${S.alg}`));
            } else if (/^(?:RS|PS|ES)/.test(S.alg) && s2.type !== "public") {
              return b(new n(`secretOrPublicKey must be an asymmetric key when using ${S.alg}`));
            }
            if (!t3.allowInvalidAsymmetricKeyTypes) {
              try {
                u(S.alg, s2);
              } catch (e4) {
                return b(e4);
              }
            }
            let I2;
            try {
              I2 = c.verify(e3, w.header.alg, s2);
            } catch (e4) {
              return b(e4);
            }
            if (!I2) {
              return b(new n("invalid signature"));
            }
            const A = w.payload;
            if (typeof A.nbf !== "undefined" && !t3.ignoreNotBefore) {
              if (typeof A.nbf !== "number") {
                return b(new n("invalid nbf value"));
              }
              if (A.nbf > m + (t3.clockTolerance || 0)) {
                return b(new a("jwt not active", new Date(A.nbf * 1e3)));
              }
            }
            if (typeof A.exp !== "undefined" && !t3.ignoreExpiration) {
              if (typeof A.exp !== "number") {
                return b(new n("invalid exp value"));
              }
              if (m >= A.exp + (t3.clockTolerance || 0)) {
                return b(new i("jwt expired", new Date(A.exp * 1e3)));
              }
            }
            if (t3.audience) {
              const e4 = Array.isArray(t3.audience) ? t3.audience : [t3.audience];
              const r5 = Array.isArray(A.aud) ? A.aud : [A.aud];
              const a2 = r5.some(function(r6) {
                return e4.some(function(e5) {
                  return e5 instanceof RegExp ? e5.test(r6) : e5 === r6;
                });
              });
              if (!a2) {
                return b(new n("jwt audience invalid. expected: " + e4.join(" or ")));
              }
            }
            if (t3.issuer) {
              const e4 = typeof t3.issuer === "string" && A.iss !== t3.issuer || Array.isArray(t3.issuer) && t3.issuer.indexOf(A.iss) === -1;
              if (e4) {
                return b(new n("jwt issuer invalid. expected: " + t3.issuer));
              }
            }
            if (t3.subject) {
              if (A.sub !== t3.subject) {
                return b(new n("jwt subject invalid. expected: " + t3.subject));
              }
            }
            if (t3.jwtid) {
              if (A.jti !== t3.jwtid) {
                return b(new n("jwt jwtid invalid. expected: " + t3.jwtid));
              }
            }
            if (t3.nonce) {
              if (A.nonce !== t3.nonce) {
                return b(new n("jwt nonce invalid. expected: " + t3.nonce));
              }
            }
            if (t3.maxAge) {
              if (typeof A.iat !== "number") {
                return b(new n("iat required when maxAge is specified"));
              }
              const e4 = o(t3.maxAge, A.iat);
              if (typeof e4 === "undefined") {
                return b(new n('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
              }
              if (m >= e4 + (t3.clockTolerance || 0)) {
                return b(new i("maxAge exceeded", new Date(e4 * 1e3)));
              }
            }
            if (t3.complete === true) {
              const e4 = w.signature;
              return b(null, { header: S, payload: A, signature: e4 });
            }
            return b(null, A);
          });
        };
      }, 251: (e2, r2, t2) => {
        var n = t2(112);
        var a = t2(911).Buffer;
        var i = t2(113);
        var s = t2(160);
        var o = t2(837);
        var u = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
        var l = "secret must be a string or buffer";
        var c = "key must be a string or a buffer";
        var f = "key must be a string, a buffer or an object";
        var h = typeof i.createPublicKey === "function";
        if (h) {
          c += " or a KeyObject";
          l += "or a KeyObject";
        }
        function checkIsPublicKey(e3) {
          if (a.isBuffer(e3)) {
            return;
          }
          if (typeof e3 === "string") {
            return;
          }
          if (!h) {
            throw typeError(c);
          }
          if (typeof e3 !== "object") {
            throw typeError(c);
          }
          if (typeof e3.type !== "string") {
            throw typeError(c);
          }
          if (typeof e3.asymmetricKeyType !== "string") {
            throw typeError(c);
          }
          if (typeof e3.export !== "function") {
            throw typeError(c);
          }
        }
        function checkIsPrivateKey(e3) {
          if (a.isBuffer(e3)) {
            return;
          }
          if (typeof e3 === "string") {
            return;
          }
          if (typeof e3 === "object") {
            return;
          }
          throw typeError(f);
        }
        function checkIsSecretKey(e3) {
          if (a.isBuffer(e3)) {
            return;
          }
          if (typeof e3 === "string") {
            return e3;
          }
          if (!h) {
            throw typeError(l);
          }
          if (typeof e3 !== "object") {
            throw typeError(l);
          }
          if (e3.type !== "secret") {
            throw typeError(l);
          }
          if (typeof e3.export !== "function") {
            throw typeError(l);
          }
        }
        function fromBase64(e3) {
          return e3.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        function toBase64(e3) {
          e3 = e3.toString();
          var r3 = 4 - e3.length % 4;
          if (r3 !== 4) {
            for (var t3 = 0; t3 < r3; ++t3) {
              e3 += "=";
            }
          }
          return e3.replace(/\-/g, "+").replace(/_/g, "/");
        }
        function typeError(e3) {
          var r3 = [].slice.call(arguments, 1);
          var t3 = o.format.bind(o, e3).apply(null, r3);
          return new TypeError(t3);
        }
        function bufferOrString(e3) {
          return a.isBuffer(e3) || typeof e3 === "string";
        }
        function normalizeInput(e3) {
          if (!bufferOrString(e3))
            e3 = JSON.stringify(e3);
          return e3;
        }
        function createHmacSigner(e3) {
          return function sign(r3, t3) {
            checkIsSecretKey(t3);
            r3 = normalizeInput(r3);
            var n2 = i.createHmac("sha" + e3, t3);
            var a2 = (n2.update(r3), n2.digest("base64"));
            return fromBase64(a2);
          };
        }
        function createHmacVerifier(e3) {
          return function verify(r3, t3, i2) {
            var s2 = createHmacSigner(e3)(r3, i2);
            return n(a.from(t3), a.from(s2));
          };
        }
        function createKeySigner(e3) {
          return function sign(r3, t3) {
            checkIsPrivateKey(t3);
            r3 = normalizeInput(r3);
            var n2 = i.createSign("RSA-SHA" + e3);
            var a2 = (n2.update(r3), n2.sign(t3, "base64"));
            return fromBase64(a2);
          };
        }
        function createKeyVerifier(e3) {
          return function verify(r3, t3, n2) {
            checkIsPublicKey(n2);
            r3 = normalizeInput(r3);
            t3 = toBase64(t3);
            var a2 = i.createVerify("RSA-SHA" + e3);
            a2.update(r3);
            return a2.verify(n2, t3, "base64");
          };
        }
        function createPSSKeySigner(e3) {
          return function sign(r3, t3) {
            checkIsPrivateKey(t3);
            r3 = normalizeInput(r3);
            var n2 = i.createSign("RSA-SHA" + e3);
            var a2 = (n2.update(r3), n2.sign({ key: t3, padding: i.constants.RSA_PKCS1_PSS_PADDING, saltLength: i.constants.RSA_PSS_SALTLEN_DIGEST }, "base64"));
            return fromBase64(a2);
          };
        }
        function createPSSKeyVerifier(e3) {
          return function verify(r3, t3, n2) {
            checkIsPublicKey(n2);
            r3 = normalizeInput(r3);
            t3 = toBase64(t3);
            var a2 = i.createVerify("RSA-SHA" + e3);
            a2.update(r3);
            return a2.verify({ key: n2, padding: i.constants.RSA_PKCS1_PSS_PADDING, saltLength: i.constants.RSA_PSS_SALTLEN_DIGEST }, t3, "base64");
          };
        }
        function createECDSASigner(e3) {
          var r3 = createKeySigner(e3);
          return function sign() {
            var t3 = r3.apply(null, arguments);
            t3 = s.derToJose(t3, "ES" + e3);
            return t3;
          };
        }
        function createECDSAVerifer(e3) {
          var r3 = createKeyVerifier(e3);
          return function verify(t3, n2, a2) {
            n2 = s.joseToDer(n2, "ES" + e3).toString("base64");
            var i2 = r3(t3, n2, a2);
            return i2;
          };
        }
        function createNoneSigner() {
          return function sign() {
            return "";
          };
        }
        function createNoneVerifier() {
          return function verify(e3, r3) {
            return r3 === "";
          };
        }
        e2.exports = function jwa(e3) {
          var r3 = { hs: createHmacSigner, rs: createKeySigner, ps: createPSSKeySigner, es: createECDSASigner, none: createNoneSigner };
          var t3 = { hs: createHmacVerifier, rs: createKeyVerifier, ps: createPSSKeyVerifier, es: createECDSAVerifer, none: createNoneVerifier };
          var n2 = e3.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
          if (!n2)
            throw typeError(u, e3);
          var a2 = (n2[1] || n2[3]).toLowerCase();
          var i2 = n2[2];
          return { sign: r3[a2](i2), verify: t3[a2](i2) };
        };
      }, 111: (e2, r2, t2) => {
        var n = t2(409);
        var a = t2(851);
        var i = ["HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512"];
        r2.ALGORITHMS = i;
        r2.sign = n.sign;
        r2.verify = a.verify;
        r2.decode = a.decode;
        r2.isValid = a.isValid;
        r2.createSign = function createSign(e3) {
          return new n(e3);
        };
        r2.createVerify = function createVerify(e3) {
          return new a(e3);
        };
      }, 626: (e2, r2, t2) => {
        var n = t2(911).Buffer;
        var a = t2(781);
        var i = t2(837);
        function DataStream(e3) {
          this.buffer = null;
          this.writable = true;
          this.readable = true;
          if (!e3) {
            this.buffer = n.alloc(0);
            return this;
          }
          if (typeof e3.pipe === "function") {
            this.buffer = n.alloc(0);
            e3.pipe(this);
            return this;
          }
          if (e3.length || typeof e3 === "object") {
            this.buffer = e3;
            this.writable = false;
            process.nextTick(function() {
              this.emit("end", e3);
              this.readable = false;
              this.emit("close");
            }.bind(this));
            return this;
          }
          throw new TypeError("Unexpected data type (" + typeof e3 + ")");
        }
        i.inherits(DataStream, a);
        DataStream.prototype.write = function write(e3) {
          this.buffer = n.concat([this.buffer, n.from(e3)]);
          this.emit("data", e3);
        };
        DataStream.prototype.end = function end(e3) {
          if (e3)
            this.write(e3);
          this.emit("end", e3);
          this.emit("close");
          this.writable = false;
          this.readable = false;
        };
        e2.exports = DataStream;
      }, 409: (e2, r2, t2) => {
        var n = t2(911).Buffer;
        var a = t2(626);
        var i = t2(251);
        var s = t2(781);
        var o = t2(730);
        var u = t2(837);
        function base64url(e3, r3) {
          return n.from(e3, r3).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        }
        function jwsSecuredInput(e3, r3, t3) {
          t3 = t3 || "utf8";
          var n2 = base64url(o(e3), "binary");
          var a2 = base64url(o(r3), t3);
          return u.format("%s.%s", n2, a2);
        }
        function jwsSign(e3) {
          var r3 = e3.header;
          var t3 = e3.payload;
          var n2 = e3.secret || e3.privateKey;
          var a2 = e3.encoding;
          var s2 = i(r3.alg);
          var o2 = jwsSecuredInput(r3, t3, a2);
          var l = s2.sign(o2, n2);
          return u.format("%s.%s", o2, l);
        }
        function SignStream(e3) {
          var r3 = e3.secret || e3.privateKey || e3.key;
          var t3 = new a(r3);
          this.readable = true;
          this.header = e3.header;
          this.encoding = e3.encoding;
          this.secret = this.privateKey = this.key = t3;
          this.payload = new a(e3.payload);
          this.secret.once("close", function() {
            if (!this.payload.writable && this.readable)
              this.sign();
          }.bind(this));
          this.payload.once("close", function() {
            if (!this.secret.writable && this.readable)
              this.sign();
          }.bind(this));
        }
        u.inherits(SignStream, s);
        SignStream.prototype.sign = function sign() {
          try {
            var e3 = jwsSign({ header: this.header, payload: this.payload.buffer, secret: this.secret.buffer, encoding: this.encoding });
            this.emit("done", e3);
            this.emit("data", e3);
            this.emit("end");
            this.readable = false;
            return e3;
          } catch (e4) {
            this.readable = false;
            this.emit("error", e4);
            this.emit("close");
          }
        };
        SignStream.sign = jwsSign;
        e2.exports = SignStream;
      }, 730: (e2, r2, t2) => {
        var n = t2(300).Buffer;
        e2.exports = function toString(e3) {
          if (typeof e3 === "string")
            return e3;
          if (typeof e3 === "number" || n.isBuffer(e3))
            return e3.toString();
          return JSON.stringify(e3);
        };
      }, 851: (e2, r2, t2) => {
        var n = t2(911).Buffer;
        var a = t2(626);
        var i = t2(251);
        var s = t2(781);
        var o = t2(730);
        var u = t2(837);
        var l = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
        function isObject(e3) {
          return Object.prototype.toString.call(e3) === "[object Object]";
        }
        function safeJsonParse(e3) {
          if (isObject(e3))
            return e3;
          try {
            return JSON.parse(e3);
          } catch (e4) {
            return void 0;
          }
        }
        function headerFromJWS(e3) {
          var r3 = e3.split(".", 1)[0];
          return safeJsonParse(n.from(r3, "base64").toString("binary"));
        }
        function securedInputFromJWS(e3) {
          return e3.split(".", 2).join(".");
        }
        function signatureFromJWS(e3) {
          return e3.split(".")[2];
        }
        function payloadFromJWS(e3, r3) {
          r3 = r3 || "utf8";
          var t3 = e3.split(".")[1];
          return n.from(t3, "base64").toString(r3);
        }
        function isValidJws(e3) {
          return l.test(e3) && !!headerFromJWS(e3);
        }
        function jwsVerify(e3, r3, t3) {
          if (!r3) {
            var n2 = new Error("Missing algorithm parameter for jws.verify");
            n2.code = "MISSING_ALGORITHM";
            throw n2;
          }
          e3 = o(e3);
          var a2 = signatureFromJWS(e3);
          var s2 = securedInputFromJWS(e3);
          var u2 = i(r3);
          return u2.verify(s2, a2, t3);
        }
        function jwsDecode(e3, r3) {
          r3 = r3 || {};
          e3 = o(e3);
          if (!isValidJws(e3))
            return null;
          var t3 = headerFromJWS(e3);
          if (!t3)
            return null;
          var n2 = payloadFromJWS(e3);
          if (t3.typ === "JWT" || r3.json)
            n2 = JSON.parse(n2, r3.encoding);
          return { header: t3, payload: n2, signature: signatureFromJWS(e3) };
        }
        function VerifyStream(e3) {
          e3 = e3 || {};
          var r3 = e3.secret || e3.publicKey || e3.key;
          var t3 = new a(r3);
          this.readable = true;
          this.algorithm = e3.algorithm;
          this.encoding = e3.encoding;
          this.secret = this.publicKey = this.key = t3;
          this.signature = new a(e3.signature);
          this.secret.once("close", function() {
            if (!this.signature.writable && this.readable)
              this.verify();
          }.bind(this));
          this.signature.once("close", function() {
            if (!this.secret.writable && this.readable)
              this.verify();
          }.bind(this));
        }
        u.inherits(VerifyStream, s);
        VerifyStream.prototype.verify = function verify() {
          try {
            var e3 = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
            var r3 = jwsDecode(this.signature.buffer, this.encoding);
            this.emit("done", e3, r3);
            this.emit("data", e3);
            this.emit("end");
            this.readable = false;
            return e3;
          } catch (e4) {
            this.readable = false;
            this.emit("error", e4);
            this.emit("close");
          }
        };
        VerifyStream.decode = jwsDecode;
        VerifyStream.isValid = isValidJws;
        VerifyStream.verify = jwsVerify;
        e2.exports = VerifyStream;
      }, 788: function(e2, r2, t2) {
        e2 = t2.nmd(e2);
        (function() {
          var t3;
          var n = "4.17.21";
          var a = 200;
          var i = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", s = "Expected a function", o = "Invalid `variable` option passed into `_.template`";
          var u = "__lodash_hash_undefined__";
          var l = 500;
          var c = "__lodash_placeholder__";
          var f = 1, h = 2, p = 4;
          var d = 1, y = 2;
          var g = 1, v = 2, b = 4, m = 8, _ = 16, w = 32, S = 64, I = 128, A = 256, x = 512;
          var k = 30, j = "...";
          var O = 800, E = 16;
          var R = 1, L = 2, C = 3;
          var T = 1 / 0, W = 9007199254740991, P = 17976931348623157e292, z = 0 / 0;
          var B = 4294967295, F = B - 1, M = B >>> 1;
          var D = [["ary", I], ["bind", g], ["bindKey", v], ["curry", m], ["curryRight", _], ["flip", x], ["partial", w], ["partialRight", S], ["rearg", A]];
          var K = "[object Arguments]", q = "[object Array]", V = "[object AsyncFunction]", U = "[object Boolean]", N = "[object Date]", H = "[object DOMException]", G = "[object Error]", $ = "[object Function]", J = "[object GeneratorFunction]", Z = "[object Map]", X = "[object Number]", Y = "[object Null]", Q = "[object Object]", ee = "[object Promise]", re = "[object Proxy]", te = "[object RegExp]", ne = "[object Set]", ae = "[object String]", ie = "[object Symbol]", se = "[object Undefined]", oe = "[object WeakMap]", ue = "[object WeakSet]";
          var le = "[object ArrayBuffer]", ce = "[object DataView]", fe = "[object Float32Array]", he = "[object Float64Array]", pe = "[object Int8Array]", de = "[object Int16Array]", ye = "[object Int32Array]", ge = "[object Uint8Array]", ve = "[object Uint8ClampedArray]", be = "[object Uint16Array]", me = "[object Uint32Array]";
          var _e = /\b__p \+= '';/g, we = /\b(__p \+=) '' \+/g, Se = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
          var Ie = /&(?:amp|lt|gt|quot|#39);/g, Ae = /[&<>"']/g, xe = RegExp(Ie.source), ke = RegExp(Ae.source);
          var je = /<%-([\s\S]+?)%>/g, Oe = /<%([\s\S]+?)%>/g, Ee = /<%=([\s\S]+?)%>/g;
          var Re = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Le = /^\w*$/, Ce = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
          var Te = /[\\^$.*+?()[\]{}|]/g, We = RegExp(Te.source);
          var Pe = /^\s+/;
          var ze = /\s/;
          var Be = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Fe = /\{\n\/\* \[wrapped with (.+)\] \*/, Me = /,? & /;
          var De = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
          var Ke = /[()=,{}\[\]\/\s]/;
          var qe = /\\(\\)?/g;
          var Ve = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
          var Ue = /\w*$/;
          var Ne = /^[-+]0x[0-9a-f]+$/i;
          var He = /^0b[01]+$/i;
          var Ge = /^\[object .+?Constructor\]$/;
          var $e = /^0o[0-7]+$/i;
          var Je = /^(?:0|[1-9]\d*)$/;
          var Ze = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
          var Xe = /($^)/;
          var Ye = /['\n\r\u2028\u2029\\]/g;
          var Qe = "\\ud800-\\udfff", er = "\\u0300-\\u036f", rr = "\\ufe20-\\ufe2f", tr = "\\u20d0-\\u20ff", nr = er + rr + tr, ar = "\\u2700-\\u27bf", ir = "a-z\\xdf-\\xf6\\xf8-\\xff", sr = "\\xac\\xb1\\xd7\\xf7", or = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", ur = "\\u2000-\\u206f", lr = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", cr = "A-Z\\xc0-\\xd6\\xd8-\\xde", fr = "\\ufe0e\\ufe0f", hr = sr + or + ur + lr;
          var pr = "['\u2019]", dr = "[" + Qe + "]", yr = "[" + hr + "]", gr = "[" + nr + "]", vr = "\\d+", br = "[" + ar + "]", mr = "[" + ir + "]", _r = "[^" + Qe + hr + vr + ar + ir + cr + "]", wr = "\\ud83c[\\udffb-\\udfff]", Sr = "(?:" + gr + "|" + wr + ")", Ir = "[^" + Qe + "]", Ar = "(?:\\ud83c[\\udde6-\\uddff]){2}", xr = "[\\ud800-\\udbff][\\udc00-\\udfff]", kr = "[" + cr + "]", jr = "\\u200d";
          var Or = "(?:" + mr + "|" + _r + ")", Er = "(?:" + kr + "|" + _r + ")", Rr = "(?:" + pr + "(?:d|ll|m|re|s|t|ve))?", Lr = "(?:" + pr + "(?:D|LL|M|RE|S|T|VE))?", Cr = Sr + "?", Tr = "[" + fr + "]?", Wr = "(?:" + jr + "(?:" + [Ir, Ar, xr].join("|") + ")" + Tr + Cr + ")*", Pr = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", zr = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", Br = Tr + Cr + Wr, Fr = "(?:" + [br, Ar, xr].join("|") + ")" + Br, Mr = "(?:" + [Ir + gr + "?", gr, Ar, xr, dr].join("|") + ")";
          var Dr = RegExp(pr, "g");
          var Kr = RegExp(gr, "g");
          var qr = RegExp(wr + "(?=" + wr + ")|" + Mr + Br, "g");
          var Vr = RegExp([kr + "?" + mr + "+" + Rr + "(?=" + [yr, kr, "$"].join("|") + ")", Er + "+" + Lr + "(?=" + [yr, kr + Or, "$"].join("|") + ")", kr + "?" + Or + "+" + Rr, kr + "+" + Lr, zr, Pr, vr, Fr].join("|"), "g");
          var Ur = RegExp("[" + jr + Qe + nr + fr + "]");
          var Nr = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
          var Hr = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"];
          var Gr = -1;
          var $r = {};
          $r[fe] = $r[he] = $r[pe] = $r[de] = $r[ye] = $r[ge] = $r[ve] = $r[be] = $r[me] = true;
          $r[K] = $r[q] = $r[le] = $r[U] = $r[ce] = $r[N] = $r[G] = $r[$] = $r[Z] = $r[X] = $r[Q] = $r[te] = $r[ne] = $r[ae] = $r[oe] = false;
          var Jr = {};
          Jr[K] = Jr[q] = Jr[le] = Jr[ce] = Jr[U] = Jr[N] = Jr[fe] = Jr[he] = Jr[pe] = Jr[de] = Jr[ye] = Jr[Z] = Jr[X] = Jr[Q] = Jr[te] = Jr[ne] = Jr[ae] = Jr[ie] = Jr[ge] = Jr[ve] = Jr[be] = Jr[me] = true;
          Jr[G] = Jr[$] = Jr[oe] = false;
          var Zr = { "\xC0": "A", "\xC1": "A", "\xC2": "A", "\xC3": "A", "\xC4": "A", "\xC5": "A", "\xE0": "a", "\xE1": "a", "\xE2": "a", "\xE3": "a", "\xE4": "a", "\xE5": "a", "\xC7": "C", "\xE7": "c", "\xD0": "D", "\xF0": "d", "\xC8": "E", "\xC9": "E", "\xCA": "E", "\xCB": "E", "\xE8": "e", "\xE9": "e", "\xEA": "e", "\xEB": "e", "\xCC": "I", "\xCD": "I", "\xCE": "I", "\xCF": "I", "\xEC": "i", "\xED": "i", "\xEE": "i", "\xEF": "i", "\xD1": "N", "\xF1": "n", "\xD2": "O", "\xD3": "O", "\xD4": "O", "\xD5": "O", "\xD6": "O", "\xD8": "O", "\xF2": "o", "\xF3": "o", "\xF4": "o", "\xF5": "o", "\xF6": "o", "\xF8": "o", "\xD9": "U", "\xDA": "U", "\xDB": "U", "\xDC": "U", "\xF9": "u", "\xFA": "u", "\xFB": "u", "\xFC": "u", "\xDD": "Y", "\xFD": "y", "\xFF": "y", "\xC6": "Ae", "\xE6": "ae", "\xDE": "Th", "\xFE": "th", "\xDF": "ss", "\u0100": "A", "\u0102": "A", "\u0104": "A", "\u0101": "a", "\u0103": "a", "\u0105": "a", "\u0106": "C", "\u0108": "C", "\u010A": "C", "\u010C": "C", "\u0107": "c", "\u0109": "c", "\u010B": "c", "\u010D": "c", "\u010E": "D", "\u0110": "D", "\u010F": "d", "\u0111": "d", "\u0112": "E", "\u0114": "E", "\u0116": "E", "\u0118": "E", "\u011A": "E", "\u0113": "e", "\u0115": "e", "\u0117": "e", "\u0119": "e", "\u011B": "e", "\u011C": "G", "\u011E": "G", "\u0120": "G", "\u0122": "G", "\u011D": "g", "\u011F": "g", "\u0121": "g", "\u0123": "g", "\u0124": "H", "\u0126": "H", "\u0125": "h", "\u0127": "h", "\u0128": "I", "\u012A": "I", "\u012C": "I", "\u012E": "I", "\u0130": "I", "\u0129": "i", "\u012B": "i", "\u012D": "i", "\u012F": "i", "\u0131": "i", "\u0134": "J", "\u0135": "j", "\u0136": "K", "\u0137": "k", "\u0138": "k", "\u0139": "L", "\u013B": "L", "\u013D": "L", "\u013F": "L", "\u0141": "L", "\u013A": "l", "\u013C": "l", "\u013E": "l", "\u0140": "l", "\u0142": "l", "\u0143": "N", "\u0145": "N", "\u0147": "N", "\u014A": "N", "\u0144": "n", "\u0146": "n", "\u0148": "n", "\u014B": "n", "\u014C": "O", "\u014E": "O", "\u0150": "O", "\u014D": "o", "\u014F": "o", "\u0151": "o", "\u0154": "R", "\u0156": "R", "\u0158": "R", "\u0155": "r", "\u0157": "r", "\u0159": "r", "\u015A": "S", "\u015C": "S", "\u015E": "S", "\u0160": "S", "\u015B": "s", "\u015D": "s", "\u015F": "s", "\u0161": "s", "\u0162": "T", "\u0164": "T", "\u0166": "T", "\u0163": "t", "\u0165": "t", "\u0167": "t", "\u0168": "U", "\u016A": "U", "\u016C": "U", "\u016E": "U", "\u0170": "U", "\u0172": "U", "\u0169": "u", "\u016B": "u", "\u016D": "u", "\u016F": "u", "\u0171": "u", "\u0173": "u", "\u0174": "W", "\u0175": "w", "\u0176": "Y", "\u0177": "y", "\u0178": "Y", "\u0179": "Z", "\u017B": "Z", "\u017D": "Z", "\u017A": "z", "\u017C": "z", "\u017E": "z", "\u0132": "IJ", "\u0133": "ij", "\u0152": "Oe", "\u0153": "oe", "\u0149": "'n", "\u017F": "s" };
          var Xr = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
          var Yr = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" };
          var Qr = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" };
          var et = parseFloat, rt = parseInt;
          var tt = typeof global == "object" && global && global.Object === Object && global;
          var nt = typeof self == "object" && self && self.Object === Object && self;
          var at = tt || nt || Function("return this")();
          var it = r2 && !r2.nodeType && r2;
          var st = it && true && e2 && !e2.nodeType && e2;
          var ot = st && st.exports === it;
          var ut = ot && tt.process;
          var lt = function() {
            try {
              var e3 = st && st.require && st.require("util").types;
              if (e3) {
                return e3;
              }
              return ut && ut.binding && ut.binding("util");
            } catch (e4) {
            }
          }();
          var ct = lt && lt.isArrayBuffer, ft = lt && lt.isDate, ht = lt && lt.isMap, pt = lt && lt.isRegExp, dt = lt && lt.isSet, yt = lt && lt.isTypedArray;
          function apply(e3, r3, t4) {
            switch (t4.length) {
              case 0:
                return e3.call(r3);
              case 1:
                return e3.call(r3, t4[0]);
              case 2:
                return e3.call(r3, t4[0], t4[1]);
              case 3:
                return e3.call(r3, t4[0], t4[1], t4[2]);
            }
            return e3.apply(r3, t4);
          }
          function arrayAggregator(e3, r3, t4, n2) {
            var a2 = -1, i2 = e3 == null ? 0 : e3.length;
            while (++a2 < i2) {
              var s2 = e3[a2];
              r3(n2, s2, t4(s2), e3);
            }
            return n2;
          }
          function arrayEach(e3, r3) {
            var t4 = -1, n2 = e3 == null ? 0 : e3.length;
            while (++t4 < n2) {
              if (r3(e3[t4], t4, e3) === false) {
                break;
              }
            }
            return e3;
          }
          function arrayEachRight(e3, r3) {
            var t4 = e3 == null ? 0 : e3.length;
            while (t4--) {
              if (r3(e3[t4], t4, e3) === false) {
                break;
              }
            }
            return e3;
          }
          function arrayEvery(e3, r3) {
            var t4 = -1, n2 = e3 == null ? 0 : e3.length;
            while (++t4 < n2) {
              if (!r3(e3[t4], t4, e3)) {
                return false;
              }
            }
            return true;
          }
          function arrayFilter(e3, r3) {
            var t4 = -1, n2 = e3 == null ? 0 : e3.length, a2 = 0, i2 = [];
            while (++t4 < n2) {
              var s2 = e3[t4];
              if (r3(s2, t4, e3)) {
                i2[a2++] = s2;
              }
            }
            return i2;
          }
          function arrayIncludes(e3, r3) {
            var t4 = e3 == null ? 0 : e3.length;
            return !!t4 && baseIndexOf(e3, r3, 0) > -1;
          }
          function arrayIncludesWith(e3, r3, t4) {
            var n2 = -1, a2 = e3 == null ? 0 : e3.length;
            while (++n2 < a2) {
              if (t4(r3, e3[n2])) {
                return true;
              }
            }
            return false;
          }
          function arrayMap(e3, r3) {
            var t4 = -1, n2 = e3 == null ? 0 : e3.length, a2 = Array(n2);
            while (++t4 < n2) {
              a2[t4] = r3(e3[t4], t4, e3);
            }
            return a2;
          }
          function arrayPush(e3, r3) {
            var t4 = -1, n2 = r3.length, a2 = e3.length;
            while (++t4 < n2) {
              e3[a2 + t4] = r3[t4];
            }
            return e3;
          }
          function arrayReduce(e3, r3, t4, n2) {
            var a2 = -1, i2 = e3 == null ? 0 : e3.length;
            if (n2 && i2) {
              t4 = e3[++a2];
            }
            while (++a2 < i2) {
              t4 = r3(t4, e3[a2], a2, e3);
            }
            return t4;
          }
          function arrayReduceRight(e3, r3, t4, n2) {
            var a2 = e3 == null ? 0 : e3.length;
            if (n2 && a2) {
              t4 = e3[--a2];
            }
            while (a2--) {
              t4 = r3(t4, e3[a2], a2, e3);
            }
            return t4;
          }
          function arraySome(e3, r3) {
            var t4 = -1, n2 = e3 == null ? 0 : e3.length;
            while (++t4 < n2) {
              if (r3(e3[t4], t4, e3)) {
                return true;
              }
            }
            return false;
          }
          var gt = baseProperty("length");
          function asciiToArray(e3) {
            return e3.split("");
          }
          function asciiWords(e3) {
            return e3.match(De) || [];
          }
          function baseFindKey(e3, r3, t4) {
            var n2;
            t4(e3, function(e4, t5, a2) {
              if (r3(e4, t5, a2)) {
                n2 = t5;
                return false;
              }
            });
            return n2;
          }
          function baseFindIndex(e3, r3, t4, n2) {
            var a2 = e3.length, i2 = t4 + (n2 ? 1 : -1);
            while (n2 ? i2-- : ++i2 < a2) {
              if (r3(e3[i2], i2, e3)) {
                return i2;
              }
            }
            return -1;
          }
          function baseIndexOf(e3, r3, t4) {
            return r3 === r3 ? strictIndexOf(e3, r3, t4) : baseFindIndex(e3, baseIsNaN, t4);
          }
          function baseIndexOfWith(e3, r3, t4, n2) {
            var a2 = t4 - 1, i2 = e3.length;
            while (++a2 < i2) {
              if (n2(e3[a2], r3)) {
                return a2;
              }
            }
            return -1;
          }
          function baseIsNaN(e3) {
            return e3 !== e3;
          }
          function baseMean(e3, r3) {
            var t4 = e3 == null ? 0 : e3.length;
            return t4 ? baseSum(e3, r3) / t4 : z;
          }
          function baseProperty(e3) {
            return function(r3) {
              return r3 == null ? t3 : r3[e3];
            };
          }
          function basePropertyOf(e3) {
            return function(r3) {
              return e3 == null ? t3 : e3[r3];
            };
          }
          function baseReduce(e3, r3, t4, n2, a2) {
            a2(e3, function(e4, a3, i2) {
              t4 = n2 ? (n2 = false, e4) : r3(t4, e4, a3, i2);
            });
            return t4;
          }
          function baseSortBy(e3, r3) {
            var t4 = e3.length;
            e3.sort(r3);
            while (t4--) {
              e3[t4] = e3[t4].value;
            }
            return e3;
          }
          function baseSum(e3, r3) {
            var n2, a2 = -1, i2 = e3.length;
            while (++a2 < i2) {
              var s2 = r3(e3[a2]);
              if (s2 !== t3) {
                n2 = n2 === t3 ? s2 : n2 + s2;
              }
            }
            return n2;
          }
          function baseTimes(e3, r3) {
            var t4 = -1, n2 = Array(e3);
            while (++t4 < e3) {
              n2[t4] = r3(t4);
            }
            return n2;
          }
          function baseToPairs(e3, r3) {
            return arrayMap(r3, function(r4) {
              return [r4, e3[r4]];
            });
          }
          function baseTrim(e3) {
            return e3 ? e3.slice(0, trimmedEndIndex(e3) + 1).replace(Pe, "") : e3;
          }
          function baseUnary(e3) {
            return function(r3) {
              return e3(r3);
            };
          }
          function baseValues(e3, r3) {
            return arrayMap(r3, function(r4) {
              return e3[r4];
            });
          }
          function cacheHas(e3, r3) {
            return e3.has(r3);
          }
          function charsStartIndex(e3, r3) {
            var t4 = -1, n2 = e3.length;
            while (++t4 < n2 && baseIndexOf(r3, e3[t4], 0) > -1) {
            }
            return t4;
          }
          function charsEndIndex(e3, r3) {
            var t4 = e3.length;
            while (t4-- && baseIndexOf(r3, e3[t4], 0) > -1) {
            }
            return t4;
          }
          function countHolders(e3, r3) {
            var t4 = e3.length, n2 = 0;
            while (t4--) {
              if (e3[t4] === r3) {
                ++n2;
              }
            }
            return n2;
          }
          var vt = basePropertyOf(Zr);
          var bt = basePropertyOf(Xr);
          function escapeStringChar(e3) {
            return "\\" + Qr[e3];
          }
          function getValue(e3, r3) {
            return e3 == null ? t3 : e3[r3];
          }
          function hasUnicode(e3) {
            return Ur.test(e3);
          }
          function hasUnicodeWord(e3) {
            return Nr.test(e3);
          }
          function iteratorToArray(e3) {
            var r3, t4 = [];
            while (!(r3 = e3.next()).done) {
              t4.push(r3.value);
            }
            return t4;
          }
          function mapToArray(e3) {
            var r3 = -1, t4 = Array(e3.size);
            e3.forEach(function(e4, n2) {
              t4[++r3] = [n2, e4];
            });
            return t4;
          }
          function overArg(e3, r3) {
            return function(t4) {
              return e3(r3(t4));
            };
          }
          function replaceHolders(e3, r3) {
            var t4 = -1, n2 = e3.length, a2 = 0, i2 = [];
            while (++t4 < n2) {
              var s2 = e3[t4];
              if (s2 === r3 || s2 === c) {
                e3[t4] = c;
                i2[a2++] = t4;
              }
            }
            return i2;
          }
          function setToArray(e3) {
            var r3 = -1, t4 = Array(e3.size);
            e3.forEach(function(e4) {
              t4[++r3] = e4;
            });
            return t4;
          }
          function setToPairs(e3) {
            var r3 = -1, t4 = Array(e3.size);
            e3.forEach(function(e4) {
              t4[++r3] = [e4, e4];
            });
            return t4;
          }
          function strictIndexOf(e3, r3, t4) {
            var n2 = t4 - 1, a2 = e3.length;
            while (++n2 < a2) {
              if (e3[n2] === r3) {
                return n2;
              }
            }
            return -1;
          }
          function strictLastIndexOf(e3, r3, t4) {
            var n2 = t4 + 1;
            while (n2--) {
              if (e3[n2] === r3) {
                return n2;
              }
            }
            return n2;
          }
          function stringSize(e3) {
            return hasUnicode(e3) ? unicodeSize(e3) : gt(e3);
          }
          function stringToArray(e3) {
            return hasUnicode(e3) ? unicodeToArray(e3) : asciiToArray(e3);
          }
          function trimmedEndIndex(e3) {
            var r3 = e3.length;
            while (r3-- && ze.test(e3.charAt(r3))) {
            }
            return r3;
          }
          var mt = basePropertyOf(Yr);
          function unicodeSize(e3) {
            var r3 = qr.lastIndex = 0;
            while (qr.test(e3)) {
              ++r3;
            }
            return r3;
          }
          function unicodeToArray(e3) {
            return e3.match(qr) || [];
          }
          function unicodeWords(e3) {
            return e3.match(Vr) || [];
          }
          var _t = function runInContext(e3) {
            e3 = e3 == null ? at : wt.defaults(at.Object(), e3, wt.pick(at, Hr));
            var r3 = e3.Array, ze2 = e3.Date, De2 = e3.Error, Qe2 = e3.Function, er2 = e3.Math, rr2 = e3.Object, tr2 = e3.RegExp, nr2 = e3.String, ar2 = e3.TypeError;
            var ir2 = r3.prototype, sr2 = Qe2.prototype, or2 = rr2.prototype;
            var ur2 = e3["__core-js_shared__"];
            var lr2 = sr2.toString;
            var cr2 = or2.hasOwnProperty;
            var fr2 = 0;
            var hr2 = function() {
              var e4 = /[^.]+$/.exec(ur2 && ur2.keys && ur2.keys.IE_PROTO || "");
              return e4 ? "Symbol(src)_1." + e4 : "";
            }();
            var pr2 = or2.toString;
            var dr2 = lr2.call(rr2);
            var yr2 = at._;
            var gr2 = tr2("^" + lr2.call(cr2).replace(Te, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
            var vr2 = ot ? e3.Buffer : t3, br2 = e3.Symbol, mr2 = e3.Uint8Array, _r2 = vr2 ? vr2.allocUnsafe : t3, wr2 = overArg(rr2.getPrototypeOf, rr2), Sr2 = rr2.create, Ir2 = or2.propertyIsEnumerable, Ar2 = ir2.splice, xr2 = br2 ? br2.isConcatSpreadable : t3, kr2 = br2 ? br2.iterator : t3, jr2 = br2 ? br2.toStringTag : t3;
            var Or2 = function() {
              try {
                var e4 = getNative(rr2, "defineProperty");
                e4({}, "", {});
                return e4;
              } catch (e5) {
              }
            }();
            var Er2 = e3.clearTimeout !== at.clearTimeout && e3.clearTimeout, Rr2 = ze2 && ze2.now !== at.Date.now && ze2.now, Lr2 = e3.setTimeout !== at.setTimeout && e3.setTimeout;
            var Cr2 = er2.ceil, Tr2 = er2.floor, Wr2 = rr2.getOwnPropertySymbols, Pr2 = vr2 ? vr2.isBuffer : t3, zr2 = e3.isFinite, Br2 = ir2.join, Fr2 = overArg(rr2.keys, rr2), Mr2 = er2.max, qr2 = er2.min, Vr2 = ze2.now, Ur2 = e3.parseInt, Nr2 = er2.random, Zr2 = ir2.reverse;
            var Xr2 = getNative(e3, "DataView"), Yr2 = getNative(e3, "Map"), Qr2 = getNative(e3, "Promise"), tt2 = getNative(e3, "Set"), nt2 = getNative(e3, "WeakMap"), it2 = getNative(rr2, "create");
            var st2 = nt2 && new nt2();
            var ut2 = {};
            var lt2 = toSource(Xr2), gt2 = toSource(Yr2), _t2 = toSource(Qr2), St = toSource(tt2), It = toSource(nt2);
            var At = br2 ? br2.prototype : t3, xt = At ? At.valueOf : t3, kt = At ? At.toString : t3;
            function lodash(e4) {
              if (isObjectLike(e4) && !Ln(e4) && !(e4 instanceof LazyWrapper)) {
                if (e4 instanceof LodashWrapper) {
                  return e4;
                }
                if (cr2.call(e4, "__wrapped__")) {
                  return wrapperClone(e4);
                }
              }
              return new LodashWrapper(e4);
            }
            var jt = function() {
              function object() {
              }
              return function(e4) {
                if (!isObject(e4)) {
                  return {};
                }
                if (Sr2) {
                  return Sr2(e4);
                }
                object.prototype = e4;
                var r4 = new object();
                object.prototype = t3;
                return r4;
              };
            }();
            function baseLodash() {
            }
            function LodashWrapper(e4, r4) {
              this.__wrapped__ = e4;
              this.__actions__ = [];
              this.__chain__ = !!r4;
              this.__index__ = 0;
              this.__values__ = t3;
            }
            lodash.templateSettings = { escape: je, evaluate: Oe, interpolate: Ee, variable: "", imports: { _: lodash } };
            lodash.prototype = baseLodash.prototype;
            lodash.prototype.constructor = lodash;
            LodashWrapper.prototype = jt(baseLodash.prototype);
            LodashWrapper.prototype.constructor = LodashWrapper;
            function LazyWrapper(e4) {
              this.__wrapped__ = e4;
              this.__actions__ = [];
              this.__dir__ = 1;
              this.__filtered__ = false;
              this.__iteratees__ = [];
              this.__takeCount__ = B;
              this.__views__ = [];
            }
            function lazyClone() {
              var e4 = new LazyWrapper(this.__wrapped__);
              e4.__actions__ = copyArray(this.__actions__);
              e4.__dir__ = this.__dir__;
              e4.__filtered__ = this.__filtered__;
              e4.__iteratees__ = copyArray(this.__iteratees__);
              e4.__takeCount__ = this.__takeCount__;
              e4.__views__ = copyArray(this.__views__);
              return e4;
            }
            function lazyReverse() {
              if (this.__filtered__) {
                var e4 = new LazyWrapper(this);
                e4.__dir__ = -1;
                e4.__filtered__ = true;
              } else {
                e4 = this.clone();
                e4.__dir__ *= -1;
              }
              return e4;
            }
            function lazyValue() {
              var e4 = this.__wrapped__.value(), r4 = this.__dir__, t4 = Ln(e4), n2 = r4 < 0, a2 = t4 ? e4.length : 0, i2 = getView(0, a2, this.__views__), s2 = i2.start, o2 = i2.end, u2 = o2 - s2, l2 = n2 ? o2 : s2 - 1, c2 = this.__iteratees__, f2 = c2.length, h2 = 0, p2 = qr2(u2, this.__takeCount__);
              if (!t4 || !n2 && a2 == u2 && p2 == u2) {
                return baseWrapperValue(e4, this.__actions__);
              }
              var d2 = [];
              e:
                while (u2-- && h2 < p2) {
                  l2 += r4;
                  var y2 = -1, g2 = e4[l2];
                  while (++y2 < f2) {
                    var v2 = c2[y2], b2 = v2.iteratee, m2 = v2.type, _2 = b2(g2);
                    if (m2 == L) {
                      g2 = _2;
                    } else if (!_2) {
                      if (m2 == R) {
                        continue e;
                      } else {
                        break e;
                      }
                    }
                  }
                  d2[h2++] = g2;
                }
              return d2;
            }
            LazyWrapper.prototype = jt(baseLodash.prototype);
            LazyWrapper.prototype.constructor = LazyWrapper;
            function Hash(e4) {
              var r4 = -1, t4 = e4 == null ? 0 : e4.length;
              this.clear();
              while (++r4 < t4) {
                var n2 = e4[r4];
                this.set(n2[0], n2[1]);
              }
            }
            function hashClear() {
              this.__data__ = it2 ? it2(null) : {};
              this.size = 0;
            }
            function hashDelete(e4) {
              var r4 = this.has(e4) && delete this.__data__[e4];
              this.size -= r4 ? 1 : 0;
              return r4;
            }
            function hashGet(e4) {
              var r4 = this.__data__;
              if (it2) {
                var n2 = r4[e4];
                return n2 === u ? t3 : n2;
              }
              return cr2.call(r4, e4) ? r4[e4] : t3;
            }
            function hashHas(e4) {
              var r4 = this.__data__;
              return it2 ? r4[e4] !== t3 : cr2.call(r4, e4);
            }
            function hashSet(e4, r4) {
              var n2 = this.__data__;
              this.size += this.has(e4) ? 0 : 1;
              n2[e4] = it2 && r4 === t3 ? u : r4;
              return this;
            }
            Hash.prototype.clear = hashClear;
            Hash.prototype["delete"] = hashDelete;
            Hash.prototype.get = hashGet;
            Hash.prototype.has = hashHas;
            Hash.prototype.set = hashSet;
            function ListCache(e4) {
              var r4 = -1, t4 = e4 == null ? 0 : e4.length;
              this.clear();
              while (++r4 < t4) {
                var n2 = e4[r4];
                this.set(n2[0], n2[1]);
              }
            }
            function listCacheClear() {
              this.__data__ = [];
              this.size = 0;
            }
            function listCacheDelete(e4) {
              var r4 = this.__data__, t4 = assocIndexOf(r4, e4);
              if (t4 < 0) {
                return false;
              }
              var n2 = r4.length - 1;
              if (t4 == n2) {
                r4.pop();
              } else {
                Ar2.call(r4, t4, 1);
              }
              --this.size;
              return true;
            }
            function listCacheGet(e4) {
              var r4 = this.__data__, n2 = assocIndexOf(r4, e4);
              return n2 < 0 ? t3 : r4[n2][1];
            }
            function listCacheHas(e4) {
              return assocIndexOf(this.__data__, e4) > -1;
            }
            function listCacheSet(e4, r4) {
              var t4 = this.__data__, n2 = assocIndexOf(t4, e4);
              if (n2 < 0) {
                ++this.size;
                t4.push([e4, r4]);
              } else {
                t4[n2][1] = r4;
              }
              return this;
            }
            ListCache.prototype.clear = listCacheClear;
            ListCache.prototype["delete"] = listCacheDelete;
            ListCache.prototype.get = listCacheGet;
            ListCache.prototype.has = listCacheHas;
            ListCache.prototype.set = listCacheSet;
            function MapCache(e4) {
              var r4 = -1, t4 = e4 == null ? 0 : e4.length;
              this.clear();
              while (++r4 < t4) {
                var n2 = e4[r4];
                this.set(n2[0], n2[1]);
              }
            }
            function mapCacheClear() {
              this.size = 0;
              this.__data__ = { hash: new Hash(), map: new (Yr2 || ListCache)(), string: new Hash() };
            }
            function mapCacheDelete(e4) {
              var r4 = getMapData(this, e4)["delete"](e4);
              this.size -= r4 ? 1 : 0;
              return r4;
            }
            function mapCacheGet(e4) {
              return getMapData(this, e4).get(e4);
            }
            function mapCacheHas(e4) {
              return getMapData(this, e4).has(e4);
            }
            function mapCacheSet(e4, r4) {
              var t4 = getMapData(this, e4), n2 = t4.size;
              t4.set(e4, r4);
              this.size += t4.size == n2 ? 0 : 1;
              return this;
            }
            MapCache.prototype.clear = mapCacheClear;
            MapCache.prototype["delete"] = mapCacheDelete;
            MapCache.prototype.get = mapCacheGet;
            MapCache.prototype.has = mapCacheHas;
            MapCache.prototype.set = mapCacheSet;
            function SetCache(e4) {
              var r4 = -1, t4 = e4 == null ? 0 : e4.length;
              this.__data__ = new MapCache();
              while (++r4 < t4) {
                this.add(e4[r4]);
              }
            }
            function setCacheAdd(e4) {
              this.__data__.set(e4, u);
              return this;
            }
            function setCacheHas(e4) {
              return this.__data__.has(e4);
            }
            SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
            SetCache.prototype.has = setCacheHas;
            function Stack(e4) {
              var r4 = this.__data__ = new ListCache(e4);
              this.size = r4.size;
            }
            function stackClear() {
              this.__data__ = new ListCache();
              this.size = 0;
            }
            function stackDelete(e4) {
              var r4 = this.__data__, t4 = r4["delete"](e4);
              this.size = r4.size;
              return t4;
            }
            function stackGet(e4) {
              return this.__data__.get(e4);
            }
            function stackHas(e4) {
              return this.__data__.has(e4);
            }
            function stackSet(e4, r4) {
              var t4 = this.__data__;
              if (t4 instanceof ListCache) {
                var n2 = t4.__data__;
                if (!Yr2 || n2.length < a - 1) {
                  n2.push([e4, r4]);
                  this.size = ++t4.size;
                  return this;
                }
                t4 = this.__data__ = new MapCache(n2);
              }
              t4.set(e4, r4);
              this.size = t4.size;
              return this;
            }
            Stack.prototype.clear = stackClear;
            Stack.prototype["delete"] = stackDelete;
            Stack.prototype.get = stackGet;
            Stack.prototype.has = stackHas;
            Stack.prototype.set = stackSet;
            function arrayLikeKeys(e4, r4) {
              var t4 = Ln(e4), n2 = !t4 && Rn(e4), a2 = !t4 && !n2 && Tn(e4), i2 = !t4 && !n2 && !a2 && Fn(e4), s2 = t4 || n2 || a2 || i2, o2 = s2 ? baseTimes(e4.length, nr2) : [], u2 = o2.length;
              for (var l2 in e4) {
                if ((r4 || cr2.call(e4, l2)) && !(s2 && (l2 == "length" || a2 && (l2 == "offset" || l2 == "parent") || i2 && (l2 == "buffer" || l2 == "byteLength" || l2 == "byteOffset") || isIndex(l2, u2)))) {
                  o2.push(l2);
                }
              }
              return o2;
            }
            function arraySample(e4) {
              var r4 = e4.length;
              return r4 ? e4[baseRandom(0, r4 - 1)] : t3;
            }
            function arraySampleSize(e4, r4) {
              return shuffleSelf(copyArray(e4), baseClamp(r4, 0, e4.length));
            }
            function arrayShuffle(e4) {
              return shuffleSelf(copyArray(e4));
            }
            function assignMergeValue(e4, r4, n2) {
              if (n2 !== t3 && !eq(e4[r4], n2) || n2 === t3 && !(r4 in e4)) {
                baseAssignValue(e4, r4, n2);
              }
            }
            function assignValue(e4, r4, n2) {
              var a2 = e4[r4];
              if (!(cr2.call(e4, r4) && eq(a2, n2)) || n2 === t3 && !(r4 in e4)) {
                baseAssignValue(e4, r4, n2);
              }
            }
            function assocIndexOf(e4, r4) {
              var t4 = e4.length;
              while (t4--) {
                if (eq(e4[t4][0], r4)) {
                  return t4;
                }
              }
              return -1;
            }
            function baseAggregator(e4, r4, t4, n2) {
              Ot(e4, function(e5, a2, i2) {
                r4(n2, e5, t4(e5), i2);
              });
              return n2;
            }
            function baseAssign(e4, r4) {
              return e4 && copyObject(r4, keys(r4), e4);
            }
            function baseAssignIn(e4, r4) {
              return e4 && copyObject(r4, keysIn(r4), e4);
            }
            function baseAssignValue(e4, r4, t4) {
              if (r4 == "__proto__" && Or2) {
                Or2(e4, r4, { configurable: true, enumerable: true, value: t4, writable: true });
              } else {
                e4[r4] = t4;
              }
            }
            function baseAt(e4, n2) {
              var a2 = -1, i2 = n2.length, s2 = r3(i2), o2 = e4 == null;
              while (++a2 < i2) {
                s2[a2] = o2 ? t3 : get(e4, n2[a2]);
              }
              return s2;
            }
            function baseClamp(e4, r4, n2) {
              if (e4 === e4) {
                if (n2 !== t3) {
                  e4 = e4 <= n2 ? e4 : n2;
                }
                if (r4 !== t3) {
                  e4 = e4 >= r4 ? e4 : r4;
                }
              }
              return e4;
            }
            function baseClone(e4, r4, n2, a2, i2, s2) {
              var o2, u2 = r4 & f, l2 = r4 & h, c2 = r4 & p;
              if (n2) {
                o2 = i2 ? n2(e4, a2, i2, s2) : n2(e4);
              }
              if (o2 !== t3) {
                return o2;
              }
              if (!isObject(e4)) {
                return e4;
              }
              var d2 = Ln(e4);
              if (d2) {
                o2 = initCloneArray(e4);
                if (!u2) {
                  return copyArray(e4, o2);
                }
              } else {
                var y2 = Dt(e4), g2 = y2 == $ || y2 == J;
                if (Tn(e4)) {
                  return cloneBuffer(e4, u2);
                }
                if (y2 == Q || y2 == K || g2 && !i2) {
                  o2 = l2 || g2 ? {} : initCloneObject(e4);
                  if (!u2) {
                    return l2 ? copySymbolsIn(e4, baseAssignIn(o2, e4)) : copySymbols(e4, baseAssign(o2, e4));
                  }
                } else {
                  if (!Jr[y2]) {
                    return i2 ? e4 : {};
                  }
                  o2 = initCloneByTag(e4, y2, u2);
                }
              }
              s2 || (s2 = new Stack());
              var v2 = s2.get(e4);
              if (v2) {
                return v2;
              }
              s2.set(e4, o2);
              if (Bn(e4)) {
                e4.forEach(function(t4) {
                  o2.add(baseClone(t4, r4, n2, t4, e4, s2));
                });
              } else if (Pn(e4)) {
                e4.forEach(function(t4, a3) {
                  o2.set(a3, baseClone(t4, r4, n2, a3, e4, s2));
                });
              }
              var b2 = c2 ? l2 ? getAllKeysIn : getAllKeys : l2 ? keysIn : keys;
              var m2 = d2 ? t3 : b2(e4);
              arrayEach(m2 || e4, function(t4, a3) {
                if (m2) {
                  a3 = t4;
                  t4 = e4[a3];
                }
                assignValue(o2, a3, baseClone(t4, r4, n2, a3, e4, s2));
              });
              return o2;
            }
            function baseConforms(e4) {
              var r4 = keys(e4);
              return function(t4) {
                return baseConformsTo(t4, e4, r4);
              };
            }
            function baseConformsTo(e4, r4, n2) {
              var a2 = n2.length;
              if (e4 == null) {
                return !a2;
              }
              e4 = rr2(e4);
              while (a2--) {
                var i2 = n2[a2], s2 = r4[i2], o2 = e4[i2];
                if (o2 === t3 && !(i2 in e4) || !s2(o2)) {
                  return false;
                }
              }
              return true;
            }
            function baseDelay(e4, r4, n2) {
              if (typeof e4 != "function") {
                throw new ar2(s);
              }
              return Vt(function() {
                e4.apply(t3, n2);
              }, r4);
            }
            function baseDifference(e4, r4, t4, n2) {
              var i2 = -1, s2 = arrayIncludes, o2 = true, u2 = e4.length, l2 = [], c2 = r4.length;
              if (!u2) {
                return l2;
              }
              if (t4) {
                r4 = arrayMap(r4, baseUnary(t4));
              }
              if (n2) {
                s2 = arrayIncludesWith;
                o2 = false;
              } else if (r4.length >= a) {
                s2 = cacheHas;
                o2 = false;
                r4 = new SetCache(r4);
              }
              e:
                while (++i2 < u2) {
                  var f2 = e4[i2], h2 = t4 == null ? f2 : t4(f2);
                  f2 = n2 || f2 !== 0 ? f2 : 0;
                  if (o2 && h2 === h2) {
                    var p2 = c2;
                    while (p2--) {
                      if (r4[p2] === h2) {
                        continue e;
                      }
                    }
                    l2.push(f2);
                  } else if (!s2(r4, h2, n2)) {
                    l2.push(f2);
                  }
                }
              return l2;
            }
            var Ot = createBaseEach(baseForOwn);
            var Et = createBaseEach(baseForOwnRight, true);
            function baseEvery(e4, r4) {
              var t4 = true;
              Ot(e4, function(e5, n2, a2) {
                t4 = !!r4(e5, n2, a2);
                return t4;
              });
              return t4;
            }
            function baseExtremum(e4, r4, n2) {
              var a2 = -1, i2 = e4.length;
              while (++a2 < i2) {
                var s2 = e4[a2], o2 = r4(s2);
                if (o2 != null && (u2 === t3 ? o2 === o2 && !isSymbol(o2) : n2(o2, u2))) {
                  var u2 = o2, l2 = s2;
                }
              }
              return l2;
            }
            function baseFill(e4, r4, n2, a2) {
              var i2 = e4.length;
              n2 = toInteger(n2);
              if (n2 < 0) {
                n2 = -n2 > i2 ? 0 : i2 + n2;
              }
              a2 = a2 === t3 || a2 > i2 ? i2 : toInteger(a2);
              if (a2 < 0) {
                a2 += i2;
              }
              a2 = n2 > a2 ? 0 : toLength(a2);
              while (n2 < a2) {
                e4[n2++] = r4;
              }
              return e4;
            }
            function baseFilter(e4, r4) {
              var t4 = [];
              Ot(e4, function(e5, n2, a2) {
                if (r4(e5, n2, a2)) {
                  t4.push(e5);
                }
              });
              return t4;
            }
            function baseFlatten(e4, r4, t4, n2, a2) {
              var i2 = -1, s2 = e4.length;
              t4 || (t4 = isFlattenable);
              a2 || (a2 = []);
              while (++i2 < s2) {
                var o2 = e4[i2];
                if (r4 > 0 && t4(o2)) {
                  if (r4 > 1) {
                    baseFlatten(o2, r4 - 1, t4, n2, a2);
                  } else {
                    arrayPush(a2, o2);
                  }
                } else if (!n2) {
                  a2[a2.length] = o2;
                }
              }
              return a2;
            }
            var Rt = createBaseFor();
            var Lt = createBaseFor(true);
            function baseForOwn(e4, r4) {
              return e4 && Rt(e4, r4, keys);
            }
            function baseForOwnRight(e4, r4) {
              return e4 && Lt(e4, r4, keys);
            }
            function baseFunctions(e4, r4) {
              return arrayFilter(r4, function(r5) {
                return isFunction(e4[r5]);
              });
            }
            function baseGet(e4, r4) {
              r4 = castPath(r4, e4);
              var n2 = 0, a2 = r4.length;
              while (e4 != null && n2 < a2) {
                e4 = e4[toKey(r4[n2++])];
              }
              return n2 && n2 == a2 ? e4 : t3;
            }
            function baseGetAllKeys(e4, r4, t4) {
              var n2 = r4(e4);
              return Ln(e4) ? n2 : arrayPush(n2, t4(e4));
            }
            function baseGetTag(e4) {
              if (e4 == null) {
                return e4 === t3 ? se : Y;
              }
              return jr2 && jr2 in rr2(e4) ? getRawTag(e4) : objectToString(e4);
            }
            function baseGt(e4, r4) {
              return e4 > r4;
            }
            function baseHas(e4, r4) {
              return e4 != null && cr2.call(e4, r4);
            }
            function baseHasIn(e4, r4) {
              return e4 != null && r4 in rr2(e4);
            }
            function baseInRange(e4, r4, t4) {
              return e4 >= qr2(r4, t4) && e4 < Mr2(r4, t4);
            }
            function baseIntersection(e4, n2, a2) {
              var i2 = a2 ? arrayIncludesWith : arrayIncludes, s2 = e4[0].length, o2 = e4.length, u2 = o2, l2 = r3(o2), c2 = Infinity, f2 = [];
              while (u2--) {
                var h2 = e4[u2];
                if (u2 && n2) {
                  h2 = arrayMap(h2, baseUnary(n2));
                }
                c2 = qr2(h2.length, c2);
                l2[u2] = !a2 && (n2 || s2 >= 120 && h2.length >= 120) ? new SetCache(u2 && h2) : t3;
              }
              h2 = e4[0];
              var p2 = -1, d2 = l2[0];
              e:
                while (++p2 < s2 && f2.length < c2) {
                  var y2 = h2[p2], g2 = n2 ? n2(y2) : y2;
                  y2 = a2 || y2 !== 0 ? y2 : 0;
                  if (!(d2 ? cacheHas(d2, g2) : i2(f2, g2, a2))) {
                    u2 = o2;
                    while (--u2) {
                      var v2 = l2[u2];
                      if (!(v2 ? cacheHas(v2, g2) : i2(e4[u2], g2, a2))) {
                        continue e;
                      }
                    }
                    if (d2) {
                      d2.push(g2);
                    }
                    f2.push(y2);
                  }
                }
              return f2;
            }
            function baseInverter(e4, r4, t4, n2) {
              baseForOwn(e4, function(e5, a2, i2) {
                r4(n2, t4(e5), a2, i2);
              });
              return n2;
            }
            function baseInvoke(e4, r4, n2) {
              r4 = castPath(r4, e4);
              e4 = parent(e4, r4);
              var a2 = e4 == null ? e4 : e4[toKey(last(r4))];
              return a2 == null ? t3 : apply(a2, e4, n2);
            }
            function baseIsArguments(e4) {
              return isObjectLike(e4) && baseGetTag(e4) == K;
            }
            function baseIsArrayBuffer(e4) {
              return isObjectLike(e4) && baseGetTag(e4) == le;
            }
            function baseIsDate(e4) {
              return isObjectLike(e4) && baseGetTag(e4) == N;
            }
            function baseIsEqual(e4, r4, t4, n2, a2) {
              if (e4 === r4) {
                return true;
              }
              if (e4 == null || r4 == null || !isObjectLike(e4) && !isObjectLike(r4)) {
                return e4 !== e4 && r4 !== r4;
              }
              return baseIsEqualDeep(e4, r4, t4, n2, baseIsEqual, a2);
            }
            function baseIsEqualDeep(e4, r4, t4, n2, a2, i2) {
              var s2 = Ln(e4), o2 = Ln(r4), u2 = s2 ? q : Dt(e4), l2 = o2 ? q : Dt(r4);
              u2 = u2 == K ? Q : u2;
              l2 = l2 == K ? Q : l2;
              var c2 = u2 == Q, f2 = l2 == Q, h2 = u2 == l2;
              if (h2 && Tn(e4)) {
                if (!Tn(r4)) {
                  return false;
                }
                s2 = true;
                c2 = false;
              }
              if (h2 && !c2) {
                i2 || (i2 = new Stack());
                return s2 || Fn(e4) ? equalArrays(e4, r4, t4, n2, a2, i2) : equalByTag(e4, r4, u2, t4, n2, a2, i2);
              }
              if (!(t4 & d)) {
                var p2 = c2 && cr2.call(e4, "__wrapped__"), y2 = f2 && cr2.call(r4, "__wrapped__");
                if (p2 || y2) {
                  var g2 = p2 ? e4.value() : e4, v2 = y2 ? r4.value() : r4;
                  i2 || (i2 = new Stack());
                  return a2(g2, v2, t4, n2, i2);
                }
              }
              if (!h2) {
                return false;
              }
              i2 || (i2 = new Stack());
              return equalObjects(e4, r4, t4, n2, a2, i2);
            }
            function baseIsMap(e4) {
              return isObjectLike(e4) && Dt(e4) == Z;
            }
            function baseIsMatch(e4, r4, n2, a2) {
              var i2 = n2.length, s2 = i2, o2 = !a2;
              if (e4 == null) {
                return !s2;
              }
              e4 = rr2(e4);
              while (i2--) {
                var u2 = n2[i2];
                if (o2 && u2[2] ? u2[1] !== e4[u2[0]] : !(u2[0] in e4)) {
                  return false;
                }
              }
              while (++i2 < s2) {
                u2 = n2[i2];
                var l2 = u2[0], c2 = e4[l2], f2 = u2[1];
                if (o2 && u2[2]) {
                  if (c2 === t3 && !(l2 in e4)) {
                    return false;
                  }
                } else {
                  var h2 = new Stack();
                  if (a2) {
                    var p2 = a2(c2, f2, l2, e4, r4, h2);
                  }
                  if (!(p2 === t3 ? baseIsEqual(f2, c2, d | y, a2, h2) : p2)) {
                    return false;
                  }
                }
              }
              return true;
            }
            function baseIsNative(e4) {
              if (!isObject(e4) || isMasked(e4)) {
                return false;
              }
              var r4 = isFunction(e4) ? gr2 : Ge;
              return r4.test(toSource(e4));
            }
            function baseIsRegExp(e4) {
              return isObjectLike(e4) && baseGetTag(e4) == te;
            }
            function baseIsSet(e4) {
              return isObjectLike(e4) && Dt(e4) == ne;
            }
            function baseIsTypedArray(e4) {
              return isObjectLike(e4) && isLength(e4.length) && !!$r[baseGetTag(e4)];
            }
            function baseIteratee(e4) {
              if (typeof e4 == "function") {
                return e4;
              }
              if (e4 == null) {
                return identity;
              }
              if (typeof e4 == "object") {
                return Ln(e4) ? baseMatchesProperty(e4[0], e4[1]) : baseMatches(e4);
              }
              return property(e4);
            }
            function baseKeys(e4) {
              if (!isPrototype(e4)) {
                return Fr2(e4);
              }
              var r4 = [];
              for (var t4 in rr2(e4)) {
                if (cr2.call(e4, t4) && t4 != "constructor") {
                  r4.push(t4);
                }
              }
              return r4;
            }
            function baseKeysIn(e4) {
              if (!isObject(e4)) {
                return nativeKeysIn(e4);
              }
              var r4 = isPrototype(e4), t4 = [];
              for (var n2 in e4) {
                if (!(n2 == "constructor" && (r4 || !cr2.call(e4, n2)))) {
                  t4.push(n2);
                }
              }
              return t4;
            }
            function baseLt(e4, r4) {
              return e4 < r4;
            }
            function baseMap(e4, t4) {
              var n2 = -1, a2 = isArrayLike(e4) ? r3(e4.length) : [];
              Ot(e4, function(e5, r4, i2) {
                a2[++n2] = t4(e5, r4, i2);
              });
              return a2;
            }
            function baseMatches(e4) {
              var r4 = getMatchData(e4);
              if (r4.length == 1 && r4[0][2]) {
                return matchesStrictComparable(r4[0][0], r4[0][1]);
              }
              return function(t4) {
                return t4 === e4 || baseIsMatch(t4, e4, r4);
              };
            }
            function baseMatchesProperty(e4, r4) {
              if (isKey(e4) && isStrictComparable(r4)) {
                return matchesStrictComparable(toKey(e4), r4);
              }
              return function(n2) {
                var a2 = get(n2, e4);
                return a2 === t3 && a2 === r4 ? hasIn(n2, e4) : baseIsEqual(r4, a2, d | y);
              };
            }
            function baseMerge(e4, r4, n2, a2, i2) {
              if (e4 === r4) {
                return;
              }
              Rt(r4, function(s2, o2) {
                i2 || (i2 = new Stack());
                if (isObject(s2)) {
                  baseMergeDeep(e4, r4, o2, n2, baseMerge, a2, i2);
                } else {
                  var u2 = a2 ? a2(safeGet(e4, o2), s2, o2 + "", e4, r4, i2) : t3;
                  if (u2 === t3) {
                    u2 = s2;
                  }
                  assignMergeValue(e4, o2, u2);
                }
              }, keysIn);
            }
            function baseMergeDeep(e4, r4, n2, a2, i2, s2, o2) {
              var u2 = safeGet(e4, n2), l2 = safeGet(r4, n2), c2 = o2.get(l2);
              if (c2) {
                assignMergeValue(e4, n2, c2);
                return;
              }
              var f2 = s2 ? s2(u2, l2, n2 + "", e4, r4, o2) : t3;
              var h2 = f2 === t3;
              if (h2) {
                var p2 = Ln(l2), d2 = !p2 && Tn(l2), y2 = !p2 && !d2 && Fn(l2);
                f2 = l2;
                if (p2 || d2 || y2) {
                  if (Ln(u2)) {
                    f2 = u2;
                  } else if (isArrayLikeObject(u2)) {
                    f2 = copyArray(u2);
                  } else if (d2) {
                    h2 = false;
                    f2 = cloneBuffer(l2, true);
                  } else if (y2) {
                    h2 = false;
                    f2 = cloneTypedArray(l2, true);
                  } else {
                    f2 = [];
                  }
                } else if (isPlainObject(l2) || Rn(l2)) {
                  f2 = u2;
                  if (Rn(u2)) {
                    f2 = toPlainObject(u2);
                  } else if (!isObject(u2) || isFunction(u2)) {
                    f2 = initCloneObject(l2);
                  }
                } else {
                  h2 = false;
                }
              }
              if (h2) {
                o2.set(l2, f2);
                i2(f2, l2, a2, s2, o2);
                o2["delete"](l2);
              }
              assignMergeValue(e4, n2, f2);
            }
            function baseNth(e4, r4) {
              var n2 = e4.length;
              if (!n2) {
                return;
              }
              r4 += r4 < 0 ? n2 : 0;
              return isIndex(r4, n2) ? e4[r4] : t3;
            }
            function baseOrderBy(e4, r4, t4) {
              if (r4.length) {
                r4 = arrayMap(r4, function(e5) {
                  if (Ln(e5)) {
                    return function(r5) {
                      return baseGet(r5, e5.length === 1 ? e5[0] : e5);
                    };
                  }
                  return e5;
                });
              } else {
                r4 = [identity];
              }
              var n2 = -1;
              r4 = arrayMap(r4, baseUnary(getIteratee()));
              var a2 = baseMap(e4, function(e5, t5, a3) {
                var i2 = arrayMap(r4, function(r5) {
                  return r5(e5);
                });
                return { criteria: i2, index: ++n2, value: e5 };
              });
              return baseSortBy(a2, function(e5, r5) {
                return compareMultiple(e5, r5, t4);
              });
            }
            function basePick(e4, r4) {
              return basePickBy(e4, r4, function(r5, t4) {
                return hasIn(e4, t4);
              });
            }
            function basePickBy(e4, r4, t4) {
              var n2 = -1, a2 = r4.length, i2 = {};
              while (++n2 < a2) {
                var s2 = r4[n2], o2 = baseGet(e4, s2);
                if (t4(o2, s2)) {
                  baseSet(i2, castPath(s2, e4), o2);
                }
              }
              return i2;
            }
            function basePropertyDeep(e4) {
              return function(r4) {
                return baseGet(r4, e4);
              };
            }
            function basePullAll(e4, r4, t4, n2) {
              var a2 = n2 ? baseIndexOfWith : baseIndexOf, i2 = -1, s2 = r4.length, o2 = e4;
              if (e4 === r4) {
                r4 = copyArray(r4);
              }
              if (t4) {
                o2 = arrayMap(e4, baseUnary(t4));
              }
              while (++i2 < s2) {
                var u2 = 0, l2 = r4[i2], c2 = t4 ? t4(l2) : l2;
                while ((u2 = a2(o2, c2, u2, n2)) > -1) {
                  if (o2 !== e4) {
                    Ar2.call(o2, u2, 1);
                  }
                  Ar2.call(e4, u2, 1);
                }
              }
              return e4;
            }
            function basePullAt(e4, r4) {
              var t4 = e4 ? r4.length : 0, n2 = t4 - 1;
              while (t4--) {
                var a2 = r4[t4];
                if (t4 == n2 || a2 !== i2) {
                  var i2 = a2;
                  if (isIndex(a2)) {
                    Ar2.call(e4, a2, 1);
                  } else {
                    baseUnset(e4, a2);
                  }
                }
              }
              return e4;
            }
            function baseRandom(e4, r4) {
              return e4 + Tr2(Nr2() * (r4 - e4 + 1));
            }
            function baseRange(e4, t4, n2, a2) {
              var i2 = -1, s2 = Mr2(Cr2((t4 - e4) / (n2 || 1)), 0), o2 = r3(s2);
              while (s2--) {
                o2[a2 ? s2 : ++i2] = e4;
                e4 += n2;
              }
              return o2;
            }
            function baseRepeat(e4, r4) {
              var t4 = "";
              if (!e4 || r4 < 1 || r4 > W) {
                return t4;
              }
              do {
                if (r4 % 2) {
                  t4 += e4;
                }
                r4 = Tr2(r4 / 2);
                if (r4) {
                  e4 += e4;
                }
              } while (r4);
              return t4;
            }
            function baseRest(e4, r4) {
              return Ut(overRest(e4, r4, identity), e4 + "");
            }
            function baseSample(e4) {
              return arraySample(values(e4));
            }
            function baseSampleSize(e4, r4) {
              var t4 = values(e4);
              return shuffleSelf(t4, baseClamp(r4, 0, t4.length));
            }
            function baseSet(e4, r4, n2, a2) {
              if (!isObject(e4)) {
                return e4;
              }
              r4 = castPath(r4, e4);
              var i2 = -1, s2 = r4.length, o2 = s2 - 1, u2 = e4;
              while (u2 != null && ++i2 < s2) {
                var l2 = toKey(r4[i2]), c2 = n2;
                if (l2 === "__proto__" || l2 === "constructor" || l2 === "prototype") {
                  return e4;
                }
                if (i2 != o2) {
                  var f2 = u2[l2];
                  c2 = a2 ? a2(f2, l2, u2) : t3;
                  if (c2 === t3) {
                    c2 = isObject(f2) ? f2 : isIndex(r4[i2 + 1]) ? [] : {};
                  }
                }
                assignValue(u2, l2, c2);
                u2 = u2[l2];
              }
              return e4;
            }
            var Ct = !st2 ? identity : function(e4, r4) {
              st2.set(e4, r4);
              return e4;
            };
            var Tt = !Or2 ? identity : function(e4, r4) {
              return Or2(e4, "toString", { configurable: true, enumerable: false, value: constant(r4), writable: true });
            };
            function baseShuffle(e4) {
              return shuffleSelf(values(e4));
            }
            function baseSlice(e4, t4, n2) {
              var a2 = -1, i2 = e4.length;
              if (t4 < 0) {
                t4 = -t4 > i2 ? 0 : i2 + t4;
              }
              n2 = n2 > i2 ? i2 : n2;
              if (n2 < 0) {
                n2 += i2;
              }
              i2 = t4 > n2 ? 0 : n2 - t4 >>> 0;
              t4 >>>= 0;
              var s2 = r3(i2);
              while (++a2 < i2) {
                s2[a2] = e4[a2 + t4];
              }
              return s2;
            }
            function baseSome(e4, r4) {
              var t4;
              Ot(e4, function(e5, n2, a2) {
                t4 = r4(e5, n2, a2);
                return !t4;
              });
              return !!t4;
            }
            function baseSortedIndex(e4, r4, t4) {
              var n2 = 0, a2 = e4 == null ? n2 : e4.length;
              if (typeof r4 == "number" && r4 === r4 && a2 <= M) {
                while (n2 < a2) {
                  var i2 = n2 + a2 >>> 1, s2 = e4[i2];
                  if (s2 !== null && !isSymbol(s2) && (t4 ? s2 <= r4 : s2 < r4)) {
                    n2 = i2 + 1;
                  } else {
                    a2 = i2;
                  }
                }
                return a2;
              }
              return baseSortedIndexBy(e4, r4, identity, t4);
            }
            function baseSortedIndexBy(e4, r4, n2, a2) {
              var i2 = 0, s2 = e4 == null ? 0 : e4.length;
              if (s2 === 0) {
                return 0;
              }
              r4 = n2(r4);
              var o2 = r4 !== r4, u2 = r4 === null, l2 = isSymbol(r4), c2 = r4 === t3;
              while (i2 < s2) {
                var f2 = Tr2((i2 + s2) / 2), h2 = n2(e4[f2]), p2 = h2 !== t3, d2 = h2 === null, y2 = h2 === h2, g2 = isSymbol(h2);
                if (o2) {
                  var v2 = a2 || y2;
                } else if (c2) {
                  v2 = y2 && (a2 || p2);
                } else if (u2) {
                  v2 = y2 && p2 && (a2 || !d2);
                } else if (l2) {
                  v2 = y2 && p2 && !d2 && (a2 || !g2);
                } else if (d2 || g2) {
                  v2 = false;
                } else {
                  v2 = a2 ? h2 <= r4 : h2 < r4;
                }
                if (v2) {
                  i2 = f2 + 1;
                } else {
                  s2 = f2;
                }
              }
              return qr2(s2, F);
            }
            function baseSortedUniq(e4, r4) {
              var t4 = -1, n2 = e4.length, a2 = 0, i2 = [];
              while (++t4 < n2) {
                var s2 = e4[t4], o2 = r4 ? r4(s2) : s2;
                if (!t4 || !eq(o2, u2)) {
                  var u2 = o2;
                  i2[a2++] = s2 === 0 ? 0 : s2;
                }
              }
              return i2;
            }
            function baseToNumber(e4) {
              if (typeof e4 == "number") {
                return e4;
              }
              if (isSymbol(e4)) {
                return z;
              }
              return +e4;
            }
            function baseToString(e4) {
              if (typeof e4 == "string") {
                return e4;
              }
              if (Ln(e4)) {
                return arrayMap(e4, baseToString) + "";
              }
              if (isSymbol(e4)) {
                return kt ? kt.call(e4) : "";
              }
              var r4 = e4 + "";
              return r4 == "0" && 1 / e4 == -T ? "-0" : r4;
            }
            function baseUniq(e4, r4, t4) {
              var n2 = -1, i2 = arrayIncludes, s2 = e4.length, o2 = true, u2 = [], l2 = u2;
              if (t4) {
                o2 = false;
                i2 = arrayIncludesWith;
              } else if (s2 >= a) {
                var c2 = r4 ? null : zt(e4);
                if (c2) {
                  return setToArray(c2);
                }
                o2 = false;
                i2 = cacheHas;
                l2 = new SetCache();
              } else {
                l2 = r4 ? [] : u2;
              }
              e:
                while (++n2 < s2) {
                  var f2 = e4[n2], h2 = r4 ? r4(f2) : f2;
                  f2 = t4 || f2 !== 0 ? f2 : 0;
                  if (o2 && h2 === h2) {
                    var p2 = l2.length;
                    while (p2--) {
                      if (l2[p2] === h2) {
                        continue e;
                      }
                    }
                    if (r4) {
                      l2.push(h2);
                    }
                    u2.push(f2);
                  } else if (!i2(l2, h2, t4)) {
                    if (l2 !== u2) {
                      l2.push(h2);
                    }
                    u2.push(f2);
                  }
                }
              return u2;
            }
            function baseUnset(e4, r4) {
              r4 = castPath(r4, e4);
              e4 = parent(e4, r4);
              return e4 == null || delete e4[toKey(last(r4))];
            }
            function baseUpdate(e4, r4, t4, n2) {
              return baseSet(e4, r4, t4(baseGet(e4, r4)), n2);
            }
            function baseWhile(e4, r4, t4, n2) {
              var a2 = e4.length, i2 = n2 ? a2 : -1;
              while ((n2 ? i2-- : ++i2 < a2) && r4(e4[i2], i2, e4)) {
              }
              return t4 ? baseSlice(e4, n2 ? 0 : i2, n2 ? i2 + 1 : a2) : baseSlice(e4, n2 ? i2 + 1 : 0, n2 ? a2 : i2);
            }
            function baseWrapperValue(e4, r4) {
              var t4 = e4;
              if (t4 instanceof LazyWrapper) {
                t4 = t4.value();
              }
              return arrayReduce(r4, function(e5, r5) {
                return r5.func.apply(r5.thisArg, arrayPush([e5], r5.args));
              }, t4);
            }
            function baseXor(e4, t4, n2) {
              var a2 = e4.length;
              if (a2 < 2) {
                return a2 ? baseUniq(e4[0]) : [];
              }
              var i2 = -1, s2 = r3(a2);
              while (++i2 < a2) {
                var o2 = e4[i2], u2 = -1;
                while (++u2 < a2) {
                  if (u2 != i2) {
                    s2[i2] = baseDifference(s2[i2] || o2, e4[u2], t4, n2);
                  }
                }
              }
              return baseUniq(baseFlatten(s2, 1), t4, n2);
            }
            function baseZipObject(e4, r4, n2) {
              var a2 = -1, i2 = e4.length, s2 = r4.length, o2 = {};
              while (++a2 < i2) {
                var u2 = a2 < s2 ? r4[a2] : t3;
                n2(o2, e4[a2], u2);
              }
              return o2;
            }
            function castArrayLikeObject(e4) {
              return isArrayLikeObject(e4) ? e4 : [];
            }
            function castFunction(e4) {
              return typeof e4 == "function" ? e4 : identity;
            }
            function castPath(e4, r4) {
              if (Ln(e4)) {
                return e4;
              }
              return isKey(e4, r4) ? [e4] : Nt(toString(e4));
            }
            var Wt = baseRest;
            function castSlice(e4, r4, n2) {
              var a2 = e4.length;
              n2 = n2 === t3 ? a2 : n2;
              return !r4 && n2 >= a2 ? e4 : baseSlice(e4, r4, n2);
            }
            var Pt = Er2 || function(e4) {
              return at.clearTimeout(e4);
            };
            function cloneBuffer(e4, r4) {
              if (r4) {
                return e4.slice();
              }
              var t4 = e4.length, n2 = _r2 ? _r2(t4) : new e4.constructor(t4);
              e4.copy(n2);
              return n2;
            }
            function cloneArrayBuffer(e4) {
              var r4 = new e4.constructor(e4.byteLength);
              new mr2(r4).set(new mr2(e4));
              return r4;
            }
            function cloneDataView(e4, r4) {
              var t4 = r4 ? cloneArrayBuffer(e4.buffer) : e4.buffer;
              return new e4.constructor(t4, e4.byteOffset, e4.byteLength);
            }
            function cloneRegExp(e4) {
              var r4 = new e4.constructor(e4.source, Ue.exec(e4));
              r4.lastIndex = e4.lastIndex;
              return r4;
            }
            function cloneSymbol(e4) {
              return xt ? rr2(xt.call(e4)) : {};
            }
            function cloneTypedArray(e4, r4) {
              var t4 = r4 ? cloneArrayBuffer(e4.buffer) : e4.buffer;
              return new e4.constructor(t4, e4.byteOffset, e4.length);
            }
            function compareAscending(e4, r4) {
              if (e4 !== r4) {
                var n2 = e4 !== t3, a2 = e4 === null, i2 = e4 === e4, s2 = isSymbol(e4);
                var o2 = r4 !== t3, u2 = r4 === null, l2 = r4 === r4, c2 = isSymbol(r4);
                if (!u2 && !c2 && !s2 && e4 > r4 || s2 && o2 && l2 && !u2 && !c2 || a2 && o2 && l2 || !n2 && l2 || !i2) {
                  return 1;
                }
                if (!a2 && !s2 && !c2 && e4 < r4 || c2 && n2 && i2 && !a2 && !s2 || u2 && n2 && i2 || !o2 && i2 || !l2) {
                  return -1;
                }
              }
              return 0;
            }
            function compareMultiple(e4, r4, t4) {
              var n2 = -1, a2 = e4.criteria, i2 = r4.criteria, s2 = a2.length, o2 = t4.length;
              while (++n2 < s2) {
                var u2 = compareAscending(a2[n2], i2[n2]);
                if (u2) {
                  if (n2 >= o2) {
                    return u2;
                  }
                  var l2 = t4[n2];
                  return u2 * (l2 == "desc" ? -1 : 1);
                }
              }
              return e4.index - r4.index;
            }
            function composeArgs(e4, t4, n2, a2) {
              var i2 = -1, s2 = e4.length, o2 = n2.length, u2 = -1, l2 = t4.length, c2 = Mr2(s2 - o2, 0), f2 = r3(l2 + c2), h2 = !a2;
              while (++u2 < l2) {
                f2[u2] = t4[u2];
              }
              while (++i2 < o2) {
                if (h2 || i2 < s2) {
                  f2[n2[i2]] = e4[i2];
                }
              }
              while (c2--) {
                f2[u2++] = e4[i2++];
              }
              return f2;
            }
            function composeArgsRight(e4, t4, n2, a2) {
              var i2 = -1, s2 = e4.length, o2 = -1, u2 = n2.length, l2 = -1, c2 = t4.length, f2 = Mr2(s2 - u2, 0), h2 = r3(f2 + c2), p2 = !a2;
              while (++i2 < f2) {
                h2[i2] = e4[i2];
              }
              var d2 = i2;
              while (++l2 < c2) {
                h2[d2 + l2] = t4[l2];
              }
              while (++o2 < u2) {
                if (p2 || i2 < s2) {
                  h2[d2 + n2[o2]] = e4[i2++];
                }
              }
              return h2;
            }
            function copyArray(e4, t4) {
              var n2 = -1, a2 = e4.length;
              t4 || (t4 = r3(a2));
              while (++n2 < a2) {
                t4[n2] = e4[n2];
              }
              return t4;
            }
            function copyObject(e4, r4, n2, a2) {
              var i2 = !n2;
              n2 || (n2 = {});
              var s2 = -1, o2 = r4.length;
              while (++s2 < o2) {
                var u2 = r4[s2];
                var l2 = a2 ? a2(n2[u2], e4[u2], u2, n2, e4) : t3;
                if (l2 === t3) {
                  l2 = e4[u2];
                }
                if (i2) {
                  baseAssignValue(n2, u2, l2);
                } else {
                  assignValue(n2, u2, l2);
                }
              }
              return n2;
            }
            function copySymbols(e4, r4) {
              return copyObject(e4, Ft(e4), r4);
            }
            function copySymbolsIn(e4, r4) {
              return copyObject(e4, Mt(e4), r4);
            }
            function createAggregator(e4, r4) {
              return function(t4, n2) {
                var a2 = Ln(t4) ? arrayAggregator : baseAggregator, i2 = r4 ? r4() : {};
                return a2(t4, e4, getIteratee(n2, 2), i2);
              };
            }
            function createAssigner(e4) {
              return baseRest(function(r4, n2) {
                var a2 = -1, i2 = n2.length, s2 = i2 > 1 ? n2[i2 - 1] : t3, o2 = i2 > 2 ? n2[2] : t3;
                s2 = e4.length > 3 && typeof s2 == "function" ? (i2--, s2) : t3;
                if (o2 && isIterateeCall(n2[0], n2[1], o2)) {
                  s2 = i2 < 3 ? t3 : s2;
                  i2 = 1;
                }
                r4 = rr2(r4);
                while (++a2 < i2) {
                  var u2 = n2[a2];
                  if (u2) {
                    e4(r4, u2, a2, s2);
                  }
                }
                return r4;
              });
            }
            function createBaseEach(e4, r4) {
              return function(t4, n2) {
                if (t4 == null) {
                  return t4;
                }
                if (!isArrayLike(t4)) {
                  return e4(t4, n2);
                }
                var a2 = t4.length, i2 = r4 ? a2 : -1, s2 = rr2(t4);
                while (r4 ? i2-- : ++i2 < a2) {
                  if (n2(s2[i2], i2, s2) === false) {
                    break;
                  }
                }
                return t4;
              };
            }
            function createBaseFor(e4) {
              return function(r4, t4, n2) {
                var a2 = -1, i2 = rr2(r4), s2 = n2(r4), o2 = s2.length;
                while (o2--) {
                  var u2 = s2[e4 ? o2 : ++a2];
                  if (t4(i2[u2], u2, i2) === false) {
                    break;
                  }
                }
                return r4;
              };
            }
            function createBind(e4, r4, t4) {
              var n2 = r4 & g, a2 = createCtor(e4);
              function wrapper() {
                var r5 = this && this !== at && this instanceof wrapper ? a2 : e4;
                return r5.apply(n2 ? t4 : this, arguments);
              }
              return wrapper;
            }
            function createCaseFirst(e4) {
              return function(r4) {
                r4 = toString(r4);
                var n2 = hasUnicode(r4) ? stringToArray(r4) : t3;
                var a2 = n2 ? n2[0] : r4.charAt(0);
                var i2 = n2 ? castSlice(n2, 1).join("") : r4.slice(1);
                return a2[e4]() + i2;
              };
            }
            function createCompounder(e4) {
              return function(r4) {
                return arrayReduce(words(deburr(r4).replace(Dr, "")), e4, "");
              };
            }
            function createCtor(e4) {
              return function() {
                var r4 = arguments;
                switch (r4.length) {
                  case 0:
                    return new e4();
                  case 1:
                    return new e4(r4[0]);
                  case 2:
                    return new e4(r4[0], r4[1]);
                  case 3:
                    return new e4(r4[0], r4[1], r4[2]);
                  case 4:
                    return new e4(r4[0], r4[1], r4[2], r4[3]);
                  case 5:
                    return new e4(r4[0], r4[1], r4[2], r4[3], r4[4]);
                  case 6:
                    return new e4(r4[0], r4[1], r4[2], r4[3], r4[4], r4[5]);
                  case 7:
                    return new e4(r4[0], r4[1], r4[2], r4[3], r4[4], r4[5], r4[6]);
                }
                var t4 = jt(e4.prototype), n2 = e4.apply(t4, r4);
                return isObject(n2) ? n2 : t4;
              };
            }
            function createCurry(e4, n2, a2) {
              var i2 = createCtor(e4);
              function wrapper() {
                var s2 = arguments.length, o2 = r3(s2), u2 = s2, l2 = getHolder(wrapper);
                while (u2--) {
                  o2[u2] = arguments[u2];
                }
                var c2 = s2 < 3 && o2[0] !== l2 && o2[s2 - 1] !== l2 ? [] : replaceHolders(o2, l2);
                s2 -= c2.length;
                if (s2 < a2) {
                  return createRecurry(e4, n2, createHybrid, wrapper.placeholder, t3, o2, c2, t3, t3, a2 - s2);
                }
                var f2 = this && this !== at && this instanceof wrapper ? i2 : e4;
                return apply(f2, this, o2);
              }
              return wrapper;
            }
            function createFind(e4) {
              return function(r4, n2, a2) {
                var i2 = rr2(r4);
                if (!isArrayLike(r4)) {
                  var s2 = getIteratee(n2, 3);
                  r4 = keys(r4);
                  n2 = function(e5) {
                    return s2(i2[e5], e5, i2);
                  };
                }
                var o2 = e4(r4, n2, a2);
                return o2 > -1 ? i2[s2 ? r4[o2] : o2] : t3;
              };
            }
            function createFlow(e4) {
              return flatRest(function(r4) {
                var n2 = r4.length, a2 = n2, i2 = LodashWrapper.prototype.thru;
                if (e4) {
                  r4.reverse();
                }
                while (a2--) {
                  var o2 = r4[a2];
                  if (typeof o2 != "function") {
                    throw new ar2(s);
                  }
                  if (i2 && !u2 && getFuncName(o2) == "wrapper") {
                    var u2 = new LodashWrapper([], true);
                  }
                }
                a2 = u2 ? a2 : n2;
                while (++a2 < n2) {
                  o2 = r4[a2];
                  var l2 = getFuncName(o2), c2 = l2 == "wrapper" ? Bt(o2) : t3;
                  if (c2 && isLaziable(c2[0]) && c2[1] == (I | m | w | A) && !c2[4].length && c2[9] == 1) {
                    u2 = u2[getFuncName(c2[0])].apply(u2, c2[3]);
                  } else {
                    u2 = o2.length == 1 && isLaziable(o2) ? u2[l2]() : u2.thru(o2);
                  }
                }
                return function() {
                  var e5 = arguments, t4 = e5[0];
                  if (u2 && e5.length == 1 && Ln(t4)) {
                    return u2.plant(t4).value();
                  }
                  var a3 = 0, i3 = n2 ? r4[a3].apply(this, e5) : t4;
                  while (++a3 < n2) {
                    i3 = r4[a3].call(this, i3);
                  }
                  return i3;
                };
              });
            }
            function createHybrid(e4, n2, a2, i2, s2, o2, u2, l2, c2, f2) {
              var h2 = n2 & I, p2 = n2 & g, d2 = n2 & v, y2 = n2 & (m | _), b2 = n2 & x, w2 = d2 ? t3 : createCtor(e4);
              function wrapper() {
                var t4 = arguments.length, g2 = r3(t4), v2 = t4;
                while (v2--) {
                  g2[v2] = arguments[v2];
                }
                if (y2) {
                  var m2 = getHolder(wrapper), _2 = countHolders(g2, m2);
                }
                if (i2) {
                  g2 = composeArgs(g2, i2, s2, y2);
                }
                if (o2) {
                  g2 = composeArgsRight(g2, o2, u2, y2);
                }
                t4 -= _2;
                if (y2 && t4 < f2) {
                  var S2 = replaceHolders(g2, m2);
                  return createRecurry(e4, n2, createHybrid, wrapper.placeholder, a2, g2, S2, l2, c2, f2 - t4);
                }
                var I2 = p2 ? a2 : this, A2 = d2 ? I2[e4] : e4;
                t4 = g2.length;
                if (l2) {
                  g2 = reorder(g2, l2);
                } else if (b2 && t4 > 1) {
                  g2.reverse();
                }
                if (h2 && c2 < t4) {
                  g2.length = c2;
                }
                if (this && this !== at && this instanceof wrapper) {
                  A2 = w2 || createCtor(A2);
                }
                return A2.apply(I2, g2);
              }
              return wrapper;
            }
            function createInverter(e4, r4) {
              return function(t4, n2) {
                return baseInverter(t4, e4, r4(n2), {});
              };
            }
            function createMathOperation(e4, r4) {
              return function(n2, a2) {
                var i2;
                if (n2 === t3 && a2 === t3) {
                  return r4;
                }
                if (n2 !== t3) {
                  i2 = n2;
                }
                if (a2 !== t3) {
                  if (i2 === t3) {
                    return a2;
                  }
                  if (typeof n2 == "string" || typeof a2 == "string") {
                    n2 = baseToString(n2);
                    a2 = baseToString(a2);
                  } else {
                    n2 = baseToNumber(n2);
                    a2 = baseToNumber(a2);
                  }
                  i2 = e4(n2, a2);
                }
                return i2;
              };
            }
            function createOver(e4) {
              return flatRest(function(r4) {
                r4 = arrayMap(r4, baseUnary(getIteratee()));
                return baseRest(function(t4) {
                  var n2 = this;
                  return e4(r4, function(e5) {
                    return apply(e5, n2, t4);
                  });
                });
              });
            }
            function createPadding(e4, r4) {
              r4 = r4 === t3 ? " " : baseToString(r4);
              var n2 = r4.length;
              if (n2 < 2) {
                return n2 ? baseRepeat(r4, e4) : r4;
              }
              var a2 = baseRepeat(r4, Cr2(e4 / stringSize(r4)));
              return hasUnicode(r4) ? castSlice(stringToArray(a2), 0, e4).join("") : a2.slice(0, e4);
            }
            function createPartial(e4, t4, n2, a2) {
              var i2 = t4 & g, s2 = createCtor(e4);
              function wrapper() {
                var t5 = -1, o2 = arguments.length, u2 = -1, l2 = a2.length, c2 = r3(l2 + o2), f2 = this && this !== at && this instanceof wrapper ? s2 : e4;
                while (++u2 < l2) {
                  c2[u2] = a2[u2];
                }
                while (o2--) {
                  c2[u2++] = arguments[++t5];
                }
                return apply(f2, i2 ? n2 : this, c2);
              }
              return wrapper;
            }
            function createRange(e4) {
              return function(r4, n2, a2) {
                if (a2 && typeof a2 != "number" && isIterateeCall(r4, n2, a2)) {
                  n2 = a2 = t3;
                }
                r4 = toFinite(r4);
                if (n2 === t3) {
                  n2 = r4;
                  r4 = 0;
                } else {
                  n2 = toFinite(n2);
                }
                a2 = a2 === t3 ? r4 < n2 ? 1 : -1 : toFinite(a2);
                return baseRange(r4, n2, a2, e4);
              };
            }
            function createRelationalOperation(e4) {
              return function(r4, t4) {
                if (!(typeof r4 == "string" && typeof t4 == "string")) {
                  r4 = toNumber(r4);
                  t4 = toNumber(t4);
                }
                return e4(r4, t4);
              };
            }
            function createRecurry(e4, r4, n2, a2, i2, s2, o2, u2, l2, c2) {
              var f2 = r4 & m, h2 = f2 ? o2 : t3, p2 = f2 ? t3 : o2, d2 = f2 ? s2 : t3, y2 = f2 ? t3 : s2;
              r4 |= f2 ? w : S;
              r4 &= ~(f2 ? S : w);
              if (!(r4 & b)) {
                r4 &= ~(g | v);
              }
              var _2 = [e4, r4, i2, d2, h2, y2, p2, u2, l2, c2];
              var I2 = n2.apply(t3, _2);
              if (isLaziable(e4)) {
                qt(I2, _2);
              }
              I2.placeholder = a2;
              return setWrapToString(I2, e4, r4);
            }
            function createRound(e4) {
              var r4 = er2[e4];
              return function(e5, t4) {
                e5 = toNumber(e5);
                t4 = t4 == null ? 0 : qr2(toInteger(t4), 292);
                if (t4 && zr2(e5)) {
                  var n2 = (toString(e5) + "e").split("e"), a2 = r4(n2[0] + "e" + (+n2[1] + t4));
                  n2 = (toString(a2) + "e").split("e");
                  return +(n2[0] + "e" + (+n2[1] - t4));
                }
                return r4(e5);
              };
            }
            var zt = !(tt2 && 1 / setToArray(new tt2([, -0]))[1] == T) ? noop : function(e4) {
              return new tt2(e4);
            };
            function createToPairs(e4) {
              return function(r4) {
                var t4 = Dt(r4);
                if (t4 == Z) {
                  return mapToArray(r4);
                }
                if (t4 == ne) {
                  return setToPairs(r4);
                }
                return baseToPairs(r4, e4(r4));
              };
            }
            function createWrap(e4, r4, n2, a2, i2, o2, u2, l2) {
              var c2 = r4 & v;
              if (!c2 && typeof e4 != "function") {
                throw new ar2(s);
              }
              var f2 = a2 ? a2.length : 0;
              if (!f2) {
                r4 &= ~(w | S);
                a2 = i2 = t3;
              }
              u2 = u2 === t3 ? u2 : Mr2(toInteger(u2), 0);
              l2 = l2 === t3 ? l2 : toInteger(l2);
              f2 -= i2 ? i2.length : 0;
              if (r4 & S) {
                var h2 = a2, p2 = i2;
                a2 = i2 = t3;
              }
              var d2 = c2 ? t3 : Bt(e4);
              var y2 = [e4, r4, n2, a2, i2, h2, p2, o2, u2, l2];
              if (d2) {
                mergeData(y2, d2);
              }
              e4 = y2[0];
              r4 = y2[1];
              n2 = y2[2];
              a2 = y2[3];
              i2 = y2[4];
              l2 = y2[9] = y2[9] === t3 ? c2 ? 0 : e4.length : Mr2(y2[9] - f2, 0);
              if (!l2 && r4 & (m | _)) {
                r4 &= ~(m | _);
              }
              if (!r4 || r4 == g) {
                var b2 = createBind(e4, r4, n2);
              } else if (r4 == m || r4 == _) {
                b2 = createCurry(e4, r4, l2);
              } else if ((r4 == w || r4 == (g | w)) && !i2.length) {
                b2 = createPartial(e4, r4, n2, a2);
              } else {
                b2 = createHybrid.apply(t3, y2);
              }
              var I2 = d2 ? Ct : qt;
              return setWrapToString(I2(b2, y2), e4, r4);
            }
            function customDefaultsAssignIn(e4, r4, n2, a2) {
              if (e4 === t3 || eq(e4, or2[n2]) && !cr2.call(a2, n2)) {
                return r4;
              }
              return e4;
            }
            function customDefaultsMerge(e4, r4, n2, a2, i2, s2) {
              if (isObject(e4) && isObject(r4)) {
                s2.set(r4, e4);
                baseMerge(e4, r4, t3, customDefaultsMerge, s2);
                s2["delete"](r4);
              }
              return e4;
            }
            function customOmitClone(e4) {
              return isPlainObject(e4) ? t3 : e4;
            }
            function equalArrays(e4, r4, n2, a2, i2, s2) {
              var o2 = n2 & d, u2 = e4.length, l2 = r4.length;
              if (u2 != l2 && !(o2 && l2 > u2)) {
                return false;
              }
              var c2 = s2.get(e4);
              var f2 = s2.get(r4);
              if (c2 && f2) {
                return c2 == r4 && f2 == e4;
              }
              var h2 = -1, p2 = true, g2 = n2 & y ? new SetCache() : t3;
              s2.set(e4, r4);
              s2.set(r4, e4);
              while (++h2 < u2) {
                var v2 = e4[h2], b2 = r4[h2];
                if (a2) {
                  var m2 = o2 ? a2(b2, v2, h2, r4, e4, s2) : a2(v2, b2, h2, e4, r4, s2);
                }
                if (m2 !== t3) {
                  if (m2) {
                    continue;
                  }
                  p2 = false;
                  break;
                }
                if (g2) {
                  if (!arraySome(r4, function(e5, r5) {
                    if (!cacheHas(g2, r5) && (v2 === e5 || i2(v2, e5, n2, a2, s2))) {
                      return g2.push(r5);
                    }
                  })) {
                    p2 = false;
                    break;
                  }
                } else if (!(v2 === b2 || i2(v2, b2, n2, a2, s2))) {
                  p2 = false;
                  break;
                }
              }
              s2["delete"](e4);
              s2["delete"](r4);
              return p2;
            }
            function equalByTag(e4, r4, t4, n2, a2, i2, s2) {
              switch (t4) {
                case ce:
                  if (e4.byteLength != r4.byteLength || e4.byteOffset != r4.byteOffset) {
                    return false;
                  }
                  e4 = e4.buffer;
                  r4 = r4.buffer;
                case le:
                  if (e4.byteLength != r4.byteLength || !i2(new mr2(e4), new mr2(r4))) {
                    return false;
                  }
                  return true;
                case U:
                case N:
                case X:
                  return eq(+e4, +r4);
                case G:
                  return e4.name == r4.name && e4.message == r4.message;
                case te:
                case ae:
                  return e4 == r4 + "";
                case Z:
                  var o2 = mapToArray;
                case ne:
                  var u2 = n2 & d;
                  o2 || (o2 = setToArray);
                  if (e4.size != r4.size && !u2) {
                    return false;
                  }
                  var l2 = s2.get(e4);
                  if (l2) {
                    return l2 == r4;
                  }
                  n2 |= y;
                  s2.set(e4, r4);
                  var c2 = equalArrays(o2(e4), o2(r4), n2, a2, i2, s2);
                  s2["delete"](e4);
                  return c2;
                case ie:
                  if (xt) {
                    return xt.call(e4) == xt.call(r4);
                  }
              }
              return false;
            }
            function equalObjects(e4, r4, n2, a2, i2, s2) {
              var o2 = n2 & d, u2 = getAllKeys(e4), l2 = u2.length, c2 = getAllKeys(r4), f2 = c2.length;
              if (l2 != f2 && !o2) {
                return false;
              }
              var h2 = l2;
              while (h2--) {
                var p2 = u2[h2];
                if (!(o2 ? p2 in r4 : cr2.call(r4, p2))) {
                  return false;
                }
              }
              var y2 = s2.get(e4);
              var g2 = s2.get(r4);
              if (y2 && g2) {
                return y2 == r4 && g2 == e4;
              }
              var v2 = true;
              s2.set(e4, r4);
              s2.set(r4, e4);
              var b2 = o2;
              while (++h2 < l2) {
                p2 = u2[h2];
                var m2 = e4[p2], _2 = r4[p2];
                if (a2) {
                  var w2 = o2 ? a2(_2, m2, p2, r4, e4, s2) : a2(m2, _2, p2, e4, r4, s2);
                }
                if (!(w2 === t3 ? m2 === _2 || i2(m2, _2, n2, a2, s2) : w2)) {
                  v2 = false;
                  break;
                }
                b2 || (b2 = p2 == "constructor");
              }
              if (v2 && !b2) {
                var S2 = e4.constructor, I2 = r4.constructor;
                if (S2 != I2 && ("constructor" in e4 && "constructor" in r4) && !(typeof S2 == "function" && S2 instanceof S2 && typeof I2 == "function" && I2 instanceof I2)) {
                  v2 = false;
                }
              }
              s2["delete"](e4);
              s2["delete"](r4);
              return v2;
            }
            function flatRest(e4) {
              return Ut(overRest(e4, t3, flatten), e4 + "");
            }
            function getAllKeys(e4) {
              return baseGetAllKeys(e4, keys, Ft);
            }
            function getAllKeysIn(e4) {
              return baseGetAllKeys(e4, keysIn, Mt);
            }
            var Bt = !st2 ? noop : function(e4) {
              return st2.get(e4);
            };
            function getFuncName(e4) {
              var r4 = e4.name + "", t4 = ut2[r4], n2 = cr2.call(ut2, r4) ? t4.length : 0;
              while (n2--) {
                var a2 = t4[n2], i2 = a2.func;
                if (i2 == null || i2 == e4) {
                  return a2.name;
                }
              }
              return r4;
            }
            function getHolder(e4) {
              var r4 = cr2.call(lodash, "placeholder") ? lodash : e4;
              return r4.placeholder;
            }
            function getIteratee() {
              var e4 = lodash.iteratee || iteratee;
              e4 = e4 === iteratee ? baseIteratee : e4;
              return arguments.length ? e4(arguments[0], arguments[1]) : e4;
            }
            function getMapData(e4, r4) {
              var t4 = e4.__data__;
              return isKeyable(r4) ? t4[typeof r4 == "string" ? "string" : "hash"] : t4.map;
            }
            function getMatchData(e4) {
              var r4 = keys(e4), t4 = r4.length;
              while (t4--) {
                var n2 = r4[t4], a2 = e4[n2];
                r4[t4] = [n2, a2, isStrictComparable(a2)];
              }
              return r4;
            }
            function getNative(e4, r4) {
              var n2 = getValue(e4, r4);
              return baseIsNative(n2) ? n2 : t3;
            }
            function getRawTag(e4) {
              var r4 = cr2.call(e4, jr2), n2 = e4[jr2];
              try {
                e4[jr2] = t3;
                var a2 = true;
              } catch (e5) {
              }
              var i2 = pr2.call(e4);
              if (a2) {
                if (r4) {
                  e4[jr2] = n2;
                } else {
                  delete e4[jr2];
                }
              }
              return i2;
            }
            var Ft = !Wr2 ? stubArray : function(e4) {
              if (e4 == null) {
                return [];
              }
              e4 = rr2(e4);
              return arrayFilter(Wr2(e4), function(r4) {
                return Ir2.call(e4, r4);
              });
            };
            var Mt = !Wr2 ? stubArray : function(e4) {
              var r4 = [];
              while (e4) {
                arrayPush(r4, Ft(e4));
                e4 = wr2(e4);
              }
              return r4;
            };
            var Dt = baseGetTag;
            if (Xr2 && Dt(new Xr2(new ArrayBuffer(1))) != ce || Yr2 && Dt(new Yr2()) != Z || Qr2 && Dt(Qr2.resolve()) != ee || tt2 && Dt(new tt2()) != ne || nt2 && Dt(new nt2()) != oe) {
              Dt = function(e4) {
                var r4 = baseGetTag(e4), n2 = r4 == Q ? e4.constructor : t3, a2 = n2 ? toSource(n2) : "";
                if (a2) {
                  switch (a2) {
                    case lt2:
                      return ce;
                    case gt2:
                      return Z;
                    case _t2:
                      return ee;
                    case St:
                      return ne;
                    case It:
                      return oe;
                  }
                }
                return r4;
              };
            }
            function getView(e4, r4, t4) {
              var n2 = -1, a2 = t4.length;
              while (++n2 < a2) {
                var i2 = t4[n2], s2 = i2.size;
                switch (i2.type) {
                  case "drop":
                    e4 += s2;
                    break;
                  case "dropRight":
                    r4 -= s2;
                    break;
                  case "take":
                    r4 = qr2(r4, e4 + s2);
                    break;
                  case "takeRight":
                    e4 = Mr2(e4, r4 - s2);
                    break;
                }
              }
              return { start: e4, end: r4 };
            }
            function getWrapDetails(e4) {
              var r4 = e4.match(Fe);
              return r4 ? r4[1].split(Me) : [];
            }
            function hasPath(e4, r4, t4) {
              r4 = castPath(r4, e4);
              var n2 = -1, a2 = r4.length, i2 = false;
              while (++n2 < a2) {
                var s2 = toKey(r4[n2]);
                if (!(i2 = e4 != null && t4(e4, s2))) {
                  break;
                }
                e4 = e4[s2];
              }
              if (i2 || ++n2 != a2) {
                return i2;
              }
              a2 = e4 == null ? 0 : e4.length;
              return !!a2 && isLength(a2) && isIndex(s2, a2) && (Ln(e4) || Rn(e4));
            }
            function initCloneArray(e4) {
              var r4 = e4.length, t4 = new e4.constructor(r4);
              if (r4 && typeof e4[0] == "string" && cr2.call(e4, "index")) {
                t4.index = e4.index;
                t4.input = e4.input;
              }
              return t4;
            }
            function initCloneObject(e4) {
              return typeof e4.constructor == "function" && !isPrototype(e4) ? jt(wr2(e4)) : {};
            }
            function initCloneByTag(e4, r4, t4) {
              var n2 = e4.constructor;
              switch (r4) {
                case le:
                  return cloneArrayBuffer(e4);
                case U:
                case N:
                  return new n2(+e4);
                case ce:
                  return cloneDataView(e4, t4);
                case fe:
                case he:
                case pe:
                case de:
                case ye:
                case ge:
                case ve:
                case be:
                case me:
                  return cloneTypedArray(e4, t4);
                case Z:
                  return new n2();
                case X:
                case ae:
                  return new n2(e4);
                case te:
                  return cloneRegExp(e4);
                case ne:
                  return new n2();
                case ie:
                  return cloneSymbol(e4);
              }
            }
            function insertWrapDetails(e4, r4) {
              var t4 = r4.length;
              if (!t4) {
                return e4;
              }
              var n2 = t4 - 1;
              r4[n2] = (t4 > 1 ? "& " : "") + r4[n2];
              r4 = r4.join(t4 > 2 ? ", " : " ");
              return e4.replace(Be, "{\n/* [wrapped with " + r4 + "] */\n");
            }
            function isFlattenable(e4) {
              return Ln(e4) || Rn(e4) || !!(xr2 && e4 && e4[xr2]);
            }
            function isIndex(e4, r4) {
              var t4 = typeof e4;
              r4 = r4 == null ? W : r4;
              return !!r4 && (t4 == "number" || t4 != "symbol" && Je.test(e4)) && (e4 > -1 && e4 % 1 == 0 && e4 < r4);
            }
            function isIterateeCall(e4, r4, t4) {
              if (!isObject(t4)) {
                return false;
              }
              var n2 = typeof r4;
              if (n2 == "number" ? isArrayLike(t4) && isIndex(r4, t4.length) : n2 == "string" && r4 in t4) {
                return eq(t4[r4], e4);
              }
              return false;
            }
            function isKey(e4, r4) {
              if (Ln(e4)) {
                return false;
              }
              var t4 = typeof e4;
              if (t4 == "number" || t4 == "symbol" || t4 == "boolean" || e4 == null || isSymbol(e4)) {
                return true;
              }
              return Le.test(e4) || !Re.test(e4) || r4 != null && e4 in rr2(r4);
            }
            function isKeyable(e4) {
              var r4 = typeof e4;
              return r4 == "string" || r4 == "number" || r4 == "symbol" || r4 == "boolean" ? e4 !== "__proto__" : e4 === null;
            }
            function isLaziable(e4) {
              var r4 = getFuncName(e4), t4 = lodash[r4];
              if (typeof t4 != "function" || !(r4 in LazyWrapper.prototype)) {
                return false;
              }
              if (e4 === t4) {
                return true;
              }
              var n2 = Bt(t4);
              return !!n2 && e4 === n2[0];
            }
            function isMasked(e4) {
              return !!hr2 && hr2 in e4;
            }
            var Kt = ur2 ? isFunction : stubFalse;
            function isPrototype(e4) {
              var r4 = e4 && e4.constructor, t4 = typeof r4 == "function" && r4.prototype || or2;
              return e4 === t4;
            }
            function isStrictComparable(e4) {
              return e4 === e4 && !isObject(e4);
            }
            function matchesStrictComparable(e4, r4) {
              return function(n2) {
                if (n2 == null) {
                  return false;
                }
                return n2[e4] === r4 && (r4 !== t3 || e4 in rr2(n2));
              };
            }
            function memoizeCapped(e4) {
              var r4 = memoize(e4, function(e5) {
                if (t4.size === l) {
                  t4.clear();
                }
                return e5;
              });
              var t4 = r4.cache;
              return r4;
            }
            function mergeData(e4, r4) {
              var t4 = e4[1], n2 = r4[1], a2 = t4 | n2, i2 = a2 < (g | v | I);
              var s2 = n2 == I && t4 == m || n2 == I && t4 == A && e4[7].length <= r4[8] || n2 == (I | A) && r4[7].length <= r4[8] && t4 == m;
              if (!(i2 || s2)) {
                return e4;
              }
              if (n2 & g) {
                e4[2] = r4[2];
                a2 |= t4 & g ? 0 : b;
              }
              var o2 = r4[3];
              if (o2) {
                var u2 = e4[3];
                e4[3] = u2 ? composeArgs(u2, o2, r4[4]) : o2;
                e4[4] = u2 ? replaceHolders(e4[3], c) : r4[4];
              }
              o2 = r4[5];
              if (o2) {
                u2 = e4[5];
                e4[5] = u2 ? composeArgsRight(u2, o2, r4[6]) : o2;
                e4[6] = u2 ? replaceHolders(e4[5], c) : r4[6];
              }
              o2 = r4[7];
              if (o2) {
                e4[7] = o2;
              }
              if (n2 & I) {
                e4[8] = e4[8] == null ? r4[8] : qr2(e4[8], r4[8]);
              }
              if (e4[9] == null) {
                e4[9] = r4[9];
              }
              e4[0] = r4[0];
              e4[1] = a2;
              return e4;
            }
            function nativeKeysIn(e4) {
              var r4 = [];
              if (e4 != null) {
                for (var t4 in rr2(e4)) {
                  r4.push(t4);
                }
              }
              return r4;
            }
            function objectToString(e4) {
              return pr2.call(e4);
            }
            function overRest(e4, n2, a2) {
              n2 = Mr2(n2 === t3 ? e4.length - 1 : n2, 0);
              return function() {
                var t4 = arguments, i2 = -1, s2 = Mr2(t4.length - n2, 0), o2 = r3(s2);
                while (++i2 < s2) {
                  o2[i2] = t4[n2 + i2];
                }
                i2 = -1;
                var u2 = r3(n2 + 1);
                while (++i2 < n2) {
                  u2[i2] = t4[i2];
                }
                u2[n2] = a2(o2);
                return apply(e4, this, u2);
              };
            }
            function parent(e4, r4) {
              return r4.length < 2 ? e4 : baseGet(e4, baseSlice(r4, 0, -1));
            }
            function reorder(e4, r4) {
              var n2 = e4.length, a2 = qr2(r4.length, n2), i2 = copyArray(e4);
              while (a2--) {
                var s2 = r4[a2];
                e4[a2] = isIndex(s2, n2) ? i2[s2] : t3;
              }
              return e4;
            }
            function safeGet(e4, r4) {
              if (r4 === "constructor" && typeof e4[r4] === "function") {
                return;
              }
              if (r4 == "__proto__") {
                return;
              }
              return e4[r4];
            }
            var qt = shortOut(Ct);
            var Vt = Lr2 || function(e4, r4) {
              return at.setTimeout(e4, r4);
            };
            var Ut = shortOut(Tt);
            function setWrapToString(e4, r4, t4) {
              var n2 = r4 + "";
              return Ut(e4, insertWrapDetails(n2, updateWrapDetails(getWrapDetails(n2), t4)));
            }
            function shortOut(e4) {
              var r4 = 0, n2 = 0;
              return function() {
                var a2 = Vr2(), i2 = E - (a2 - n2);
                n2 = a2;
                if (i2 > 0) {
                  if (++r4 >= O) {
                    return arguments[0];
                  }
                } else {
                  r4 = 0;
                }
                return e4.apply(t3, arguments);
              };
            }
            function shuffleSelf(e4, r4) {
              var n2 = -1, a2 = e4.length, i2 = a2 - 1;
              r4 = r4 === t3 ? a2 : r4;
              while (++n2 < r4) {
                var s2 = baseRandom(n2, i2), o2 = e4[s2];
                e4[s2] = e4[n2];
                e4[n2] = o2;
              }
              e4.length = r4;
              return e4;
            }
            var Nt = memoizeCapped(function(e4) {
              var r4 = [];
              if (e4.charCodeAt(0) === 46) {
                r4.push("");
              }
              e4.replace(Ce, function(e5, t4, n2, a2) {
                r4.push(n2 ? a2.replace(qe, "$1") : t4 || e5);
              });
              return r4;
            });
            function toKey(e4) {
              if (typeof e4 == "string" || isSymbol(e4)) {
                return e4;
              }
              var r4 = e4 + "";
              return r4 == "0" && 1 / e4 == -T ? "-0" : r4;
            }
            function toSource(e4) {
              if (e4 != null) {
                try {
                  return lr2.call(e4);
                } catch (e5) {
                }
                try {
                  return e4 + "";
                } catch (e5) {
                }
              }
              return "";
            }
            function updateWrapDetails(e4, r4) {
              arrayEach(D, function(t4) {
                var n2 = "_." + t4[0];
                if (r4 & t4[1] && !arrayIncludes(e4, n2)) {
                  e4.push(n2);
                }
              });
              return e4.sort();
            }
            function wrapperClone(e4) {
              if (e4 instanceof LazyWrapper) {
                return e4.clone();
              }
              var r4 = new LodashWrapper(e4.__wrapped__, e4.__chain__);
              r4.__actions__ = copyArray(e4.__actions__);
              r4.__index__ = e4.__index__;
              r4.__values__ = e4.__values__;
              return r4;
            }
            function chunk(e4, n2, a2) {
              if (a2 ? isIterateeCall(e4, n2, a2) : n2 === t3) {
                n2 = 1;
              } else {
                n2 = Mr2(toInteger(n2), 0);
              }
              var i2 = e4 == null ? 0 : e4.length;
              if (!i2 || n2 < 1) {
                return [];
              }
              var s2 = 0, o2 = 0, u2 = r3(Cr2(i2 / n2));
              while (s2 < i2) {
                u2[o2++] = baseSlice(e4, s2, s2 += n2);
              }
              return u2;
            }
            function compact(e4) {
              var r4 = -1, t4 = e4 == null ? 0 : e4.length, n2 = 0, a2 = [];
              while (++r4 < t4) {
                var i2 = e4[r4];
                if (i2) {
                  a2[n2++] = i2;
                }
              }
              return a2;
            }
            function concat() {
              var e4 = arguments.length;
              if (!e4) {
                return [];
              }
              var t4 = r3(e4 - 1), n2 = arguments[0], a2 = e4;
              while (a2--) {
                t4[a2 - 1] = arguments[a2];
              }
              return arrayPush(Ln(n2) ? copyArray(n2) : [n2], baseFlatten(t4, 1));
            }
            var Ht = baseRest(function(e4, r4) {
              return isArrayLikeObject(e4) ? baseDifference(e4, baseFlatten(r4, 1, isArrayLikeObject, true)) : [];
            });
            var Gt = baseRest(function(e4, r4) {
              var n2 = last(r4);
              if (isArrayLikeObject(n2)) {
                n2 = t3;
              }
              return isArrayLikeObject(e4) ? baseDifference(e4, baseFlatten(r4, 1, isArrayLikeObject, true), getIteratee(n2, 2)) : [];
            });
            var $t = baseRest(function(e4, r4) {
              var n2 = last(r4);
              if (isArrayLikeObject(n2)) {
                n2 = t3;
              }
              return isArrayLikeObject(e4) ? baseDifference(e4, baseFlatten(r4, 1, isArrayLikeObject, true), t3, n2) : [];
            });
            function drop(e4, r4, n2) {
              var a2 = e4 == null ? 0 : e4.length;
              if (!a2) {
                return [];
              }
              r4 = n2 || r4 === t3 ? 1 : toInteger(r4);
              return baseSlice(e4, r4 < 0 ? 0 : r4, a2);
            }
            function dropRight(e4, r4, n2) {
              var a2 = e4 == null ? 0 : e4.length;
              if (!a2) {
                return [];
              }
              r4 = n2 || r4 === t3 ? 1 : toInteger(r4);
              r4 = a2 - r4;
              return baseSlice(e4, 0, r4 < 0 ? 0 : r4);
            }
            function dropRightWhile(e4, r4) {
              return e4 && e4.length ? baseWhile(e4, getIteratee(r4, 3), true, true) : [];
            }
            function dropWhile(e4, r4) {
              return e4 && e4.length ? baseWhile(e4, getIteratee(r4, 3), true) : [];
            }
            function fill(e4, r4, t4, n2) {
              var a2 = e4 == null ? 0 : e4.length;
              if (!a2) {
                return [];
              }
              if (t4 && typeof t4 != "number" && isIterateeCall(e4, r4, t4)) {
                t4 = 0;
                n2 = a2;
              }
              return baseFill(e4, r4, t4, n2);
            }
            function findIndex(e4, r4, t4) {
              var n2 = e4 == null ? 0 : e4.length;
              if (!n2) {
                return -1;
              }
              var a2 = t4 == null ? 0 : toInteger(t4);
              if (a2 < 0) {
                a2 = Mr2(n2 + a2, 0);
              }
              return baseFindIndex(e4, getIteratee(r4, 3), a2);
            }
            function findLastIndex(e4, r4, n2) {
              var a2 = e4 == null ? 0 : e4.length;
              if (!a2) {
                return -1;
              }
              var i2 = a2 - 1;
              if (n2 !== t3) {
                i2 = toInteger(n2);
                i2 = n2 < 0 ? Mr2(a2 + i2, 0) : qr2(i2, a2 - 1);
              }
              return baseFindIndex(e4, getIteratee(r4, 3), i2, true);
            }
            function flatten(e4) {
              var r4 = e4 == null ? 0 : e4.length;
              return r4 ? baseFlatten(e4, 1) : [];
            }
            function flattenDeep(e4) {
              var r4 = e4 == null ? 0 : e4.length;
              return r4 ? baseFlatten(e4, T) : [];
            }
            function flattenDepth(e4, r4) {
              var n2 = e4 == null ? 0 : e4.length;
              if (!n2) {
                return [];
              }
              r4 = r4 === t3 ? 1 : toInteger(r4);
              return baseFlatten(e4, r4);
            }
            function fromPairs(e4) {
              var r4 = -1, t4 = e4 == null ? 0 : e4.length, n2 = {};
              while (++r4 < t4) {
                var a2 = e4[r4];
                n2[a2[0]] = a2[1];
              }
              return n2;
            }
            function head(e4) {
              return e4 && e4.length ? e4[0] : t3;
            }
            function indexOf(e4, r4, t4) {
              var n2 = e4 == null ? 0 : e4.length;
              if (!n2) {
                return -1;
              }
              var a2 = t4 == null ? 0 : toInteger(t4);
              if (a2 < 0) {
                a2 = Mr2(n2 + a2, 0);
              }
              return baseIndexOf(e4, r4, a2);
            }
            function initial(e4) {
              var r4 = e4 == null ? 0 : e4.length;
              return r4 ? baseSlice(e4, 0, -1) : [];
            }
            var Jt = baseRest(function(e4) {
              var r4 = arrayMap(e4, castArrayLikeObject);
              return r4.length && r4[0] === e4[0] ? baseIntersection(r4) : [];
            });
            var Zt = baseRest(function(e4) {
              var r4 = last(e4), n2 = arrayMap(e4, castArrayLikeObject);
              if (r4 === last(n2)) {
                r4 = t3;
              } else {
                n2.pop();
              }
              return n2.length && n2[0] === e4[0] ? baseIntersection(n2, getIteratee(r4, 2)) : [];
            });
            var Xt = baseRest(function(e4) {
              var r4 = last(e4), n2 = arrayMap(e4, castArrayLikeObject);
              r4 = typeof r4 == "function" ? r4 : t3;
              if (r4) {
                n2.pop();
              }
              return n2.length && n2[0] === e4[0] ? baseIntersection(n2, t3, r4) : [];
            });
            function join(e4, r4) {
              return e4 == null ? "" : Br2.call(e4, r4);
            }
            function last(e4) {
              var r4 = e4 == null ? 0 : e4.length;
              return r4 ? e4[r4 - 1] : t3;
            }
            function lastIndexOf(e4, r4, n2) {
              var a2 = e4 == null ? 0 : e4.length;
              if (!a2) {
                return -1;
              }
              var i2 = a2;
              if (n2 !== t3) {
                i2 = toInteger(n2);
                i2 = i2 < 0 ? Mr2(a2 + i2, 0) : qr2(i2, a2 - 1);
              }
              return r4 === r4 ? strictLastIndexOf(e4, r4, i2) : baseFindIndex(e4, baseIsNaN, i2, true);
            }
            function nth(e4, r4) {
              return e4 && e4.length ? baseNth(e4, toInteger(r4)) : t3;
            }
            var Yt = baseRest(pullAll);
            function pullAll(e4, r4) {
              return e4 && e4.length && r4 && r4.length ? basePullAll(e4, r4) : e4;
            }
            function pullAllBy(e4, r4, t4) {
              return e4 && e4.length && r4 && r4.length ? basePullAll(e4, r4, getIteratee(t4, 2)) : e4;
            }
            function pullAllWith(e4, r4, n2) {
              return e4 && e4.length && r4 && r4.length ? basePullAll(e4, r4, t3, n2) : e4;
            }
            var Qt = flatRest(function(e4, r4) {
              var t4 = e4 == null ? 0 : e4.length, n2 = baseAt(e4, r4);
              basePullAt(e4, arrayMap(r4, function(e5) {
                return isIndex(e5, t4) ? +e5 : e5;
              }).sort(compareAscending));
              return n2;
            });
            function remove(e4, r4) {
              var t4 = [];
              if (!(e4 && e4.length)) {
                return t4;
              }
              var n2 = -1, a2 = [], i2 = e4.length;
              r4 = getIteratee(r4, 3);
              while (++n2 < i2) {
                var s2 = e4[n2];
                if (r4(s2, n2, e4)) {
                  t4.push(s2);
                  a2.push(n2);
                }
              }
              basePullAt(e4, a2);
              return t4;
            }
            function reverse(e4) {
              return e4 == null ? e4 : Zr2.call(e4);
            }
            function slice(e4, r4, n2) {
              var a2 = e4 == null ? 0 : e4.length;
              if (!a2) {
                return [];
              }
              if (n2 && typeof n2 != "number" && isIterateeCall(e4, r4, n2)) {
                r4 = 0;
                n2 = a2;
              } else {
                r4 = r4 == null ? 0 : toInteger(r4);
                n2 = n2 === t3 ? a2 : toInteger(n2);
              }
              return baseSlice(e4, r4, n2);
            }
            function sortedIndex(e4, r4) {
              return baseSortedIndex(e4, r4);
            }
            function sortedIndexBy(e4, r4, t4) {
              return baseSortedIndexBy(e4, r4, getIteratee(t4, 2));
            }
            function sortedIndexOf(e4, r4) {
              var t4 = e4 == null ? 0 : e4.length;
              if (t4) {
                var n2 = baseSortedIndex(e4, r4);
                if (n2 < t4 && eq(e4[n2], r4)) {
                  return n2;
                }
              }
              return -1;
            }
            function sortedLastIndex(e4, r4) {
              return baseSortedIndex(e4, r4, true);
            }
            function sortedLastIndexBy(e4, r4, t4) {
              return baseSortedIndexBy(e4, r4, getIteratee(t4, 2), true);
            }
            function sortedLastIndexOf(e4, r4) {
              var t4 = e4 == null ? 0 : e4.length;
              if (t4) {
                var n2 = baseSortedIndex(e4, r4, true) - 1;
                if (eq(e4[n2], r4)) {
                  return n2;
                }
              }
              return -1;
            }
            function sortedUniq(e4) {
              return e4 && e4.length ? baseSortedUniq(e4) : [];
            }
            function sortedUniqBy(e4, r4) {
              return e4 && e4.length ? baseSortedUniq(e4, getIteratee(r4, 2)) : [];
            }
            function tail(e4) {
              var r4 = e4 == null ? 0 : e4.length;
              return r4 ? baseSlice(e4, 1, r4) : [];
            }
            function take(e4, r4, n2) {
              if (!(e4 && e4.length)) {
                return [];
              }
              r4 = n2 || r4 === t3 ? 1 : toInteger(r4);
              return baseSlice(e4, 0, r4 < 0 ? 0 : r4);
            }
            function takeRight(e4, r4, n2) {
              var a2 = e4 == null ? 0 : e4.length;
              if (!a2) {
                return [];
              }
              r4 = n2 || r4 === t3 ? 1 : toInteger(r4);
              r4 = a2 - r4;
              return baseSlice(e4, r4 < 0 ? 0 : r4, a2);
            }
            function takeRightWhile(e4, r4) {
              return e4 && e4.length ? baseWhile(e4, getIteratee(r4, 3), false, true) : [];
            }
            function takeWhile(e4, r4) {
              return e4 && e4.length ? baseWhile(e4, getIteratee(r4, 3)) : [];
            }
            var en = baseRest(function(e4) {
              return baseUniq(baseFlatten(e4, 1, isArrayLikeObject, true));
            });
            var rn = baseRest(function(e4) {
              var r4 = last(e4);
              if (isArrayLikeObject(r4)) {
                r4 = t3;
              }
              return baseUniq(baseFlatten(e4, 1, isArrayLikeObject, true), getIteratee(r4, 2));
            });
            var tn = baseRest(function(e4) {
              var r4 = last(e4);
              r4 = typeof r4 == "function" ? r4 : t3;
              return baseUniq(baseFlatten(e4, 1, isArrayLikeObject, true), t3, r4);
            });
            function uniq(e4) {
              return e4 && e4.length ? baseUniq(e4) : [];
            }
            function uniqBy(e4, r4) {
              return e4 && e4.length ? baseUniq(e4, getIteratee(r4, 2)) : [];
            }
            function uniqWith(e4, r4) {
              r4 = typeof r4 == "function" ? r4 : t3;
              return e4 && e4.length ? baseUniq(e4, t3, r4) : [];
            }
            function unzip(e4) {
              if (!(e4 && e4.length)) {
                return [];
              }
              var r4 = 0;
              e4 = arrayFilter(e4, function(e5) {
                if (isArrayLikeObject(e5)) {
                  r4 = Mr2(e5.length, r4);
                  return true;
                }
              });
              return baseTimes(r4, function(r5) {
                return arrayMap(e4, baseProperty(r5));
              });
            }
            function unzipWith(e4, r4) {
              if (!(e4 && e4.length)) {
                return [];
              }
              var n2 = unzip(e4);
              if (r4 == null) {
                return n2;
              }
              return arrayMap(n2, function(e5) {
                return apply(r4, t3, e5);
              });
            }
            var nn = baseRest(function(e4, r4) {
              return isArrayLikeObject(e4) ? baseDifference(e4, r4) : [];
            });
            var an = baseRest(function(e4) {
              return baseXor(arrayFilter(e4, isArrayLikeObject));
            });
            var sn = baseRest(function(e4) {
              var r4 = last(e4);
              if (isArrayLikeObject(r4)) {
                r4 = t3;
              }
              return baseXor(arrayFilter(e4, isArrayLikeObject), getIteratee(r4, 2));
            });
            var on = baseRest(function(e4) {
              var r4 = last(e4);
              r4 = typeof r4 == "function" ? r4 : t3;
              return baseXor(arrayFilter(e4, isArrayLikeObject), t3, r4);
            });
            var un = baseRest(unzip);
            function zipObject(e4, r4) {
              return baseZipObject(e4 || [], r4 || [], assignValue);
            }
            function zipObjectDeep(e4, r4) {
              return baseZipObject(e4 || [], r4 || [], baseSet);
            }
            var ln = baseRest(function(e4) {
              var r4 = e4.length, n2 = r4 > 1 ? e4[r4 - 1] : t3;
              n2 = typeof n2 == "function" ? (e4.pop(), n2) : t3;
              return unzipWith(e4, n2);
            });
            function chain(e4) {
              var r4 = lodash(e4);
              r4.__chain__ = true;
              return r4;
            }
            function tap(e4, r4) {
              r4(e4);
              return e4;
            }
            function thru(e4, r4) {
              return r4(e4);
            }
            var cn = flatRest(function(e4) {
              var r4 = e4.length, n2 = r4 ? e4[0] : 0, a2 = this.__wrapped__, interceptor = function(r5) {
                return baseAt(r5, e4);
              };
              if (r4 > 1 || this.__actions__.length || !(a2 instanceof LazyWrapper) || !isIndex(n2)) {
                return this.thru(interceptor);
              }
              a2 = a2.slice(n2, +n2 + (r4 ? 1 : 0));
              a2.__actions__.push({ func: thru, args: [interceptor], thisArg: t3 });
              return new LodashWrapper(a2, this.__chain__).thru(function(e5) {
                if (r4 && !e5.length) {
                  e5.push(t3);
                }
                return e5;
              });
            });
            function wrapperChain() {
              return chain(this);
            }
            function wrapperCommit() {
              return new LodashWrapper(this.value(), this.__chain__);
            }
            function wrapperNext() {
              if (this.__values__ === t3) {
                this.__values__ = toArray(this.value());
              }
              var e4 = this.__index__ >= this.__values__.length, r4 = e4 ? t3 : this.__values__[this.__index__++];
              return { done: e4, value: r4 };
            }
            function wrapperToIterator() {
              return this;
            }
            function wrapperPlant(e4) {
              var r4, n2 = this;
              while (n2 instanceof baseLodash) {
                var a2 = wrapperClone(n2);
                a2.__index__ = 0;
                a2.__values__ = t3;
                if (r4) {
                  i2.__wrapped__ = a2;
                } else {
                  r4 = a2;
                }
                var i2 = a2;
                n2 = n2.__wrapped__;
              }
              i2.__wrapped__ = e4;
              return r4;
            }
            function wrapperReverse() {
              var e4 = this.__wrapped__;
              if (e4 instanceof LazyWrapper) {
                var r4 = e4;
                if (this.__actions__.length) {
                  r4 = new LazyWrapper(this);
                }
                r4 = r4.reverse();
                r4.__actions__.push({ func: thru, args: [reverse], thisArg: t3 });
                return new LodashWrapper(r4, this.__chain__);
              }
              return this.thru(reverse);
            }
            function wrapperValue() {
              return baseWrapperValue(this.__wrapped__, this.__actions__);
            }
            var fn = createAggregator(function(e4, r4, t4) {
              if (cr2.call(e4, t4)) {
                ++e4[t4];
              } else {
                baseAssignValue(e4, t4, 1);
              }
            });
            function every(e4, r4, n2) {
              var a2 = Ln(e4) ? arrayEvery : baseEvery;
              if (n2 && isIterateeCall(e4, r4, n2)) {
                r4 = t3;
              }
              return a2(e4, getIteratee(r4, 3));
            }
            function filter(e4, r4) {
              var t4 = Ln(e4) ? arrayFilter : baseFilter;
              return t4(e4, getIteratee(r4, 3));
            }
            var hn = createFind(findIndex);
            var pn = createFind(findLastIndex);
            function flatMap(e4, r4) {
              return baseFlatten(map(e4, r4), 1);
            }
            function flatMapDeep(e4, r4) {
              return baseFlatten(map(e4, r4), T);
            }
            function flatMapDepth(e4, r4, n2) {
              n2 = n2 === t3 ? 1 : toInteger(n2);
              return baseFlatten(map(e4, r4), n2);
            }
            function forEach(e4, r4) {
              var t4 = Ln(e4) ? arrayEach : Ot;
              return t4(e4, getIteratee(r4, 3));
            }
            function forEachRight(e4, r4) {
              var t4 = Ln(e4) ? arrayEachRight : Et;
              return t4(e4, getIteratee(r4, 3));
            }
            var dn = createAggregator(function(e4, r4, t4) {
              if (cr2.call(e4, t4)) {
                e4[t4].push(r4);
              } else {
                baseAssignValue(e4, t4, [r4]);
              }
            });
            function includes(e4, r4, t4, n2) {
              e4 = isArrayLike(e4) ? e4 : values(e4);
              t4 = t4 && !n2 ? toInteger(t4) : 0;
              var a2 = e4.length;
              if (t4 < 0) {
                t4 = Mr2(a2 + t4, 0);
              }
              return isString(e4) ? t4 <= a2 && e4.indexOf(r4, t4) > -1 : !!a2 && baseIndexOf(e4, r4, t4) > -1;
            }
            var yn = baseRest(function(e4, t4, n2) {
              var a2 = -1, i2 = typeof t4 == "function", s2 = isArrayLike(e4) ? r3(e4.length) : [];
              Ot(e4, function(e5) {
                s2[++a2] = i2 ? apply(t4, e5, n2) : baseInvoke(e5, t4, n2);
              });
              return s2;
            });
            var gn = createAggregator(function(e4, r4, t4) {
              baseAssignValue(e4, t4, r4);
            });
            function map(e4, r4) {
              var t4 = Ln(e4) ? arrayMap : baseMap;
              return t4(e4, getIteratee(r4, 3));
            }
            function orderBy(e4, r4, n2, a2) {
              if (e4 == null) {
                return [];
              }
              if (!Ln(r4)) {
                r4 = r4 == null ? [] : [r4];
              }
              n2 = a2 ? t3 : n2;
              if (!Ln(n2)) {
                n2 = n2 == null ? [] : [n2];
              }
              return baseOrderBy(e4, r4, n2);
            }
            var vn = createAggregator(function(e4, r4, t4) {
              e4[t4 ? 0 : 1].push(r4);
            }, function() {
              return [[], []];
            });
            function reduce(e4, r4, t4) {
              var n2 = Ln(e4) ? arrayReduce : baseReduce, a2 = arguments.length < 3;
              return n2(e4, getIteratee(r4, 4), t4, a2, Ot);
            }
            function reduceRight(e4, r4, t4) {
              var n2 = Ln(e4) ? arrayReduceRight : baseReduce, a2 = arguments.length < 3;
              return n2(e4, getIteratee(r4, 4), t4, a2, Et);
            }
            function reject(e4, r4) {
              var t4 = Ln(e4) ? arrayFilter : baseFilter;
              return t4(e4, negate(getIteratee(r4, 3)));
            }
            function sample(e4) {
              var r4 = Ln(e4) ? arraySample : baseSample;
              return r4(e4);
            }
            function sampleSize(e4, r4, n2) {
              if (n2 ? isIterateeCall(e4, r4, n2) : r4 === t3) {
                r4 = 1;
              } else {
                r4 = toInteger(r4);
              }
              var a2 = Ln(e4) ? arraySampleSize : baseSampleSize;
              return a2(e4, r4);
            }
            function shuffle(e4) {
              var r4 = Ln(e4) ? arrayShuffle : baseShuffle;
              return r4(e4);
            }
            function size(e4) {
              if (e4 == null) {
                return 0;
              }
              if (isArrayLike(e4)) {
                return isString(e4) ? stringSize(e4) : e4.length;
              }
              var r4 = Dt(e4);
              if (r4 == Z || r4 == ne) {
                return e4.size;
              }
              return baseKeys(e4).length;
            }
            function some(e4, r4, n2) {
              var a2 = Ln(e4) ? arraySome : baseSome;
              if (n2 && isIterateeCall(e4, r4, n2)) {
                r4 = t3;
              }
              return a2(e4, getIteratee(r4, 3));
            }
            var bn = baseRest(function(e4, r4) {
              if (e4 == null) {
                return [];
              }
              var t4 = r4.length;
              if (t4 > 1 && isIterateeCall(e4, r4[0], r4[1])) {
                r4 = [];
              } else if (t4 > 2 && isIterateeCall(r4[0], r4[1], r4[2])) {
                r4 = [r4[0]];
              }
              return baseOrderBy(e4, baseFlatten(r4, 1), []);
            });
            var mn = Rr2 || function() {
              return at.Date.now();
            };
            function after(e4, r4) {
              if (typeof r4 != "function") {
                throw new ar2(s);
              }
              e4 = toInteger(e4);
              return function() {
                if (--e4 < 1) {
                  return r4.apply(this, arguments);
                }
              };
            }
            function ary(e4, r4, n2) {
              r4 = n2 ? t3 : r4;
              r4 = e4 && r4 == null ? e4.length : r4;
              return createWrap(e4, I, t3, t3, t3, t3, r4);
            }
            function before(e4, r4) {
              var n2;
              if (typeof r4 != "function") {
                throw new ar2(s);
              }
              e4 = toInteger(e4);
              return function() {
                if (--e4 > 0) {
                  n2 = r4.apply(this, arguments);
                }
                if (e4 <= 1) {
                  r4 = t3;
                }
                return n2;
              };
            }
            var _n = baseRest(function(e4, r4, t4) {
              var n2 = g;
              if (t4.length) {
                var a2 = replaceHolders(t4, getHolder(_n));
                n2 |= w;
              }
              return createWrap(e4, n2, r4, t4, a2);
            });
            var wn = baseRest(function(e4, r4, t4) {
              var n2 = g | v;
              if (t4.length) {
                var a2 = replaceHolders(t4, getHolder(wn));
                n2 |= w;
              }
              return createWrap(r4, n2, e4, t4, a2);
            });
            function curry(e4, r4, n2) {
              r4 = n2 ? t3 : r4;
              var a2 = createWrap(e4, m, t3, t3, t3, t3, t3, r4);
              a2.placeholder = curry.placeholder;
              return a2;
            }
            function curryRight(e4, r4, n2) {
              r4 = n2 ? t3 : r4;
              var a2 = createWrap(e4, _, t3, t3, t3, t3, t3, r4);
              a2.placeholder = curryRight.placeholder;
              return a2;
            }
            function debounce(e4, r4, n2) {
              var a2, i2, o2, u2, l2, c2, f2 = 0, h2 = false, p2 = false, d2 = true;
              if (typeof e4 != "function") {
                throw new ar2(s);
              }
              r4 = toNumber(r4) || 0;
              if (isObject(n2)) {
                h2 = !!n2.leading;
                p2 = "maxWait" in n2;
                o2 = p2 ? Mr2(toNumber(n2.maxWait) || 0, r4) : o2;
                d2 = "trailing" in n2 ? !!n2.trailing : d2;
              }
              function invokeFunc(r5) {
                var n3 = a2, s2 = i2;
                a2 = i2 = t3;
                f2 = r5;
                u2 = e4.apply(s2, n3);
                return u2;
              }
              function leadingEdge(e5) {
                f2 = e5;
                l2 = Vt(timerExpired, r4);
                return h2 ? invokeFunc(e5) : u2;
              }
              function remainingWait(e5) {
                var t4 = e5 - c2, n3 = e5 - f2, a3 = r4 - t4;
                return p2 ? qr2(a3, o2 - n3) : a3;
              }
              function shouldInvoke(e5) {
                var n3 = e5 - c2, a3 = e5 - f2;
                return c2 === t3 || n3 >= r4 || n3 < 0 || p2 && a3 >= o2;
              }
              function timerExpired() {
                var e5 = mn();
                if (shouldInvoke(e5)) {
                  return trailingEdge(e5);
                }
                l2 = Vt(timerExpired, remainingWait(e5));
              }
              function trailingEdge(e5) {
                l2 = t3;
                if (d2 && a2) {
                  return invokeFunc(e5);
                }
                a2 = i2 = t3;
                return u2;
              }
              function cancel() {
                if (l2 !== t3) {
                  Pt(l2);
                }
                f2 = 0;
                a2 = c2 = i2 = l2 = t3;
              }
              function flush() {
                return l2 === t3 ? u2 : trailingEdge(mn());
              }
              function debounced() {
                var e5 = mn(), n3 = shouldInvoke(e5);
                a2 = arguments;
                i2 = this;
                c2 = e5;
                if (n3) {
                  if (l2 === t3) {
                    return leadingEdge(c2);
                  }
                  if (p2) {
                    Pt(l2);
                    l2 = Vt(timerExpired, r4);
                    return invokeFunc(c2);
                  }
                }
                if (l2 === t3) {
                  l2 = Vt(timerExpired, r4);
                }
                return u2;
              }
              debounced.cancel = cancel;
              debounced.flush = flush;
              return debounced;
            }
            var Sn = baseRest(function(e4, r4) {
              return baseDelay(e4, 1, r4);
            });
            var In = baseRest(function(e4, r4, t4) {
              return baseDelay(e4, toNumber(r4) || 0, t4);
            });
            function flip(e4) {
              return createWrap(e4, x);
            }
            function memoize(e4, r4) {
              if (typeof e4 != "function" || r4 != null && typeof r4 != "function") {
                throw new ar2(s);
              }
              var memoized = function() {
                var t4 = arguments, n2 = r4 ? r4.apply(this, t4) : t4[0], a2 = memoized.cache;
                if (a2.has(n2)) {
                  return a2.get(n2);
                }
                var i2 = e4.apply(this, t4);
                memoized.cache = a2.set(n2, i2) || a2;
                return i2;
              };
              memoized.cache = new (memoize.Cache || MapCache)();
              return memoized;
            }
            memoize.Cache = MapCache;
            function negate(e4) {
              if (typeof e4 != "function") {
                throw new ar2(s);
              }
              return function() {
                var r4 = arguments;
                switch (r4.length) {
                  case 0:
                    return !e4.call(this);
                  case 1:
                    return !e4.call(this, r4[0]);
                  case 2:
                    return !e4.call(this, r4[0], r4[1]);
                  case 3:
                    return !e4.call(this, r4[0], r4[1], r4[2]);
                }
                return !e4.apply(this, r4);
              };
            }
            function once(e4) {
              return before(2, e4);
            }
            var An = Wt(function(e4, r4) {
              r4 = r4.length == 1 && Ln(r4[0]) ? arrayMap(r4[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(r4, 1), baseUnary(getIteratee()));
              var t4 = r4.length;
              return baseRest(function(n2) {
                var a2 = -1, i2 = qr2(n2.length, t4);
                while (++a2 < i2) {
                  n2[a2] = r4[a2].call(this, n2[a2]);
                }
                return apply(e4, this, n2);
              });
            });
            var xn = baseRest(function(e4, r4) {
              var n2 = replaceHolders(r4, getHolder(xn));
              return createWrap(e4, w, t3, r4, n2);
            });
            var kn = baseRest(function(e4, r4) {
              var n2 = replaceHolders(r4, getHolder(kn));
              return createWrap(e4, S, t3, r4, n2);
            });
            var jn = flatRest(function(e4, r4) {
              return createWrap(e4, A, t3, t3, t3, r4);
            });
            function rest(e4, r4) {
              if (typeof e4 != "function") {
                throw new ar2(s);
              }
              r4 = r4 === t3 ? r4 : toInteger(r4);
              return baseRest(e4, r4);
            }
            function spread(e4, r4) {
              if (typeof e4 != "function") {
                throw new ar2(s);
              }
              r4 = r4 == null ? 0 : Mr2(toInteger(r4), 0);
              return baseRest(function(t4) {
                var n2 = t4[r4], a2 = castSlice(t4, 0, r4);
                if (n2) {
                  arrayPush(a2, n2);
                }
                return apply(e4, this, a2);
              });
            }
            function throttle(e4, r4, t4) {
              var n2 = true, a2 = true;
              if (typeof e4 != "function") {
                throw new ar2(s);
              }
              if (isObject(t4)) {
                n2 = "leading" in t4 ? !!t4.leading : n2;
                a2 = "trailing" in t4 ? !!t4.trailing : a2;
              }
              return debounce(e4, r4, { leading: n2, maxWait: r4, trailing: a2 });
            }
            function unary(e4) {
              return ary(e4, 1);
            }
            function wrap(e4, r4) {
              return xn(castFunction(r4), e4);
            }
            function castArray() {
              if (!arguments.length) {
                return [];
              }
              var e4 = arguments[0];
              return Ln(e4) ? e4 : [e4];
            }
            function clone(e4) {
              return baseClone(e4, p);
            }
            function cloneWith(e4, r4) {
              r4 = typeof r4 == "function" ? r4 : t3;
              return baseClone(e4, p, r4);
            }
            function cloneDeep(e4) {
              return baseClone(e4, f | p);
            }
            function cloneDeepWith(e4, r4) {
              r4 = typeof r4 == "function" ? r4 : t3;
              return baseClone(e4, f | p, r4);
            }
            function conformsTo(e4, r4) {
              return r4 == null || baseConformsTo(e4, r4, keys(r4));
            }
            function eq(e4, r4) {
              return e4 === r4 || e4 !== e4 && r4 !== r4;
            }
            var On = createRelationalOperation(baseGt);
            var En = createRelationalOperation(function(e4, r4) {
              return e4 >= r4;
            });
            var Rn = baseIsArguments(function() {
              return arguments;
            }()) ? baseIsArguments : function(e4) {
              return isObjectLike(e4) && cr2.call(e4, "callee") && !Ir2.call(e4, "callee");
            };
            var Ln = r3.isArray;
            var Cn = ct ? baseUnary(ct) : baseIsArrayBuffer;
            function isArrayLike(e4) {
              return e4 != null && isLength(e4.length) && !isFunction(e4);
            }
            function isArrayLikeObject(e4) {
              return isObjectLike(e4) && isArrayLike(e4);
            }
            function isBoolean(e4) {
              return e4 === true || e4 === false || isObjectLike(e4) && baseGetTag(e4) == U;
            }
            var Tn = Pr2 || stubFalse;
            var Wn = ft ? baseUnary(ft) : baseIsDate;
            function isElement(e4) {
              return isObjectLike(e4) && e4.nodeType === 1 && !isPlainObject(e4);
            }
            function isEmpty(e4) {
              if (e4 == null) {
                return true;
              }
              if (isArrayLike(e4) && (Ln(e4) || typeof e4 == "string" || typeof e4.splice == "function" || Tn(e4) || Fn(e4) || Rn(e4))) {
                return !e4.length;
              }
              var r4 = Dt(e4);
              if (r4 == Z || r4 == ne) {
                return !e4.size;
              }
              if (isPrototype(e4)) {
                return !baseKeys(e4).length;
              }
              for (var t4 in e4) {
                if (cr2.call(e4, t4)) {
                  return false;
                }
              }
              return true;
            }
            function isEqual(e4, r4) {
              return baseIsEqual(e4, r4);
            }
            function isEqualWith(e4, r4, n2) {
              n2 = typeof n2 == "function" ? n2 : t3;
              var a2 = n2 ? n2(e4, r4) : t3;
              return a2 === t3 ? baseIsEqual(e4, r4, t3, n2) : !!a2;
            }
            function isError(e4) {
              if (!isObjectLike(e4)) {
                return false;
              }
              var r4 = baseGetTag(e4);
              return r4 == G || r4 == H || typeof e4.message == "string" && typeof e4.name == "string" && !isPlainObject(e4);
            }
            function isFinite2(e4) {
              return typeof e4 == "number" && zr2(e4);
            }
            function isFunction(e4) {
              if (!isObject(e4)) {
                return false;
              }
              var r4 = baseGetTag(e4);
              return r4 == $ || r4 == J || r4 == V || r4 == re;
            }
            function isInteger(e4) {
              return typeof e4 == "number" && e4 == toInteger(e4);
            }
            function isLength(e4) {
              return typeof e4 == "number" && e4 > -1 && e4 % 1 == 0 && e4 <= W;
            }
            function isObject(e4) {
              var r4 = typeof e4;
              return e4 != null && (r4 == "object" || r4 == "function");
            }
            function isObjectLike(e4) {
              return e4 != null && typeof e4 == "object";
            }
            var Pn = ht ? baseUnary(ht) : baseIsMap;
            function isMatch(e4, r4) {
              return e4 === r4 || baseIsMatch(e4, r4, getMatchData(r4));
            }
            function isMatchWith(e4, r4, n2) {
              n2 = typeof n2 == "function" ? n2 : t3;
              return baseIsMatch(e4, r4, getMatchData(r4), n2);
            }
            function isNaN2(e4) {
              return isNumber(e4) && e4 != +e4;
            }
            function isNative(e4) {
              if (Kt(e4)) {
                throw new De2(i);
              }
              return baseIsNative(e4);
            }
            function isNull(e4) {
              return e4 === null;
            }
            function isNil(e4) {
              return e4 == null;
            }
            function isNumber(e4) {
              return typeof e4 == "number" || isObjectLike(e4) && baseGetTag(e4) == X;
            }
            function isPlainObject(e4) {
              if (!isObjectLike(e4) || baseGetTag(e4) != Q) {
                return false;
              }
              var r4 = wr2(e4);
              if (r4 === null) {
                return true;
              }
              var t4 = cr2.call(r4, "constructor") && r4.constructor;
              return typeof t4 == "function" && t4 instanceof t4 && lr2.call(t4) == dr2;
            }
            var zn = pt ? baseUnary(pt) : baseIsRegExp;
            function isSafeInteger(e4) {
              return isInteger(e4) && e4 >= -W && e4 <= W;
            }
            var Bn = dt ? baseUnary(dt) : baseIsSet;
            function isString(e4) {
              return typeof e4 == "string" || !Ln(e4) && isObjectLike(e4) && baseGetTag(e4) == ae;
            }
            function isSymbol(e4) {
              return typeof e4 == "symbol" || isObjectLike(e4) && baseGetTag(e4) == ie;
            }
            var Fn = yt ? baseUnary(yt) : baseIsTypedArray;
            function isUndefined(e4) {
              return e4 === t3;
            }
            function isWeakMap(e4) {
              return isObjectLike(e4) && Dt(e4) == oe;
            }
            function isWeakSet(e4) {
              return isObjectLike(e4) && baseGetTag(e4) == ue;
            }
            var Mn = createRelationalOperation(baseLt);
            var Dn = createRelationalOperation(function(e4, r4) {
              return e4 <= r4;
            });
            function toArray(e4) {
              if (!e4) {
                return [];
              }
              if (isArrayLike(e4)) {
                return isString(e4) ? stringToArray(e4) : copyArray(e4);
              }
              if (kr2 && e4[kr2]) {
                return iteratorToArray(e4[kr2]());
              }
              var r4 = Dt(e4), t4 = r4 == Z ? mapToArray : r4 == ne ? setToArray : values;
              return t4(e4);
            }
            function toFinite(e4) {
              if (!e4) {
                return e4 === 0 ? e4 : 0;
              }
              e4 = toNumber(e4);
              if (e4 === T || e4 === -T) {
                var r4 = e4 < 0 ? -1 : 1;
                return r4 * P;
              }
              return e4 === e4 ? e4 : 0;
            }
            function toInteger(e4) {
              var r4 = toFinite(e4), t4 = r4 % 1;
              return r4 === r4 ? t4 ? r4 - t4 : r4 : 0;
            }
            function toLength(e4) {
              return e4 ? baseClamp(toInteger(e4), 0, B) : 0;
            }
            function toNumber(e4) {
              if (typeof e4 == "number") {
                return e4;
              }
              if (isSymbol(e4)) {
                return z;
              }
              if (isObject(e4)) {
                var r4 = typeof e4.valueOf == "function" ? e4.valueOf() : e4;
                e4 = isObject(r4) ? r4 + "" : r4;
              }
              if (typeof e4 != "string") {
                return e4 === 0 ? e4 : +e4;
              }
              e4 = baseTrim(e4);
              var t4 = He.test(e4);
              return t4 || $e.test(e4) ? rt(e4.slice(2), t4 ? 2 : 8) : Ne.test(e4) ? z : +e4;
            }
            function toPlainObject(e4) {
              return copyObject(e4, keysIn(e4));
            }
            function toSafeInteger(e4) {
              return e4 ? baseClamp(toInteger(e4), -W, W) : e4 === 0 ? e4 : 0;
            }
            function toString(e4) {
              return e4 == null ? "" : baseToString(e4);
            }
            var Kn = createAssigner(function(e4, r4) {
              if (isPrototype(r4) || isArrayLike(r4)) {
                copyObject(r4, keys(r4), e4);
                return;
              }
              for (var t4 in r4) {
                if (cr2.call(r4, t4)) {
                  assignValue(e4, t4, r4[t4]);
                }
              }
            });
            var qn = createAssigner(function(e4, r4) {
              copyObject(r4, keysIn(r4), e4);
            });
            var Vn = createAssigner(function(e4, r4, t4, n2) {
              copyObject(r4, keysIn(r4), e4, n2);
            });
            var Un = createAssigner(function(e4, r4, t4, n2) {
              copyObject(r4, keys(r4), e4, n2);
            });
            var Nn = flatRest(baseAt);
            function create(e4, r4) {
              var t4 = jt(e4);
              return r4 == null ? t4 : baseAssign(t4, r4);
            }
            var Hn = baseRest(function(e4, r4) {
              e4 = rr2(e4);
              var n2 = -1;
              var a2 = r4.length;
              var i2 = a2 > 2 ? r4[2] : t3;
              if (i2 && isIterateeCall(r4[0], r4[1], i2)) {
                a2 = 1;
              }
              while (++n2 < a2) {
                var s2 = r4[n2];
                var o2 = keysIn(s2);
                var u2 = -1;
                var l2 = o2.length;
                while (++u2 < l2) {
                  var c2 = o2[u2];
                  var f2 = e4[c2];
                  if (f2 === t3 || eq(f2, or2[c2]) && !cr2.call(e4, c2)) {
                    e4[c2] = s2[c2];
                  }
                }
              }
              return e4;
            });
            var Gn = baseRest(function(e4) {
              e4.push(t3, customDefaultsMerge);
              return apply(Yn, t3, e4);
            });
            function findKey(e4, r4) {
              return baseFindKey(e4, getIteratee(r4, 3), baseForOwn);
            }
            function findLastKey(e4, r4) {
              return baseFindKey(e4, getIteratee(r4, 3), baseForOwnRight);
            }
            function forIn(e4, r4) {
              return e4 == null ? e4 : Rt(e4, getIteratee(r4, 3), keysIn);
            }
            function forInRight(e4, r4) {
              return e4 == null ? e4 : Lt(e4, getIteratee(r4, 3), keysIn);
            }
            function forOwn(e4, r4) {
              return e4 && baseForOwn(e4, getIteratee(r4, 3));
            }
            function forOwnRight(e4, r4) {
              return e4 && baseForOwnRight(e4, getIteratee(r4, 3));
            }
            function functions(e4) {
              return e4 == null ? [] : baseFunctions(e4, keys(e4));
            }
            function functionsIn(e4) {
              return e4 == null ? [] : baseFunctions(e4, keysIn(e4));
            }
            function get(e4, r4, n2) {
              var a2 = e4 == null ? t3 : baseGet(e4, r4);
              return a2 === t3 ? n2 : a2;
            }
            function has(e4, r4) {
              return e4 != null && hasPath(e4, r4, baseHas);
            }
            function hasIn(e4, r4) {
              return e4 != null && hasPath(e4, r4, baseHasIn);
            }
            var $n = createInverter(function(e4, r4, t4) {
              if (r4 != null && typeof r4.toString != "function") {
                r4 = pr2.call(r4);
              }
              e4[r4] = t4;
            }, constant(identity));
            var Jn = createInverter(function(e4, r4, t4) {
              if (r4 != null && typeof r4.toString != "function") {
                r4 = pr2.call(r4);
              }
              if (cr2.call(e4, r4)) {
                e4[r4].push(t4);
              } else {
                e4[r4] = [t4];
              }
            }, getIteratee);
            var Zn = baseRest(baseInvoke);
            function keys(e4) {
              return isArrayLike(e4) ? arrayLikeKeys(e4) : baseKeys(e4);
            }
            function keysIn(e4) {
              return isArrayLike(e4) ? arrayLikeKeys(e4, true) : baseKeysIn(e4);
            }
            function mapKeys(e4, r4) {
              var t4 = {};
              r4 = getIteratee(r4, 3);
              baseForOwn(e4, function(e5, n2, a2) {
                baseAssignValue(t4, r4(e5, n2, a2), e5);
              });
              return t4;
            }
            function mapValues(e4, r4) {
              var t4 = {};
              r4 = getIteratee(r4, 3);
              baseForOwn(e4, function(e5, n2, a2) {
                baseAssignValue(t4, n2, r4(e5, n2, a2));
              });
              return t4;
            }
            var Xn = createAssigner(function(e4, r4, t4) {
              baseMerge(e4, r4, t4);
            });
            var Yn = createAssigner(function(e4, r4, t4, n2) {
              baseMerge(e4, r4, t4, n2);
            });
            var Qn = flatRest(function(e4, r4) {
              var t4 = {};
              if (e4 == null) {
                return t4;
              }
              var n2 = false;
              r4 = arrayMap(r4, function(r5) {
                r5 = castPath(r5, e4);
                n2 || (n2 = r5.length > 1);
                return r5;
              });
              copyObject(e4, getAllKeysIn(e4), t4);
              if (n2) {
                t4 = baseClone(t4, f | h | p, customOmitClone);
              }
              var a2 = r4.length;
              while (a2--) {
                baseUnset(t4, r4[a2]);
              }
              return t4;
            });
            function omitBy(e4, r4) {
              return pickBy(e4, negate(getIteratee(r4)));
            }
            var ea = flatRest(function(e4, r4) {
              return e4 == null ? {} : basePick(e4, r4);
            });
            function pickBy(e4, r4) {
              if (e4 == null) {
                return {};
              }
              var t4 = arrayMap(getAllKeysIn(e4), function(e5) {
                return [e5];
              });
              r4 = getIteratee(r4);
              return basePickBy(e4, t4, function(e5, t5) {
                return r4(e5, t5[0]);
              });
            }
            function result(e4, r4, n2) {
              r4 = castPath(r4, e4);
              var a2 = -1, i2 = r4.length;
              if (!i2) {
                i2 = 1;
                e4 = t3;
              }
              while (++a2 < i2) {
                var s2 = e4 == null ? t3 : e4[toKey(r4[a2])];
                if (s2 === t3) {
                  a2 = i2;
                  s2 = n2;
                }
                e4 = isFunction(s2) ? s2.call(e4) : s2;
              }
              return e4;
            }
            function set(e4, r4, t4) {
              return e4 == null ? e4 : baseSet(e4, r4, t4);
            }
            function setWith(e4, r4, n2, a2) {
              a2 = typeof a2 == "function" ? a2 : t3;
              return e4 == null ? e4 : baseSet(e4, r4, n2, a2);
            }
            var ra = createToPairs(keys);
            var ta = createToPairs(keysIn);
            function transform(e4, r4, t4) {
              var n2 = Ln(e4), a2 = n2 || Tn(e4) || Fn(e4);
              r4 = getIteratee(r4, 4);
              if (t4 == null) {
                var i2 = e4 && e4.constructor;
                if (a2) {
                  t4 = n2 ? new i2() : [];
                } else if (isObject(e4)) {
                  t4 = isFunction(i2) ? jt(wr2(e4)) : {};
                } else {
                  t4 = {};
                }
              }
              (a2 ? arrayEach : baseForOwn)(e4, function(e5, n3, a3) {
                return r4(t4, e5, n3, a3);
              });
              return t4;
            }
            function unset(e4, r4) {
              return e4 == null ? true : baseUnset(e4, r4);
            }
            function update(e4, r4, t4) {
              return e4 == null ? e4 : baseUpdate(e4, r4, castFunction(t4));
            }
            function updateWith(e4, r4, n2, a2) {
              a2 = typeof a2 == "function" ? a2 : t3;
              return e4 == null ? e4 : baseUpdate(e4, r4, castFunction(n2), a2);
            }
            function values(e4) {
              return e4 == null ? [] : baseValues(e4, keys(e4));
            }
            function valuesIn(e4) {
              return e4 == null ? [] : baseValues(e4, keysIn(e4));
            }
            function clamp(e4, r4, n2) {
              if (n2 === t3) {
                n2 = r4;
                r4 = t3;
              }
              if (n2 !== t3) {
                n2 = toNumber(n2);
                n2 = n2 === n2 ? n2 : 0;
              }
              if (r4 !== t3) {
                r4 = toNumber(r4);
                r4 = r4 === r4 ? r4 : 0;
              }
              return baseClamp(toNumber(e4), r4, n2);
            }
            function inRange(e4, r4, n2) {
              r4 = toFinite(r4);
              if (n2 === t3) {
                n2 = r4;
                r4 = 0;
              } else {
                n2 = toFinite(n2);
              }
              e4 = toNumber(e4);
              return baseInRange(e4, r4, n2);
            }
            function random(e4, r4, n2) {
              if (n2 && typeof n2 != "boolean" && isIterateeCall(e4, r4, n2)) {
                r4 = n2 = t3;
              }
              if (n2 === t3) {
                if (typeof r4 == "boolean") {
                  n2 = r4;
                  r4 = t3;
                } else if (typeof e4 == "boolean") {
                  n2 = e4;
                  e4 = t3;
                }
              }
              if (e4 === t3 && r4 === t3) {
                e4 = 0;
                r4 = 1;
              } else {
                e4 = toFinite(e4);
                if (r4 === t3) {
                  r4 = e4;
                  e4 = 0;
                } else {
                  r4 = toFinite(r4);
                }
              }
              if (e4 > r4) {
                var a2 = e4;
                e4 = r4;
                r4 = a2;
              }
              if (n2 || e4 % 1 || r4 % 1) {
                var i2 = Nr2();
                return qr2(e4 + i2 * (r4 - e4 + et("1e-" + ((i2 + "").length - 1))), r4);
              }
              return baseRandom(e4, r4);
            }
            var na = createCompounder(function(e4, r4, t4) {
              r4 = r4.toLowerCase();
              return e4 + (t4 ? capitalize(r4) : r4);
            });
            function capitalize(e4) {
              return ca(toString(e4).toLowerCase());
            }
            function deburr(e4) {
              e4 = toString(e4);
              return e4 && e4.replace(Ze, vt).replace(Kr, "");
            }
            function endsWith(e4, r4, n2) {
              e4 = toString(e4);
              r4 = baseToString(r4);
              var a2 = e4.length;
              n2 = n2 === t3 ? a2 : baseClamp(toInteger(n2), 0, a2);
              var i2 = n2;
              n2 -= r4.length;
              return n2 >= 0 && e4.slice(n2, i2) == r4;
            }
            function escape(e4) {
              e4 = toString(e4);
              return e4 && ke.test(e4) ? e4.replace(Ae, bt) : e4;
            }
            function escapeRegExp(e4) {
              e4 = toString(e4);
              return e4 && We.test(e4) ? e4.replace(Te, "\\$&") : e4;
            }
            var aa = createCompounder(function(e4, r4, t4) {
              return e4 + (t4 ? "-" : "") + r4.toLowerCase();
            });
            var ia = createCompounder(function(e4, r4, t4) {
              return e4 + (t4 ? " " : "") + r4.toLowerCase();
            });
            var sa = createCaseFirst("toLowerCase");
            function pad(e4, r4, t4) {
              e4 = toString(e4);
              r4 = toInteger(r4);
              var n2 = r4 ? stringSize(e4) : 0;
              if (!r4 || n2 >= r4) {
                return e4;
              }
              var a2 = (r4 - n2) / 2;
              return createPadding(Tr2(a2), t4) + e4 + createPadding(Cr2(a2), t4);
            }
            function padEnd(e4, r4, t4) {
              e4 = toString(e4);
              r4 = toInteger(r4);
              var n2 = r4 ? stringSize(e4) : 0;
              return r4 && n2 < r4 ? e4 + createPadding(r4 - n2, t4) : e4;
            }
            function padStart(e4, r4, t4) {
              e4 = toString(e4);
              r4 = toInteger(r4);
              var n2 = r4 ? stringSize(e4) : 0;
              return r4 && n2 < r4 ? createPadding(r4 - n2, t4) + e4 : e4;
            }
            function parseInt2(e4, r4, t4) {
              if (t4 || r4 == null) {
                r4 = 0;
              } else if (r4) {
                r4 = +r4;
              }
              return Ur2(toString(e4).replace(Pe, ""), r4 || 0);
            }
            function repeat(e4, r4, n2) {
              if (n2 ? isIterateeCall(e4, r4, n2) : r4 === t3) {
                r4 = 1;
              } else {
                r4 = toInteger(r4);
              }
              return baseRepeat(toString(e4), r4);
            }
            function replace() {
              var e4 = arguments, r4 = toString(e4[0]);
              return e4.length < 3 ? r4 : r4.replace(e4[1], e4[2]);
            }
            var oa = createCompounder(function(e4, r4, t4) {
              return e4 + (t4 ? "_" : "") + r4.toLowerCase();
            });
            function split(e4, r4, n2) {
              if (n2 && typeof n2 != "number" && isIterateeCall(e4, r4, n2)) {
                r4 = n2 = t3;
              }
              n2 = n2 === t3 ? B : n2 >>> 0;
              if (!n2) {
                return [];
              }
              e4 = toString(e4);
              if (e4 && (typeof r4 == "string" || r4 != null && !zn(r4))) {
                r4 = baseToString(r4);
                if (!r4 && hasUnicode(e4)) {
                  return castSlice(stringToArray(e4), 0, n2);
                }
              }
              return e4.split(r4, n2);
            }
            var ua = createCompounder(function(e4, r4, t4) {
              return e4 + (t4 ? " " : "") + ca(r4);
            });
            function startsWith(e4, r4, t4) {
              e4 = toString(e4);
              t4 = t4 == null ? 0 : baseClamp(toInteger(t4), 0, e4.length);
              r4 = baseToString(r4);
              return e4.slice(t4, t4 + r4.length) == r4;
            }
            function template(e4, r4, n2) {
              var a2 = lodash.templateSettings;
              if (n2 && isIterateeCall(e4, r4, n2)) {
                r4 = t3;
              }
              e4 = toString(e4);
              r4 = Vn({}, r4, a2, customDefaultsAssignIn);
              var i2 = Vn({}, r4.imports, a2.imports, customDefaultsAssignIn), s2 = keys(i2), u2 = baseValues(i2, s2);
              var l2, c2, f2 = 0, h2 = r4.interpolate || Xe, p2 = "__p += '";
              var d2 = tr2((r4.escape || Xe).source + "|" + h2.source + "|" + (h2 === Ee ? Ve : Xe).source + "|" + (r4.evaluate || Xe).source + "|$", "g");
              var y2 = "//# sourceURL=" + (cr2.call(r4, "sourceURL") ? (r4.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Gr + "]") + "\n";
              e4.replace(d2, function(r5, t4, n3, a3, i3, s3) {
                n3 || (n3 = a3);
                p2 += e4.slice(f2, s3).replace(Ye, escapeStringChar);
                if (t4) {
                  l2 = true;
                  p2 += "' +\n__e(" + t4 + ") +\n'";
                }
                if (i3) {
                  c2 = true;
                  p2 += "';\n" + i3 + ";\n__p += '";
                }
                if (n3) {
                  p2 += "' +\n((__t = (" + n3 + ")) == null ? '' : __t) +\n'";
                }
                f2 = s3 + r5.length;
                return r5;
              });
              p2 += "';\n";
              var g2 = cr2.call(r4, "variable") && r4.variable;
              if (!g2) {
                p2 = "with (obj) {\n" + p2 + "\n}\n";
              } else if (Ke.test(g2)) {
                throw new De2(o);
              }
              p2 = (c2 ? p2.replace(_e, "") : p2).replace(we, "$1").replace(Se, "$1;");
              p2 = "function(" + (g2 || "obj") + ") {\n" + (g2 ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (l2 ? ", __e = _.escape" : "") + (c2 ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + p2 + "return __p\n}";
              var v2 = fa(function() {
                return Qe2(s2, y2 + "return " + p2).apply(t3, u2);
              });
              v2.source = p2;
              if (isError(v2)) {
                throw v2;
              }
              return v2;
            }
            function toLower(e4) {
              return toString(e4).toLowerCase();
            }
            function toUpper(e4) {
              return toString(e4).toUpperCase();
            }
            function trim(e4, r4, n2) {
              e4 = toString(e4);
              if (e4 && (n2 || r4 === t3)) {
                return baseTrim(e4);
              }
              if (!e4 || !(r4 = baseToString(r4))) {
                return e4;
              }
              var a2 = stringToArray(e4), i2 = stringToArray(r4), s2 = charsStartIndex(a2, i2), o2 = charsEndIndex(a2, i2) + 1;
              return castSlice(a2, s2, o2).join("");
            }
            function trimEnd(e4, r4, n2) {
              e4 = toString(e4);
              if (e4 && (n2 || r4 === t3)) {
                return e4.slice(0, trimmedEndIndex(e4) + 1);
              }
              if (!e4 || !(r4 = baseToString(r4))) {
                return e4;
              }
              var a2 = stringToArray(e4), i2 = charsEndIndex(a2, stringToArray(r4)) + 1;
              return castSlice(a2, 0, i2).join("");
            }
            function trimStart(e4, r4, n2) {
              e4 = toString(e4);
              if (e4 && (n2 || r4 === t3)) {
                return e4.replace(Pe, "");
              }
              if (!e4 || !(r4 = baseToString(r4))) {
                return e4;
              }
              var a2 = stringToArray(e4), i2 = charsStartIndex(a2, stringToArray(r4));
              return castSlice(a2, i2).join("");
            }
            function truncate(e4, r4) {
              var n2 = k, a2 = j;
              if (isObject(r4)) {
                var i2 = "separator" in r4 ? r4.separator : i2;
                n2 = "length" in r4 ? toInteger(r4.length) : n2;
                a2 = "omission" in r4 ? baseToString(r4.omission) : a2;
              }
              e4 = toString(e4);
              var s2 = e4.length;
              if (hasUnicode(e4)) {
                var o2 = stringToArray(e4);
                s2 = o2.length;
              }
              if (n2 >= s2) {
                return e4;
              }
              var u2 = n2 - stringSize(a2);
              if (u2 < 1) {
                return a2;
              }
              var l2 = o2 ? castSlice(o2, 0, u2).join("") : e4.slice(0, u2);
              if (i2 === t3) {
                return l2 + a2;
              }
              if (o2) {
                u2 += l2.length - u2;
              }
              if (zn(i2)) {
                if (e4.slice(u2).search(i2)) {
                  var c2, f2 = l2;
                  if (!i2.global) {
                    i2 = tr2(i2.source, toString(Ue.exec(i2)) + "g");
                  }
                  i2.lastIndex = 0;
                  while (c2 = i2.exec(f2)) {
                    var h2 = c2.index;
                  }
                  l2 = l2.slice(0, h2 === t3 ? u2 : h2);
                }
              } else if (e4.indexOf(baseToString(i2), u2) != u2) {
                var p2 = l2.lastIndexOf(i2);
                if (p2 > -1) {
                  l2 = l2.slice(0, p2);
                }
              }
              return l2 + a2;
            }
            function unescape(e4) {
              e4 = toString(e4);
              return e4 && xe.test(e4) ? e4.replace(Ie, mt) : e4;
            }
            var la = createCompounder(function(e4, r4, t4) {
              return e4 + (t4 ? " " : "") + r4.toUpperCase();
            });
            var ca = createCaseFirst("toUpperCase");
            function words(e4, r4, n2) {
              e4 = toString(e4);
              r4 = n2 ? t3 : r4;
              if (r4 === t3) {
                return hasUnicodeWord(e4) ? unicodeWords(e4) : asciiWords(e4);
              }
              return e4.match(r4) || [];
            }
            var fa = baseRest(function(e4, r4) {
              try {
                return apply(e4, t3, r4);
              } catch (e5) {
                return isError(e5) ? e5 : new De2(e5);
              }
            });
            var ha = flatRest(function(e4, r4) {
              arrayEach(r4, function(r5) {
                r5 = toKey(r5);
                baseAssignValue(e4, r5, _n(e4[r5], e4));
              });
              return e4;
            });
            function cond(e4) {
              var r4 = e4 == null ? 0 : e4.length, t4 = getIteratee();
              e4 = !r4 ? [] : arrayMap(e4, function(e5) {
                if (typeof e5[1] != "function") {
                  throw new ar2(s);
                }
                return [t4(e5[0]), e5[1]];
              });
              return baseRest(function(t5) {
                var n2 = -1;
                while (++n2 < r4) {
                  var a2 = e4[n2];
                  if (apply(a2[0], this, t5)) {
                    return apply(a2[1], this, t5);
                  }
                }
              });
            }
            function conforms(e4) {
              return baseConforms(baseClone(e4, f));
            }
            function constant(e4) {
              return function() {
                return e4;
              };
            }
            function defaultTo(e4, r4) {
              return e4 == null || e4 !== e4 ? r4 : e4;
            }
            var pa = createFlow();
            var da = createFlow(true);
            function identity(e4) {
              return e4;
            }
            function iteratee(e4) {
              return baseIteratee(typeof e4 == "function" ? e4 : baseClone(e4, f));
            }
            function matches(e4) {
              return baseMatches(baseClone(e4, f));
            }
            function matchesProperty(e4, r4) {
              return baseMatchesProperty(e4, baseClone(r4, f));
            }
            var ya = baseRest(function(e4, r4) {
              return function(t4) {
                return baseInvoke(t4, e4, r4);
              };
            });
            var ga = baseRest(function(e4, r4) {
              return function(t4) {
                return baseInvoke(e4, t4, r4);
              };
            });
            function mixin(e4, r4, t4) {
              var n2 = keys(r4), a2 = baseFunctions(r4, n2);
              if (t4 == null && !(isObject(r4) && (a2.length || !n2.length))) {
                t4 = r4;
                r4 = e4;
                e4 = this;
                a2 = baseFunctions(r4, keys(r4));
              }
              var i2 = !(isObject(t4) && "chain" in t4) || !!t4.chain, s2 = isFunction(e4);
              arrayEach(a2, function(t5) {
                var n3 = r4[t5];
                e4[t5] = n3;
                if (s2) {
                  e4.prototype[t5] = function() {
                    var r5 = this.__chain__;
                    if (i2 || r5) {
                      var t6 = e4(this.__wrapped__), a3 = t6.__actions__ = copyArray(this.__actions__);
                      a3.push({ func: n3, args: arguments, thisArg: e4 });
                      t6.__chain__ = r5;
                      return t6;
                    }
                    return n3.apply(e4, arrayPush([this.value()], arguments));
                  };
                }
              });
              return e4;
            }
            function noConflict() {
              if (at._ === this) {
                at._ = yr2;
              }
              return this;
            }
            function noop() {
            }
            function nthArg(e4) {
              e4 = toInteger(e4);
              return baseRest(function(r4) {
                return baseNth(r4, e4);
              });
            }
            var va = createOver(arrayMap);
            var ba = createOver(arrayEvery);
            var ma = createOver(arraySome);
            function property(e4) {
              return isKey(e4) ? baseProperty(toKey(e4)) : basePropertyDeep(e4);
            }
            function propertyOf(e4) {
              return function(r4) {
                return e4 == null ? t3 : baseGet(e4, r4);
              };
            }
            var _a = createRange();
            var wa = createRange(true);
            function stubArray() {
              return [];
            }
            function stubFalse() {
              return false;
            }
            function stubObject() {
              return {};
            }
            function stubString() {
              return "";
            }
            function stubTrue() {
              return true;
            }
            function times(e4, r4) {
              e4 = toInteger(e4);
              if (e4 < 1 || e4 > W) {
                return [];
              }
              var t4 = B, n2 = qr2(e4, B);
              r4 = getIteratee(r4);
              e4 -= B;
              var a2 = baseTimes(n2, r4);
              while (++t4 < e4) {
                r4(t4);
              }
              return a2;
            }
            function toPath(e4) {
              if (Ln(e4)) {
                return arrayMap(e4, toKey);
              }
              return isSymbol(e4) ? [e4] : copyArray(Nt(toString(e4)));
            }
            function uniqueId(e4) {
              var r4 = ++fr2;
              return toString(e4) + r4;
            }
            var Sa = createMathOperation(function(e4, r4) {
              return e4 + r4;
            }, 0);
            var Ia = createRound("ceil");
            var Aa = createMathOperation(function(e4, r4) {
              return e4 / r4;
            }, 1);
            var xa = createRound("floor");
            function max(e4) {
              return e4 && e4.length ? baseExtremum(e4, identity, baseGt) : t3;
            }
            function maxBy(e4, r4) {
              return e4 && e4.length ? baseExtremum(e4, getIteratee(r4, 2), baseGt) : t3;
            }
            function mean(e4) {
              return baseMean(e4, identity);
            }
            function meanBy(e4, r4) {
              return baseMean(e4, getIteratee(r4, 2));
            }
            function min(e4) {
              return e4 && e4.length ? baseExtremum(e4, identity, baseLt) : t3;
            }
            function minBy(e4, r4) {
              return e4 && e4.length ? baseExtremum(e4, getIteratee(r4, 2), baseLt) : t3;
            }
            var ka = createMathOperation(function(e4, r4) {
              return e4 * r4;
            }, 1);
            var ja = createRound("round");
            var Oa = createMathOperation(function(e4, r4) {
              return e4 - r4;
            }, 0);
            function sum(e4) {
              return e4 && e4.length ? baseSum(e4, identity) : 0;
            }
            function sumBy(e4, r4) {
              return e4 && e4.length ? baseSum(e4, getIteratee(r4, 2)) : 0;
            }
            lodash.after = after;
            lodash.ary = ary;
            lodash.assign = Kn;
            lodash.assignIn = qn;
            lodash.assignInWith = Vn;
            lodash.assignWith = Un;
            lodash.at = Nn;
            lodash.before = before;
            lodash.bind = _n;
            lodash.bindAll = ha;
            lodash.bindKey = wn;
            lodash.castArray = castArray;
            lodash.chain = chain;
            lodash.chunk = chunk;
            lodash.compact = compact;
            lodash.concat = concat;
            lodash.cond = cond;
            lodash.conforms = conforms;
            lodash.constant = constant;
            lodash.countBy = fn;
            lodash.create = create;
            lodash.curry = curry;
            lodash.curryRight = curryRight;
            lodash.debounce = debounce;
            lodash.defaults = Hn;
            lodash.defaultsDeep = Gn;
            lodash.defer = Sn;
            lodash.delay = In;
            lodash.difference = Ht;
            lodash.differenceBy = Gt;
            lodash.differenceWith = $t;
            lodash.drop = drop;
            lodash.dropRight = dropRight;
            lodash.dropRightWhile = dropRightWhile;
            lodash.dropWhile = dropWhile;
            lodash.fill = fill;
            lodash.filter = filter;
            lodash.flatMap = flatMap;
            lodash.flatMapDeep = flatMapDeep;
            lodash.flatMapDepth = flatMapDepth;
            lodash.flatten = flatten;
            lodash.flattenDeep = flattenDeep;
            lodash.flattenDepth = flattenDepth;
            lodash.flip = flip;
            lodash.flow = pa;
            lodash.flowRight = da;
            lodash.fromPairs = fromPairs;
            lodash.functions = functions;
            lodash.functionsIn = functionsIn;
            lodash.groupBy = dn;
            lodash.initial = initial;
            lodash.intersection = Jt;
            lodash.intersectionBy = Zt;
            lodash.intersectionWith = Xt;
            lodash.invert = $n;
            lodash.invertBy = Jn;
            lodash.invokeMap = yn;
            lodash.iteratee = iteratee;
            lodash.keyBy = gn;
            lodash.keys = keys;
            lodash.keysIn = keysIn;
            lodash.map = map;
            lodash.mapKeys = mapKeys;
            lodash.mapValues = mapValues;
            lodash.matches = matches;
            lodash.matchesProperty = matchesProperty;
            lodash.memoize = memoize;
            lodash.merge = Xn;
            lodash.mergeWith = Yn;
            lodash.method = ya;
            lodash.methodOf = ga;
            lodash.mixin = mixin;
            lodash.negate = negate;
            lodash.nthArg = nthArg;
            lodash.omit = Qn;
            lodash.omitBy = omitBy;
            lodash.once = once;
            lodash.orderBy = orderBy;
            lodash.over = va;
            lodash.overArgs = An;
            lodash.overEvery = ba;
            lodash.overSome = ma;
            lodash.partial = xn;
            lodash.partialRight = kn;
            lodash.partition = vn;
            lodash.pick = ea;
            lodash.pickBy = pickBy;
            lodash.property = property;
            lodash.propertyOf = propertyOf;
            lodash.pull = Yt;
            lodash.pullAll = pullAll;
            lodash.pullAllBy = pullAllBy;
            lodash.pullAllWith = pullAllWith;
            lodash.pullAt = Qt;
            lodash.range = _a;
            lodash.rangeRight = wa;
            lodash.rearg = jn;
            lodash.reject = reject;
            lodash.remove = remove;
            lodash.rest = rest;
            lodash.reverse = reverse;
            lodash.sampleSize = sampleSize;
            lodash.set = set;
            lodash.setWith = setWith;
            lodash.shuffle = shuffle;
            lodash.slice = slice;
            lodash.sortBy = bn;
            lodash.sortedUniq = sortedUniq;
            lodash.sortedUniqBy = sortedUniqBy;
            lodash.split = split;
            lodash.spread = spread;
            lodash.tail = tail;
            lodash.take = take;
            lodash.takeRight = takeRight;
            lodash.takeRightWhile = takeRightWhile;
            lodash.takeWhile = takeWhile;
            lodash.tap = tap;
            lodash.throttle = throttle;
            lodash.thru = thru;
            lodash.toArray = toArray;
            lodash.toPairs = ra;
            lodash.toPairsIn = ta;
            lodash.toPath = toPath;
            lodash.toPlainObject = toPlainObject;
            lodash.transform = transform;
            lodash.unary = unary;
            lodash.union = en;
            lodash.unionBy = rn;
            lodash.unionWith = tn;
            lodash.uniq = uniq;
            lodash.uniqBy = uniqBy;
            lodash.uniqWith = uniqWith;
            lodash.unset = unset;
            lodash.unzip = unzip;
            lodash.unzipWith = unzipWith;
            lodash.update = update;
            lodash.updateWith = updateWith;
            lodash.values = values;
            lodash.valuesIn = valuesIn;
            lodash.without = nn;
            lodash.words = words;
            lodash.wrap = wrap;
            lodash.xor = an;
            lodash.xorBy = sn;
            lodash.xorWith = on;
            lodash.zip = un;
            lodash.zipObject = zipObject;
            lodash.zipObjectDeep = zipObjectDeep;
            lodash.zipWith = ln;
            lodash.entries = ra;
            lodash.entriesIn = ta;
            lodash.extend = qn;
            lodash.extendWith = Vn;
            mixin(lodash, lodash);
            lodash.add = Sa;
            lodash.attempt = fa;
            lodash.camelCase = na;
            lodash.capitalize = capitalize;
            lodash.ceil = Ia;
            lodash.clamp = clamp;
            lodash.clone = clone;
            lodash.cloneDeep = cloneDeep;
            lodash.cloneDeepWith = cloneDeepWith;
            lodash.cloneWith = cloneWith;
            lodash.conformsTo = conformsTo;
            lodash.deburr = deburr;
            lodash.defaultTo = defaultTo;
            lodash.divide = Aa;
            lodash.endsWith = endsWith;
            lodash.eq = eq;
            lodash.escape = escape;
            lodash.escapeRegExp = escapeRegExp;
            lodash.every = every;
            lodash.find = hn;
            lodash.findIndex = findIndex;
            lodash.findKey = findKey;
            lodash.findLast = pn;
            lodash.findLastIndex = findLastIndex;
            lodash.findLastKey = findLastKey;
            lodash.floor = xa;
            lodash.forEach = forEach;
            lodash.forEachRight = forEachRight;
            lodash.forIn = forIn;
            lodash.forInRight = forInRight;
            lodash.forOwn = forOwn;
            lodash.forOwnRight = forOwnRight;
            lodash.get = get;
            lodash.gt = On;
            lodash.gte = En;
            lodash.has = has;
            lodash.hasIn = hasIn;
            lodash.head = head;
            lodash.identity = identity;
            lodash.includes = includes;
            lodash.indexOf = indexOf;
            lodash.inRange = inRange;
            lodash.invoke = Zn;
            lodash.isArguments = Rn;
            lodash.isArray = Ln;
            lodash.isArrayBuffer = Cn;
            lodash.isArrayLike = isArrayLike;
            lodash.isArrayLikeObject = isArrayLikeObject;
            lodash.isBoolean = isBoolean;
            lodash.isBuffer = Tn;
            lodash.isDate = Wn;
            lodash.isElement = isElement;
            lodash.isEmpty = isEmpty;
            lodash.isEqual = isEqual;
            lodash.isEqualWith = isEqualWith;
            lodash.isError = isError;
            lodash.isFinite = isFinite2;
            lodash.isFunction = isFunction;
            lodash.isInteger = isInteger;
            lodash.isLength = isLength;
            lodash.isMap = Pn;
            lodash.isMatch = isMatch;
            lodash.isMatchWith = isMatchWith;
            lodash.isNaN = isNaN2;
            lodash.isNative = isNative;
            lodash.isNil = isNil;
            lodash.isNull = isNull;
            lodash.isNumber = isNumber;
            lodash.isObject = isObject;
            lodash.isObjectLike = isObjectLike;
            lodash.isPlainObject = isPlainObject;
            lodash.isRegExp = zn;
            lodash.isSafeInteger = isSafeInteger;
            lodash.isSet = Bn;
            lodash.isString = isString;
            lodash.isSymbol = isSymbol;
            lodash.isTypedArray = Fn;
            lodash.isUndefined = isUndefined;
            lodash.isWeakMap = isWeakMap;
            lodash.isWeakSet = isWeakSet;
            lodash.join = join;
            lodash.kebabCase = aa;
            lodash.last = last;
            lodash.lastIndexOf = lastIndexOf;
            lodash.lowerCase = ia;
            lodash.lowerFirst = sa;
            lodash.lt = Mn;
            lodash.lte = Dn;
            lodash.max = max;
            lodash.maxBy = maxBy;
            lodash.mean = mean;
            lodash.meanBy = meanBy;
            lodash.min = min;
            lodash.minBy = minBy;
            lodash.stubArray = stubArray;
            lodash.stubFalse = stubFalse;
            lodash.stubObject = stubObject;
            lodash.stubString = stubString;
            lodash.stubTrue = stubTrue;
            lodash.multiply = ka;
            lodash.nth = nth;
            lodash.noConflict = noConflict;
            lodash.noop = noop;
            lodash.now = mn;
            lodash.pad = pad;
            lodash.padEnd = padEnd;
            lodash.padStart = padStart;
            lodash.parseInt = parseInt2;
            lodash.random = random;
            lodash.reduce = reduce;
            lodash.reduceRight = reduceRight;
            lodash.repeat = repeat;
            lodash.replace = replace;
            lodash.result = result;
            lodash.round = ja;
            lodash.runInContext = runInContext;
            lodash.sample = sample;
            lodash.size = size;
            lodash.snakeCase = oa;
            lodash.some = some;
            lodash.sortedIndex = sortedIndex;
            lodash.sortedIndexBy = sortedIndexBy;
            lodash.sortedIndexOf = sortedIndexOf;
            lodash.sortedLastIndex = sortedLastIndex;
            lodash.sortedLastIndexBy = sortedLastIndexBy;
            lodash.sortedLastIndexOf = sortedLastIndexOf;
            lodash.startCase = ua;
            lodash.startsWith = startsWith;
            lodash.subtract = Oa;
            lodash.sum = sum;
            lodash.sumBy = sumBy;
            lodash.template = template;
            lodash.times = times;
            lodash.toFinite = toFinite;
            lodash.toInteger = toInteger;
            lodash.toLength = toLength;
            lodash.toLower = toLower;
            lodash.toNumber = toNumber;
            lodash.toSafeInteger = toSafeInteger;
            lodash.toString = toString;
            lodash.toUpper = toUpper;
            lodash.trim = trim;
            lodash.trimEnd = trimEnd;
            lodash.trimStart = trimStart;
            lodash.truncate = truncate;
            lodash.unescape = unescape;
            lodash.uniqueId = uniqueId;
            lodash.upperCase = la;
            lodash.upperFirst = ca;
            lodash.each = forEach;
            lodash.eachRight = forEachRight;
            lodash.first = head;
            mixin(lodash, function() {
              var e4 = {};
              baseForOwn(lodash, function(r4, t4) {
                if (!cr2.call(lodash.prototype, t4)) {
                  e4[t4] = r4;
                }
              });
              return e4;
            }(), { chain: false });
            lodash.VERSION = n;
            arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(e4) {
              lodash[e4].placeholder = lodash;
            });
            arrayEach(["drop", "take"], function(e4, r4) {
              LazyWrapper.prototype[e4] = function(n2) {
                n2 = n2 === t3 ? 1 : Mr2(toInteger(n2), 0);
                var a2 = this.__filtered__ && !r4 ? new LazyWrapper(this) : this.clone();
                if (a2.__filtered__) {
                  a2.__takeCount__ = qr2(n2, a2.__takeCount__);
                } else {
                  a2.__views__.push({ size: qr2(n2, B), type: e4 + (a2.__dir__ < 0 ? "Right" : "") });
                }
                return a2;
              };
              LazyWrapper.prototype[e4 + "Right"] = function(r5) {
                return this.reverse()[e4](r5).reverse();
              };
            });
            arrayEach(["filter", "map", "takeWhile"], function(e4, r4) {
              var t4 = r4 + 1, n2 = t4 == R || t4 == C;
              LazyWrapper.prototype[e4] = function(e5) {
                var r5 = this.clone();
                r5.__iteratees__.push({ iteratee: getIteratee(e5, 3), type: t4 });
                r5.__filtered__ = r5.__filtered__ || n2;
                return r5;
              };
            });
            arrayEach(["head", "last"], function(e4, r4) {
              var t4 = "take" + (r4 ? "Right" : "");
              LazyWrapper.prototype[e4] = function() {
                return this[t4](1).value()[0];
              };
            });
            arrayEach(["initial", "tail"], function(e4, r4) {
              var t4 = "drop" + (r4 ? "" : "Right");
              LazyWrapper.prototype[e4] = function() {
                return this.__filtered__ ? new LazyWrapper(this) : this[t4](1);
              };
            });
            LazyWrapper.prototype.compact = function() {
              return this.filter(identity);
            };
            LazyWrapper.prototype.find = function(e4) {
              return this.filter(e4).head();
            };
            LazyWrapper.prototype.findLast = function(e4) {
              return this.reverse().find(e4);
            };
            LazyWrapper.prototype.invokeMap = baseRest(function(e4, r4) {
              if (typeof e4 == "function") {
                return new LazyWrapper(this);
              }
              return this.map(function(t4) {
                return baseInvoke(t4, e4, r4);
              });
            });
            LazyWrapper.prototype.reject = function(e4) {
              return this.filter(negate(getIteratee(e4)));
            };
            LazyWrapper.prototype.slice = function(e4, r4) {
              e4 = toInteger(e4);
              var n2 = this;
              if (n2.__filtered__ && (e4 > 0 || r4 < 0)) {
                return new LazyWrapper(n2);
              }
              if (e4 < 0) {
                n2 = n2.takeRight(-e4);
              } else if (e4) {
                n2 = n2.drop(e4);
              }
              if (r4 !== t3) {
                r4 = toInteger(r4);
                n2 = r4 < 0 ? n2.dropRight(-r4) : n2.take(r4 - e4);
              }
              return n2;
            };
            LazyWrapper.prototype.takeRightWhile = function(e4) {
              return this.reverse().takeWhile(e4).reverse();
            };
            LazyWrapper.prototype.toArray = function() {
              return this.take(B);
            };
            baseForOwn(LazyWrapper.prototype, function(e4, r4) {
              var n2 = /^(?:filter|find|map|reject)|While$/.test(r4), a2 = /^(?:head|last)$/.test(r4), i2 = lodash[a2 ? "take" + (r4 == "last" ? "Right" : "") : r4], s2 = a2 || /^find/.test(r4);
              if (!i2) {
                return;
              }
              lodash.prototype[r4] = function() {
                var r5 = this.__wrapped__, o2 = a2 ? [1] : arguments, u2 = r5 instanceof LazyWrapper, l2 = o2[0], c2 = u2 || Ln(r5);
                var interceptor = function(e5) {
                  var r6 = i2.apply(lodash, arrayPush([e5], o2));
                  return a2 && f2 ? r6[0] : r6;
                };
                if (c2 && n2 && typeof l2 == "function" && l2.length != 1) {
                  u2 = c2 = false;
                }
                var f2 = this.__chain__, h2 = !!this.__actions__.length, p2 = s2 && !f2, d2 = u2 && !h2;
                if (!s2 && c2) {
                  r5 = d2 ? r5 : new LazyWrapper(this);
                  var y2 = e4.apply(r5, o2);
                  y2.__actions__.push({ func: thru, args: [interceptor], thisArg: t3 });
                  return new LodashWrapper(y2, f2);
                }
                if (p2 && d2) {
                  return e4.apply(this, o2);
                }
                y2 = this.thru(interceptor);
                return p2 ? a2 ? y2.value()[0] : y2.value() : y2;
              };
            });
            arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(e4) {
              var r4 = ir2[e4], t4 = /^(?:push|sort|unshift)$/.test(e4) ? "tap" : "thru", n2 = /^(?:pop|shift)$/.test(e4);
              lodash.prototype[e4] = function() {
                var e5 = arguments;
                if (n2 && !this.__chain__) {
                  var a2 = this.value();
                  return r4.apply(Ln(a2) ? a2 : [], e5);
                }
                return this[t4](function(t5) {
                  return r4.apply(Ln(t5) ? t5 : [], e5);
                });
              };
            });
            baseForOwn(LazyWrapper.prototype, function(e4, r4) {
              var t4 = lodash[r4];
              if (t4) {
                var n2 = t4.name + "";
                if (!cr2.call(ut2, n2)) {
                  ut2[n2] = [];
                }
                ut2[n2].push({ name: r4, func: t4 });
              }
            });
            ut2[createHybrid(t3, v).name] = [{ name: "wrapper", func: t3 }];
            LazyWrapper.prototype.clone = lazyClone;
            LazyWrapper.prototype.reverse = lazyReverse;
            LazyWrapper.prototype.value = lazyValue;
            lodash.prototype.at = cn;
            lodash.prototype.chain = wrapperChain;
            lodash.prototype.commit = wrapperCommit;
            lodash.prototype.next = wrapperNext;
            lodash.prototype.plant = wrapperPlant;
            lodash.prototype.reverse = wrapperReverse;
            lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
            lodash.prototype.first = lodash.prototype.head;
            if (kr2) {
              lodash.prototype[kr2] = wrapperToIterator;
            }
            return lodash;
          };
          var wt = _t();
          if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
            at._ = wt;
            define(function() {
              return wt;
            });
          } else if (st) {
            (st.exports = wt)._ = wt;
            it._ = wt;
          } else {
            at._ = wt;
          }
        }).call(this);
      }, 958: (e2) => {
        var r2 = 1e3;
        var t2 = r2 * 60;
        var n = t2 * 60;
        var a = n * 24;
        var i = a * 7;
        var s = a * 365.25;
        e2.exports = function(e3, r3) {
          r3 = r3 || {};
          var t3 = typeof e3;
          if (t3 === "string" && e3.length > 0) {
            return parse(e3);
          } else if (t3 === "number" && isFinite(e3)) {
            return r3.long ? fmtLong(e3) : fmtShort(e3);
          }
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e3));
        };
        function parse(e3) {
          e3 = String(e3);
          if (e3.length > 100) {
            return;
          }
          var o = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e3);
          if (!o) {
            return;
          }
          var u = parseFloat(o[1]);
          var l = (o[2] || "ms").toLowerCase();
          switch (l) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return u * s;
            case "weeks":
            case "week":
            case "w":
              return u * i;
            case "days":
            case "day":
            case "d":
              return u * a;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return u * n;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return u * t2;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return u * r2;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return u;
            default:
              return void 0;
          }
        }
        function fmtShort(e3) {
          var i2 = Math.abs(e3);
          if (i2 >= a) {
            return Math.round(e3 / a) + "d";
          }
          if (i2 >= n) {
            return Math.round(e3 / n) + "h";
          }
          if (i2 >= t2) {
            return Math.round(e3 / t2) + "m";
          }
          if (i2 >= r2) {
            return Math.round(e3 / r2) + "s";
          }
          return e3 + "ms";
        }
        function fmtLong(e3) {
          var i2 = Math.abs(e3);
          if (i2 >= a) {
            return plural(e3, i2, a, "day");
          }
          if (i2 >= n) {
            return plural(e3, i2, n, "hour");
          }
          if (i2 >= t2) {
            return plural(e3, i2, t2, "minute");
          }
          if (i2 >= r2) {
            return plural(e3, i2, r2, "second");
          }
          return e3 + " ms";
        }
        function plural(e3, r3, t3, n2) {
          var a2 = r3 >= t3 * 1.5;
          return Math.round(e3 / t3) + " " + n2 + (a2 ? "s" : "");
        }
      }, 911: (e2, r2, t2) => {
        var n = t2(300);
        var a = n.Buffer;
        function copyProps(e3, r3) {
          for (var t3 in e3) {
            r3[t3] = e3[t3];
          }
        }
        if (a.from && a.alloc && a.allocUnsafe && a.allocUnsafeSlow) {
          e2.exports = n;
        } else {
          copyProps(n, r2);
          r2.Buffer = SafeBuffer;
        }
        function SafeBuffer(e3, r3, t3) {
          return a(e3, r3, t3);
        }
        SafeBuffer.prototype = Object.create(a.prototype);
        copyProps(a, SafeBuffer);
        SafeBuffer.from = function(e3, r3, t3) {
          if (typeof e3 === "number") {
            throw new TypeError("Argument must not be a number");
          }
          return a(e3, r3, t3);
        };
        SafeBuffer.alloc = function(e3, r3, t3) {
          if (typeof e3 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          var n2 = a(e3);
          if (r3 !== void 0) {
            if (typeof t3 === "string") {
              n2.fill(r3, t3);
            } else {
              n2.fill(r3);
            }
          } else {
            n2.fill(0);
          }
          return n2;
        };
        SafeBuffer.allocUnsafe = function(e3) {
          if (typeof e3 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return a(e3);
        };
        SafeBuffer.allocUnsafeSlow = function(e3) {
          if (typeof e3 !== "number") {
            throw new TypeError("Argument must be a number");
          }
          return n.SlowBuffer(e3);
        };
      }, 300: (e2) => {
        "use strict";
        e2.exports = require("buffer");
      }, 113: (e2) => {
        "use strict";
        e2.exports = require("crypto");
      }, 521: (e2) => {
        "use strict";
        e2.exports = require_semver_noop();
      }, 781: (e2) => {
        "use strict";
        e2.exports = require("stream");
      }, 837: (e2) => {
        "use strict";
        e2.exports = require("util");
      } };
      var r = {};
      function __nccwpck_require__2(t2) {
        var n = r[t2];
        if (n !== void 0) {
          return n.exports;
        }
        var a = r[t2] = { id: t2, loaded: false, exports: {} };
        var i = true;
        try {
          e[t2].call(a.exports, a, a.exports, __nccwpck_require__2);
          i = false;
        } finally {
          if (i)
            delete r[t2];
        }
        a.loaded = true;
        return a.exports;
      }
      (() => {
        __nccwpck_require__2.nmd = (e2) => {
          e2.paths = [];
          if (!e2.children)
            e2.children = [];
          return e2;
        };
      })();
      if (typeof __nccwpck_require__2 !== "undefined")
        __nccwpck_require__2.ab = "/";
      var t = __nccwpck_require__2(773);
      module.exports = t;
    })();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/crypto-utils.js
var require_crypto_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/crypto-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      decryptWithSecret: function() {
        return decryptWithSecret;
      },
      encryptWithSecret: function() {
        return encryptWithSecret;
      }
    });
    var _crypto = /* @__PURE__ */ _interop_require_default(require("crypto"));
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CIPHER_ALGORITHM = `aes-256-gcm`;
    var CIPHER_KEY_LENGTH = 32;
    var CIPHER_IV_LENGTH = 16;
    var CIPHER_TAG_LENGTH = 16;
    var CIPHER_SALT_LENGTH = 64;
    var PBKDF2_ITERATIONS = 1e5;
    function encryptWithSecret(secret, data) {
      const iv = _crypto.default.randomBytes(CIPHER_IV_LENGTH);
      const salt = _crypto.default.randomBytes(CIPHER_SALT_LENGTH);
      const key = _crypto.default.pbkdf2Sync(secret, salt, PBKDF2_ITERATIONS, CIPHER_KEY_LENGTH, `sha512`);
      const cipher = _crypto.default.createCipheriv(CIPHER_ALGORITHM, key, iv);
      const encrypted = Buffer.concat([
        cipher.update(data, `utf8`),
        cipher.final()
      ]);
      const tag = cipher.getAuthTag();
      return Buffer.concat([
        // Data as required by:
        // Salt for Key: https://nodejs.org/api/crypto.html#crypto_crypto_pbkdf2sync_password_salt_iterations_keylen_digest
        // IV: https://nodejs.org/api/crypto.html#crypto_class_decipher
        // Tag: https://nodejs.org/api/crypto.html#crypto_decipher_setauthtag_buffer
        salt,
        iv,
        tag,
        encrypted
      ]).toString(`hex`);
    }
    function decryptWithSecret(secret, encryptedData) {
      const buffer = Buffer.from(encryptedData, `hex`);
      const salt = buffer.slice(0, CIPHER_SALT_LENGTH);
      const iv = buffer.slice(CIPHER_SALT_LENGTH, CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH);
      const tag = buffer.slice(CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH, CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH);
      const encrypted = buffer.slice(CIPHER_SALT_LENGTH + CIPHER_IV_LENGTH + CIPHER_TAG_LENGTH);
      const key = _crypto.default.pbkdf2Sync(secret, salt, PBKDF2_ITERATIONS, CIPHER_KEY_LENGTH, `sha512`);
      const decipher = _crypto.default.createDecipheriv(CIPHER_ALGORITHM, key, iv);
      decipher.setAuthTag(tag);
      return decipher.update(encrypted) + decipher.final(`utf8`);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/api-utils/node/try-get-preview-data.js
var require_try_get_preview_data = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/api-utils/node/try-get-preview-data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "tryGetPreviewData", {
      enumerable: true,
      get: function() {
        return tryGetPreviewData;
      }
    });
    var _ = require_api_utils();
    var _index = require_api_utils();
    var _cookies = require_cookies2();
    var _headers = require_headers();
    function tryGetPreviewData(req, res, options, multiZoneDraftMode) {
      var _cookies_get, _cookies_get1;
      if (options && (0, _.checkIsOnDemandRevalidate)(req, options).isOnDemandRevalidate) {
        return false;
      }
      if (_index.SYMBOL_PREVIEW_DATA in req) {
        return req[_index.SYMBOL_PREVIEW_DATA];
      }
      const headers = _headers.HeadersAdapter.from(req.headers);
      const cookies = new _cookies.RequestCookies(headers);
      const previewModeId = (_cookies_get = cookies.get(_index.COOKIE_NAME_PRERENDER_BYPASS)) == null ? void 0 : _cookies_get.value;
      const tokenPreviewData = (_cookies_get1 = cookies.get(_index.COOKIE_NAME_PRERENDER_DATA)) == null ? void 0 : _cookies_get1.value;
      if (previewModeId && !tokenPreviewData && previewModeId === options.previewModeId) {
        const data = {};
        Object.defineProperty(req, _index.SYMBOL_PREVIEW_DATA, {
          value: data,
          enumerable: false
        });
        return data;
      }
      if (!previewModeId && !tokenPreviewData) {
        return false;
      }
      if (!previewModeId || !tokenPreviewData) {
        if (!multiZoneDraftMode) {
          (0, _index.clearPreviewData)(res);
        }
        return false;
      }
      if (previewModeId !== options.previewModeId) {
        if (!multiZoneDraftMode) {
          (0, _index.clearPreviewData)(res);
        }
        return false;
      }
      let encryptedPreviewData;
      try {
        const jsonwebtoken = require_jsonwebtoken();
        encryptedPreviewData = jsonwebtoken.verify(tokenPreviewData, options.previewModeSigningKey);
      } catch {
        (0, _index.clearPreviewData)(res);
        return false;
      }
      const { decryptWithSecret } = require_crypto_utils();
      const decryptedPreviewData = decryptWithSecret(Buffer.from(options.previewModeEncryptionKey), encryptedPreviewData.data);
      try {
        const data = JSON.parse(decryptedPreviewData);
        Object.defineProperty(req, _index.SYMBOL_PREVIEW_DATA, {
          value: data,
          enumerable: false
        });
        return data;
      } catch {
        return false;
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/base-server.js
var require_base_server = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/base-server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      NoFallbackError: function() {
        return NoFallbackError;
      },
      WrappedBuildError: function() {
        return WrappedBuildError;
      },
      default: function() {
        return Server;
      }
    });
    var _fallbackparams = require_fallback_params();
    var _responsecache = require_response_cache();
    var _utils = require_utils3();
    var _url = require("url");
    var _formathostname = require_format_hostname();
    var _redirectstatus = require_redirect_status();
    var _isedgeruntime = require_is_edge_runtime();
    var _constants = require_constants3();
    var _utils1 = require_utils5();
    var _apiutils = require_api_utils();
    var _runtimeconfigexternal = require_runtime_config_external();
    var _revalidate = require_revalidate();
    var _utils2 = require_utils6();
    var _isbot = require_is_bot();
    var _renderresult = /* @__PURE__ */ _interop_require_default(require_render_result());
    var _removetrailingslash = require_remove_trailing_slash();
    var _denormalizepagepath = require_denormalize_page_path();
    var _log = /* @__PURE__ */ _interop_require_wildcard(require_log());
    var _escapepathdelimiters = /* @__PURE__ */ _interop_require_default(require_escape_path_delimiters());
    var _serverutils = require_server_utils();
    var _iserror = /* @__PURE__ */ _interop_require_wildcard(require_is_error());
    var _requestmeta = require_request_meta();
    var _removepathprefix = require_remove_path_prefix();
    var _apppaths = require_app_paths();
    var _gethostname = require_get_hostname();
    var _parseurl = require_parse_url();
    var _getnextpathnameinfo = require_get_next_pathname_info();
    var _approuterheaders = require_app_router_headers();
    var _localeroutenormalizer = require_locale_route_normalizer();
    var _defaultroutematchermanager = require_default_route_matcher_manager();
    var _apppageroutematcherprovider = require_app_page_route_matcher_provider();
    var _approuteroutematcherprovider = require_app_route_route_matcher_provider();
    var _pagesapiroutematcherprovider = require_pages_api_route_matcher_provider();
    var _pagesroutematcherprovider = require_pages_route_matcher_provider();
    var _servermanifestloader = require_server_manifest_loader();
    var _tracer = require_tracer();
    var _constants1 = require_constants2();
    var _i18nprovider = require_i18n_provider();
    var _sendresponse = require_send_response();
    var _utils3 = require_utils();
    var _constants2 = require_constants();
    var _normalizelocalepath = require_normalize_locale_path();
    var _nextrequest = require_next_request();
    var _matchnextdatapathname = require_match_next_data_pathname();
    var _getroutefromassetpath = /* @__PURE__ */ _interop_require_default(require_get_route_from_asset_path());
    var _rsc = require_rsc();
    var _postponed = require_postponed();
    var _stripflightheaders = require_strip_flight_headers();
    var _checks = require_checks();
    var _prefetchrsc = require_prefetch_rsc();
    var _nextdata = require_next_data();
    var _serveractionrequestmeta = require_server_action_request_meta();
    var _interceptionroutes = require_interception_routes();
    var _toroute = require_to_route();
    var _helpers = require_helpers();
    var _patchsetheader = require_patch_set_header();
    var _ppr = require_ppr();
    var _builtinrequestcontext = require_builtin_request_context();
    var _encodedTags = require_encodedTags();
    var _adapter = require_adapter();
    var _utils4 = require_utils7();
    var _routekind = require_route_kind();
    var _fallback = require_fallback();
    var _utils5 = require_utils4();
    var _scheduler = require_scheduler();
    var _prefetchcachescopes = require_prefetch_cache_scopes();
    var _cachescopeexternal = require_cache_scope_external();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var NoFallbackError = class extends Error {
    };
    var WrappedBuildError = class extends Error {
      constructor(innerError) {
        super();
        this.innerError = innerError;
      }
    };
    var Server = class {
      getServerComponentsHmrCache() {
        return this.nextConfig.experimental.serverComponentsHmrCache ? globalThis.__serverComponentsHmrCache : void 0;
      }
      /**
      * This is used to persist cache scopes across
      * prefetch -> full route requests for dynamic IO
      * it's only fully used in dev
      */
      constructor(options) {
        var _this_nextConfig_i18n, _this_nextConfig_experimental_amp, _this_nextConfig_i18n1;
        this.prefetchCacheScopesDev = new _prefetchcachescopes.PrefetchCacheScopes();
        this.handleRSCRequest = (req, _res, parsedUrl) => {
          var _this_normalizers_prefetchRSC, _this_normalizers_rsc;
          if (!parsedUrl.pathname)
            return false;
          if ((_this_normalizers_prefetchRSC = this.normalizers.prefetchRSC) == null ? void 0 : _this_normalizers_prefetchRSC.match(parsedUrl.pathname)) {
            parsedUrl.pathname = this.normalizers.prefetchRSC.normalize(parsedUrl.pathname, true);
            req.headers[_approuterheaders.RSC_HEADER.toLowerCase()] = "1";
            req.headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] = "1";
            (0, _requestmeta.addRequestMeta)(req, "isRSCRequest", true);
            (0, _requestmeta.addRequestMeta)(req, "isPrefetchRSCRequest", true);
          } else if ((_this_normalizers_rsc = this.normalizers.rsc) == null ? void 0 : _this_normalizers_rsc.match(parsedUrl.pathname)) {
            parsedUrl.pathname = this.normalizers.rsc.normalize(parsedUrl.pathname, true);
            req.headers[_approuterheaders.RSC_HEADER.toLowerCase()] = "1";
            (0, _requestmeta.addRequestMeta)(req, "isRSCRequest", true);
          } else if (req.headers["x-now-route-matches"]) {
            (0, _stripflightheaders.stripFlightHeaders)(req.headers);
            return false;
          } else if (req.headers[_approuterheaders.RSC_HEADER.toLowerCase()] === "1") {
            (0, _requestmeta.addRequestMeta)(req, "isRSCRequest", true);
            if (req.headers[_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER.toLowerCase()] === "1") {
              (0, _requestmeta.addRequestMeta)(req, "isPrefetchRSCRequest", true);
            }
          } else {
            return false;
          }
          if (req.url) {
            const parsed = (0, _url.parse)(req.url);
            parsed.pathname = parsedUrl.pathname;
            req.url = (0, _url.format)(parsed);
          }
          return false;
        };
        this.handleNextDataRequest = async (req, res, parsedUrl) => {
          const middleware = this.getMiddleware();
          const params = (0, _matchnextdatapathname.matchNextDataPathname)(parsedUrl.pathname);
          if (!params || !params.path) {
            return false;
          }
          if (params.path[0] !== this.buildId) {
            if ((0, _requestmeta.getRequestMeta)(req, "middlewareInvoke")) {
              return false;
            }
            await this.render404(req, res, parsedUrl);
            return true;
          }
          params.path.shift();
          const lastParam = params.path[params.path.length - 1];
          if (typeof lastParam !== "string" || !lastParam.endsWith(".json")) {
            await this.render404(req, res, parsedUrl);
            return true;
          }
          let pathname = `/${params.path.join("/")}`;
          pathname = (0, _getroutefromassetpath.default)(pathname, ".json");
          if (middleware) {
            if (this.nextConfig.trailingSlash && !pathname.endsWith("/")) {
              pathname += "/";
            }
            if (!this.nextConfig.trailingSlash && pathname.length > 1 && pathname.endsWith("/")) {
              pathname = pathname.substring(0, pathname.length - 1);
            }
          }
          if (this.i18nProvider) {
            var _req_headers_host;
            const hostname2 = req == null ? void 0 : (_req_headers_host = req.headers.host) == null ? void 0 : _req_headers_host.split(":", 1)[0].toLowerCase();
            const domainLocale = this.i18nProvider.detectDomainLocale(hostname2);
            const defaultLocale = (domainLocale == null ? void 0 : domainLocale.defaultLocale) ?? this.i18nProvider.config.defaultLocale;
            const localePathResult = this.i18nProvider.analyze(pathname);
            if (localePathResult.detectedLocale) {
              pathname = localePathResult.pathname;
            }
            parsedUrl.query.__nextLocale = localePathResult.detectedLocale;
            parsedUrl.query.__nextDefaultLocale = defaultLocale;
            if (!localePathResult.detectedLocale) {
              delete parsedUrl.query.__nextInferredLocaleFromDefault;
            }
            if (!localePathResult.detectedLocale && !middleware) {
              parsedUrl.query.__nextLocale = defaultLocale;
              await this.render404(req, res, parsedUrl);
              return true;
            }
          }
          parsedUrl.pathname = pathname;
          parsedUrl.query.__nextDataReq = "1";
          return false;
        };
        this.handleNextImageRequest = () => false;
        this.handleCatchallRenderRequest = () => false;
        this.handleCatchallMiddlewareRequest = () => false;
        this.normalize = (pathname) => {
          const normalizers = [];
          if (this.normalizers.data) {
            normalizers.push(this.normalizers.data);
          }
          if (this.normalizers.postponed) {
            normalizers.push(this.normalizers.postponed);
          }
          if (this.normalizers.prefetchRSC) {
            normalizers.push(this.normalizers.prefetchRSC);
          }
          if (this.normalizers.rsc) {
            normalizers.push(this.normalizers.rsc);
          }
          for (const normalizer of normalizers) {
            if (!normalizer.match(pathname))
              continue;
            return normalizer.normalize(pathname, true);
          }
          return pathname;
        };
        this.normalizeAndAttachMetadata = async (req, res, url) => {
          let finished = await this.handleNextImageRequest(req, res, url);
          if (finished)
            return true;
          if (this.enabledDirectories.pages) {
            finished = await this.handleNextDataRequest(req, res, url);
            if (finished)
              return true;
          }
          return false;
        };
        this.prepared = false;
        this.preparedPromise = null;
        this.customErrorNo404Warn = (0, _utils.execOnce)(() => {
          _log.warn(`You have added a custom /_error page without a custom /404 page. This prevents the 404 page from being auto statically optimized.
See here for info: https://nextjs.org/docs/messages/custom-error-no-custom-404`);
        });
        const { dir = ".", quiet = false, conf, dev = false, minimalMode = false, customServer = true, hostname, port, experimentalTestProxy } = options;
        this.experimentalTestProxy = experimentalTestProxy;
        this.serverOptions = options;
        this.dir = false ? dir : require("path").resolve(dir);
        this.quiet = quiet;
        this.loadEnvConfig({
          dev
        });
        this.nextConfig = conf;
        this.hostname = hostname;
        if (this.hostname) {
          this.fetchHostname = (0, _formathostname.formatHostname)(this.hostname);
        }
        this.port = port;
        this.distDir = false ? this.nextConfig.distDir : require("path").join(this.dir, this.nextConfig.distDir);
        this.publicDir = this.getPublicDir();
        this.hasStaticDir = !minimalMode && this.getHasStaticDir();
        this.i18nProvider = ((_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.locales) ? new _i18nprovider.I18NProvider(this.nextConfig.i18n) : void 0;
        this.localeNormalizer = this.i18nProvider ? new _localeroutenormalizer.LocaleRouteNormalizer(this.i18nProvider) : void 0;
        const { serverRuntimeConfig = {}, publicRuntimeConfig, assetPrefix, generateEtags } = this.nextConfig;
        this.buildId = this.getBuildId();
        const minimalModeKey = "minimalMode";
        this[minimalModeKey] = minimalMode || !!process.env.NEXT_PRIVATE_MINIMAL_MODE;
        this.enabledDirectories = this.getEnabledDirectories(dev);
        this.isAppPPREnabled = this.enabledDirectories.app && (0, _ppr.checkIsAppPPREnabled)(this.nextConfig.experimental.ppr);
        this.normalizers = {
          // We should normalize the pathname from the RSC prefix only in minimal
          // mode as otherwise that route is not exposed external to the server as
          // we instead only rely on the headers.
          postponed: this.isAppPPREnabled && this.minimalMode ? new _postponed.PostponedPathnameNormalizer() : void 0,
          rsc: this.enabledDirectories.app && this.minimalMode ? new _rsc.RSCPathnameNormalizer() : void 0,
          prefetchRSC: this.isAppPPREnabled && this.minimalMode ? new _prefetchrsc.PrefetchRSCPathnameNormalizer() : void 0,
          data: this.enabledDirectories.pages ? new _nextdata.NextDataPathnameNormalizer(this.buildId) : void 0
        };
        this.nextFontManifest = this.getNextFontManifest();
        if (true) {
          process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || "";
        }
        this.renderOpts = {
          supportsDynamicResponse: true,
          trailingSlash: this.nextConfig.trailingSlash,
          deploymentId: this.nextConfig.deploymentId,
          strictNextHead: this.nextConfig.experimental.strictNextHead ?? true,
          poweredByHeader: this.nextConfig.poweredByHeader,
          canonicalBase: this.nextConfig.amp.canonicalBase || "",
          buildId: this.buildId,
          generateEtags,
          previewProps: this.getPrerenderManifest().preview,
          customServer: customServer === true ? true : void 0,
          ampOptimizerConfig: (_this_nextConfig_experimental_amp = this.nextConfig.experimental.amp) == null ? void 0 : _this_nextConfig_experimental_amp.optimizer,
          basePath: this.nextConfig.basePath,
          images: this.nextConfig.images,
          optimizeCss: this.nextConfig.experimental.optimizeCss,
          nextConfigOutput: this.nextConfig.output,
          nextScriptWorkers: this.nextConfig.experimental.nextScriptWorkers,
          disableOptimizedLoading: this.nextConfig.experimental.disableOptimizedLoading,
          domainLocales: (_this_nextConfig_i18n1 = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n1.domains,
          distDir: this.distDir,
          serverComponents: this.enabledDirectories.app,
          cacheLifeProfiles: this.nextConfig.experimental.cacheLife,
          enableTainting: this.nextConfig.experimental.taint,
          crossOrigin: this.nextConfig.crossOrigin ? this.nextConfig.crossOrigin : void 0,
          largePageDataBytes: this.nextConfig.experimental.largePageDataBytes,
          // Only the `publicRuntimeConfig` key is exposed to the client side
          // It'll be rendered as part of __NEXT_DATA__ on the client side
          runtimeConfig: Object.keys(publicRuntimeConfig).length > 0 ? publicRuntimeConfig : void 0,
          // @ts-expect-error internal field not publicly exposed
          isExperimentalCompile: this.nextConfig.experimental.isExperimentalCompile,
          experimental: {
            expireTime: this.nextConfig.expireTime,
            clientTraceMetadata: this.nextConfig.experimental.clientTraceMetadata,
            after: this.nextConfig.experimental.after ?? false,
            dynamicIO: this.nextConfig.experimental.dynamicIO ?? false
          },
          onInstrumentationRequestError: this.instrumentationOnRequestError.bind(this),
          reactMaxHeadersLength: this.nextConfig.reactMaxHeadersLength
        };
        (0, _runtimeconfigexternal.setConfig)({
          serverRuntimeConfig,
          publicRuntimeConfig
        });
        this.pagesManifest = this.getPagesManifest();
        this.appPathsManifest = this.getAppPathsManifest();
        this.appPathRoutes = this.getAppPathRoutes();
        this.interceptionRoutePatterns = this.getinterceptionRoutePatterns();
        this.matchers = this.getRouteMatchers();
        void this.matchers.reload();
        this.setAssetPrefix(assetPrefix);
        this.responseCache = this.getResponseCache({
          dev
        });
      }
      reloadMatchers() {
        return this.matchers.reload();
      }
      getRouteMatchers() {
        const manifestLoader = new _servermanifestloader.ServerManifestLoader((name) => {
          switch (name) {
            case _constants.PAGES_MANIFEST:
              return this.getPagesManifest() ?? null;
            case _constants.APP_PATHS_MANIFEST:
              return this.getAppPathsManifest() ?? null;
            default:
              return null;
          }
        });
        const matchers = new _defaultroutematchermanager.DefaultRouteMatcherManager();
        matchers.push(new _pagesroutematcherprovider.PagesRouteMatcherProvider(this.distDir, manifestLoader, this.i18nProvider));
        matchers.push(new _pagesapiroutematcherprovider.PagesAPIRouteMatcherProvider(this.distDir, manifestLoader, this.i18nProvider));
        if (this.enabledDirectories.app) {
          matchers.push(new _apppageroutematcherprovider.AppPageRouteMatcherProvider(this.distDir, manifestLoader));
          matchers.push(new _approuteroutematcherprovider.AppRouteRouteMatcherProvider(this.distDir, manifestLoader));
        }
        return matchers;
      }
      async instrumentationOnRequestError(...args) {
        const [err, req, ctx] = args;
        if (this.instrumentation) {
          try {
            await (this.instrumentation.onRequestError == null ? void 0 : this.instrumentation.onRequestError.call(this.instrumentation, err, {
              path: req.url || "",
              method: req.method || "GET",
              // Normalize middleware headers and other server request headers
              headers: req instanceof _adapter.NextRequestHint ? Object.fromEntries(req.headers.entries()) : req.headers
            }, ctx));
          } catch (handlerErr) {
            console.error("Error in instrumentation.onRequestError:", handlerErr);
          }
        }
      }
      logError(err) {
        if (this.quiet)
          return;
        _log.error(err);
      }
      async handleRequest(req, res, parsedUrl) {
        await this.prepare();
        const method = req.method.toUpperCase();
        const tracer = (0, _tracer.getTracer)();
        return tracer.withPropagatedContext(req.headers, () => {
          return tracer.trace(_constants1.BaseServerSpan.handleRequest, {
            spanName: `${method} ${req.url}`,
            kind: _tracer.SpanKind.SERVER,
            attributes: {
              "http.method": method,
              "http.target": req.url
            }
          }, async (span) => this.handleRequestImpl(req, res, parsedUrl).finally(() => {
            if (!span)
              return;
            const isRSCRequest = (0, _requestmeta.getRequestMeta)(req, "isRSCRequest") ?? false;
            span.setAttributes({
              "http.status_code": res.statusCode,
              "next.rsc": isRSCRequest
            });
            const rootSpanAttributes = tracer.getRootSpanAttributes();
            if (!rootSpanAttributes)
              return;
            if (rootSpanAttributes.get("next.span_type") !== _constants1.BaseServerSpan.handleRequest) {
              console.warn(`Unexpected root span type '${rootSpanAttributes.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);
              return;
            }
            const route = rootSpanAttributes.get("next.route");
            if (route) {
              const name = isRSCRequest ? `RSC ${method} ${route}` : `${method} ${route}`;
              span.setAttributes({
                "next.route": route,
                "http.route": route,
                "next.span_name": name
              });
              span.updateName(name);
            } else {
              span.updateName(isRSCRequest ? `RSC ${method} ${req.url}` : `${method} ${req.url}`);
            }
          }));
        });
      }
      async handleRequestImpl(req, res, parsedUrl) {
        try {
          var _originalRequest_socket, _originalRequest_socket1, _this_i18nProvider, _this_i18nProvider1, _this_nextConfig_i18n;
          await this.matchers.waitTillReady();
          (0, _patchsetheader.patchSetHeaderWithCookieSupport)(req, (0, _helpers.isNodeNextResponse)(res) ? res.originalResponse : res);
          const urlParts = (req.url || "").split("?", 1);
          const urlNoQuery = urlParts[0];
          if (urlNoQuery == null ? void 0 : urlNoQuery.match(/(\\|\/\/)/)) {
            const cleanUrl = (0, _utils.normalizeRepeatedSlashes)(req.url);
            res.redirect(cleanUrl, 308).body(cleanUrl).send();
            return;
          }
          if (!parsedUrl || typeof parsedUrl !== "object") {
            if (!req.url) {
              throw new Error("Invariant: url can not be undefined");
            }
            parsedUrl = (0, _url.parse)(req.url, true);
          }
          if (!parsedUrl.pathname) {
            throw new Error("Invariant: pathname can't be empty");
          }
          if (typeof parsedUrl.query === "string") {
            parsedUrl.query = Object.fromEntries(new URLSearchParams(parsedUrl.query));
          }
          const { originalRequest = null } = (0, _helpers.isNodeNextRequest)(req) ? req : {};
          const xForwardedProto = originalRequest == null ? void 0 : originalRequest.headers["x-forwarded-proto"];
          const isHttps = xForwardedProto ? xForwardedProto === "https" : !!(originalRequest == null ? void 0 : (_originalRequest_socket = originalRequest.socket) == null ? void 0 : _originalRequest_socket.encrypted);
          req.headers["x-forwarded-host"] ??= req.headers["host"] ?? this.hostname;
          req.headers["x-forwarded-port"] ??= this.port ? this.port.toString() : isHttps ? "443" : "80";
          req.headers["x-forwarded-proto"] ??= isHttps ? "https" : "http";
          req.headers["x-forwarded-for"] ??= originalRequest == null ? void 0 : (_originalRequest_socket1 = originalRequest.socket) == null ? void 0 : _originalRequest_socket1.remoteAddress;
          if (!((_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.validateQuery(parsedUrl.query))) {
            delete parsedUrl.query.__nextLocale;
            delete parsedUrl.query.__nextDefaultLocale;
            delete parsedUrl.query.__nextInferredLocaleFromDefault;
          }
          this.attachRequestMeta(req, parsedUrl);
          let finished = await this.handleRSCRequest(req, res, parsedUrl);
          if (finished)
            return;
          const domainLocale = (_this_i18nProvider1 = this.i18nProvider) == null ? void 0 : _this_i18nProvider1.detectDomainLocale((0, _gethostname.getHostname)(parsedUrl, req.headers));
          const defaultLocale = (domainLocale == null ? void 0 : domainLocale.defaultLocale) || ((_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.defaultLocale);
          parsedUrl.query.__nextDefaultLocale = defaultLocale;
          const url = (0, _parseurl.parseUrl)(req.url.replace(/^\/+/, "/"));
          const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(url.pathname, {
            nextConfig: this.nextConfig,
            i18nProvider: this.i18nProvider
          });
          url.pathname = pathnameInfo.pathname;
          if (pathnameInfo.basePath) {
            req.url = (0, _removepathprefix.removePathPrefix)(req.url, this.nextConfig.basePath);
          }
          const useMatchedPathHeader = this.minimalMode && typeof req.headers["x-matched-path"] === "string";
          if (useMatchedPathHeader) {
            try {
              var _this_normalizers_data, _this_normalizers_postponed, _this_i18nProvider2, _this_getRoutesManifest;
              if (this.enabledDirectories.app) {
                if (req.url.match(/^\/index($|\?)/)) {
                  req.url = req.url.replace(/^\/index/, "/");
                }
                parsedUrl.pathname = parsedUrl.pathname === "/index" ? "/" : parsedUrl.pathname;
              }
              let { pathname: matchedPath } = new URL(req.headers["x-matched-path"], "http://localhost");
              let { pathname: urlPathname } = new URL(req.url, "http://localhost");
              if ((_this_normalizers_data = this.normalizers.data) == null ? void 0 : _this_normalizers_data.match(urlPathname)) {
                parsedUrl.query.__nextDataReq = "1";
              } else if (((_this_normalizers_postponed = this.normalizers.postponed) == null ? void 0 : _this_normalizers_postponed.match(matchedPath)) && req.method === "POST") {
                const body = [];
                for await (const chunk of req.body) {
                  body.push(chunk);
                }
                const postponed = Buffer.concat(body).toString("utf8");
                (0, _requestmeta.addRequestMeta)(req, "postponed", postponed);
                if (!req.headers["x-now-route-matches"]) {
                  urlPathname = this.normalizers.postponed.normalize(matchedPath, true);
                }
              } else if (this.isAppPPREnabled && this.minimalMode && req.headers[_constants2.NEXT_RESUME_HEADER] === "1" && req.method === "POST") {
                const body = [];
                for await (const chunk of req.body) {
                  body.push(chunk);
                }
                const postponed = Buffer.concat(body).toString("utf8");
                (0, _requestmeta.addRequestMeta)(req, "postponed", postponed);
              }
              matchedPath = this.normalize(matchedPath);
              const normalizedUrlPath = this.stripNextDataPath(urlPathname);
              const localeAnalysisResult = (_this_i18nProvider2 = this.i18nProvider) == null ? void 0 : _this_i18nProvider2.analyze(matchedPath, {
                defaultLocale
              });
              if (localeAnalysisResult) {
                parsedUrl.query.__nextLocale = localeAnalysisResult.detectedLocale;
                if (localeAnalysisResult.inferredFromDefault) {
                  parsedUrl.query.__nextInferredLocaleFromDefault = "1";
                } else {
                  delete parsedUrl.query.__nextInferredLocaleFromDefault;
                }
              }
              matchedPath = (0, _denormalizepagepath.denormalizePagePath)(matchedPath);
              let srcPathname = matchedPath;
              let pageIsDynamic = (0, _utils1.isDynamicRoute)(srcPathname);
              if (!pageIsDynamic) {
                const match = await this.matchers.match(srcPathname, {
                  i18n: localeAnalysisResult
                });
                if (match) {
                  srcPathname = match.definition.pathname;
                  pageIsDynamic = typeof match.params !== "undefined";
                }
              }
              if (localeAnalysisResult) {
                matchedPath = localeAnalysisResult.pathname;
              }
              const utils = (0, _serverutils.getUtils)({
                pageIsDynamic,
                page: srcPathname,
                i18n: this.nextConfig.i18n,
                basePath: this.nextConfig.basePath,
                rewrites: ((_this_getRoutesManifest = this.getRoutesManifest()) == null ? void 0 : _this_getRoutesManifest.rewrites) || {
                  beforeFiles: [],
                  afterFiles: [],
                  fallback: []
                },
                caseSensitive: !!this.nextConfig.experimental.caseSensitiveRoutes
              });
              if (defaultLocale && !pathnameInfo.locale) {
                parsedUrl.pathname = `/${defaultLocale}${parsedUrl.pathname}`;
              }
              const pathnameBeforeRewrite = parsedUrl.pathname;
              const rewriteParams = utils.handleRewrites(req, parsedUrl);
              const rewriteParamKeys = Object.keys(rewriteParams);
              const didRewrite = pathnameBeforeRewrite !== parsedUrl.pathname;
              if (didRewrite && parsedUrl.pathname) {
                (0, _requestmeta.addRequestMeta)(req, "rewroteURL", parsedUrl.pathname);
              }
              const routeParamKeys = /* @__PURE__ */ new Set();
              for (const key of Object.keys(parsedUrl.query)) {
                const value = parsedUrl.query[key];
                (0, _utils3.normalizeNextQueryParam)(key, (normalizedKey) => {
                  if (!parsedUrl)
                    return;
                  parsedUrl.query[normalizedKey] = value;
                  routeParamKeys.add(normalizedKey);
                  delete parsedUrl.query[key];
                });
              }
              if (pageIsDynamic) {
                let params = {};
                let paramsResult = utils.normalizeDynamicRouteParams(parsedUrl.query);
                if (!paramsResult.hasValidParams && !(0, _utils1.isDynamicRoute)(normalizedUrlPath)) {
                  let matcherParams = utils.dynamicRouteMatcher == null ? void 0 : utils.dynamicRouteMatcher.call(utils, normalizedUrlPath);
                  if (matcherParams) {
                    utils.normalizeDynamicRouteParams(matcherParams);
                    Object.assign(paramsResult.params, matcherParams);
                    paramsResult.hasValidParams = true;
                  }
                }
                if (
                  // we can have a collision with /index and a top-level /[slug]
                  matchedPath !== "/index" && !paramsResult.hasValidParams && !(0, _utils1.isDynamicRoute)(matchedPath)
                ) {
                  let matcherParams = utils.dynamicRouteMatcher == null ? void 0 : utils.dynamicRouteMatcher.call(utils, matchedPath);
                  if (matcherParams) {
                    const curParamsResult = utils.normalizeDynamicRouteParams(matcherParams);
                    if (curParamsResult.hasValidParams) {
                      Object.assign(params, matcherParams);
                      paramsResult = curParamsResult;
                    }
                  }
                }
                if (paramsResult.hasValidParams) {
                  params = paramsResult.params;
                }
                if (req.headers["x-now-route-matches"] && (0, _utils1.isDynamicRoute)(matchedPath) && !paramsResult.hasValidParams) {
                  const opts = {};
                  const routeParams = utils.getParamsFromRouteMatches(req, opts, parsedUrl.query.__nextLocale || "");
                  if (opts.locale) {
                    parsedUrl.query.__nextLocale = opts.locale;
                    delete parsedUrl.query.__nextInferredLocaleFromDefault;
                  }
                  paramsResult = utils.normalizeDynamicRouteParams(routeParams, true);
                  if (paramsResult.hasValidParams) {
                    params = paramsResult.params;
                  }
                }
                if (utils.defaultRouteMatches && normalizedUrlPath === srcPathname && !paramsResult.hasValidParams && !utils.normalizeDynamicRouteParams({
                  ...params
                }, true).hasValidParams) {
                  params = utils.defaultRouteMatches;
                  (0, _requestmeta.addRequestMeta)(req, "didSetDefaultRouteMatches", true);
                }
                if (params) {
                  matchedPath = utils.interpolateDynamicPath(srcPathname, params);
                  req.url = utils.interpolateDynamicPath(req.url, params);
                }
              }
              if (pageIsDynamic || didRewrite) {
                var _utils_defaultRouteRegex;
                utils.normalizeVercelUrl(req, true, [
                  ...rewriteParamKeys,
                  ...Object.keys(((_utils_defaultRouteRegex = utils.defaultRouteRegex) == null ? void 0 : _utils_defaultRouteRegex.groups) || {})
                ]);
              }
              for (const key of routeParamKeys) {
                delete parsedUrl.query[key];
              }
              parsedUrl.pathname = matchedPath;
              url.pathname = parsedUrl.pathname;
              finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl);
              if (finished)
                return;
            } catch (err) {
              if (err instanceof _utils.DecodeError || err instanceof _utils.NormalizeError) {
                res.statusCode = 400;
                return this.renderError(null, req, res, "/_error", {});
              }
              throw err;
            }
          }
          (0, _requestmeta.addRequestMeta)(req, "isLocaleDomain", Boolean(domainLocale));
          if (pathnameInfo.locale) {
            req.url = (0, _url.format)(url);
            (0, _requestmeta.addRequestMeta)(req, "didStripLocale", true);
          }
          if (!this.minimalMode || !parsedUrl.query.__nextLocale) {
            if (pathnameInfo.locale) {
              parsedUrl.query.__nextLocale = pathnameInfo.locale;
            } else if (defaultLocale) {
              parsedUrl.query.__nextLocale = defaultLocale;
              parsedUrl.query.__nextInferredLocaleFromDefault = "1";
            }
          }
          if (!this.serverOptions.webServerConfig && !(0, _requestmeta.getRequestMeta)(req, "incrementalCache")) {
            let protocol = "https:";
            try {
              const parsedFullUrl = new URL((0, _requestmeta.getRequestMeta)(req, "initURL") || "/", "http://n");
              protocol = parsedFullUrl.protocol;
            } catch {
            }
            const incrementalCache = await this.getIncrementalCache({
              requestHeaders: Object.assign({}, req.headers),
              requestProtocol: protocol.substring(0, protocol.length - 1)
            });
            const _globalThis = globalThis;
            if (_globalThis.__nextCacheHandlers) {
              var _req_headers_NEXT_CACHE_REVALIDATED_TAGS_HEADER;
              const expiredTags = ((_req_headers_NEXT_CACHE_REVALIDATED_TAGS_HEADER = req.headers[_constants2.NEXT_CACHE_REVALIDATED_TAGS_HEADER]) == null ? void 0 : _req_headers_NEXT_CACHE_REVALIDATED_TAGS_HEADER.split(",")) || [];
              for (const handler of Object.values(_globalThis.__nextCacheHandlers)) {
                if (typeof handler.receiveExpiredTags === "function") {
                  await handler.receiveExpiredTags(...expiredTags);
                }
              }
            }
            incrementalCache.resetRequestCache();
            (0, _requestmeta.addRequestMeta)(req, "incrementalCache", incrementalCache);
            globalThis.__incrementalCache = incrementalCache;
          }
          if (!(0, _requestmeta.getRequestMeta)(req, "serverComponentsHmrCache")) {
            (0, _requestmeta.addRequestMeta)(req, "serverComponentsHmrCache", this.getServerComponentsHmrCache());
          }
          const invokePath = (0, _requestmeta.getRequestMeta)(req, "invokePath");
          const useInvokePath = !useMatchedPathHeader && true && invokePath;
          if (useInvokePath) {
            var _this_nextConfig_i18n1;
            const invokeStatus = (0, _requestmeta.getRequestMeta)(req, "invokeStatus");
            if (invokeStatus) {
              const invokeQuery2 = (0, _requestmeta.getRequestMeta)(req, "invokeQuery");
              if (invokeQuery2) {
                Object.assign(parsedUrl.query, invokeQuery2);
              }
              res.statusCode = invokeStatus;
              let err = (0, _requestmeta.getRequestMeta)(req, "invokeError") || null;
              return this.renderError(err, req, res, "/_error", parsedUrl.query);
            }
            const parsedMatchedPath = new URL(invokePath || "/", "http://n");
            const invokePathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedMatchedPath.pathname, {
              nextConfig: this.nextConfig,
              parseData: false
            });
            if (invokePathnameInfo.locale) {
              parsedUrl.query.__nextLocale = invokePathnameInfo.locale;
            }
            if (parsedUrl.pathname !== parsedMatchedPath.pathname) {
              parsedUrl.pathname = parsedMatchedPath.pathname;
              (0, _requestmeta.addRequestMeta)(req, "rewroteURL", invokePathnameInfo.pathname);
            }
            const normalizeResult = (0, _normalizelocalepath.normalizeLocalePath)((0, _removepathprefix.removePathPrefix)(parsedUrl.pathname, this.nextConfig.basePath || ""), ((_this_nextConfig_i18n1 = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n1.locales) || []);
            if (normalizeResult.detectedLocale) {
              parsedUrl.query.__nextLocale = normalizeResult.detectedLocale;
            }
            parsedUrl.pathname = normalizeResult.pathname;
            for (const key of Object.keys(parsedUrl.query)) {
              if (!key.startsWith("__next") && !key.startsWith("_next")) {
                delete parsedUrl.query[key];
              }
            }
            const invokeQuery = (0, _requestmeta.getRequestMeta)(req, "invokeQuery");
            if (invokeQuery) {
              Object.assign(parsedUrl.query, invokeQuery);
            }
            finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl);
            if (finished)
              return;
            await this.handleCatchallRenderRequest(req, res, parsedUrl);
            return;
          }
          if ((0, _requestmeta.getRequestMeta)(req, "middlewareInvoke")) {
            finished = await this.normalizeAndAttachMetadata(req, res, parsedUrl);
            if (finished)
              return;
            finished = await this.handleCatchallMiddlewareRequest(req, res, parsedUrl);
            if (finished)
              return;
            const err = new Error();
            err.result = {
              response: new Response(null, {
                headers: {
                  "x-middleware-next": "1"
                }
              })
            };
            err.bubble = true;
            throw err;
          }
          if (!useMatchedPathHeader && pathnameInfo.basePath) {
            parsedUrl.pathname = (0, _removepathprefix.removePathPrefix)(parsedUrl.pathname, pathnameInfo.basePath);
          }
          res.statusCode = 200;
          return await this.run(req, res, parsedUrl);
        } catch (err) {
          if (err instanceof NoFallbackError) {
            throw err;
          }
          if (err && typeof err === "object" && err.code === "ERR_INVALID_URL" || err instanceof _utils.DecodeError || err instanceof _utils.NormalizeError) {
            res.statusCode = 400;
            return this.renderError(null, req, res, "/_error", {});
          }
          if (this.minimalMode || this.renderOpts.dev || (0, _tracer.isBubbledError)(err) && err.bubble) {
            throw err;
          }
          this.logError((0, _iserror.getProperError)(err));
          res.statusCode = 500;
          res.body("Internal Server Error").send();
        }
      }
      /**
      * @internal - this method is internal to Next.js and should not be used directly by end-users
      */
      getRequestHandlerWithMetadata(meta) {
        const handler = this.getRequestHandler();
        return (req, res, parsedUrl) => {
          (0, _requestmeta.setRequestMeta)(req, meta);
          return handler(req, res, parsedUrl);
        };
      }
      getRequestHandler() {
        return this.handleRequest.bind(this);
      }
      setAssetPrefix(prefix) {
        this.renderOpts.assetPrefix = prefix ? prefix.replace(/\/$/, "") : "";
      }
      /**
      * Runs async initialization of server.
      * It is idempotent, won't fire underlying initialization more than once.
      */
      async prepare() {
        if (this.prepared)
          return;
        if (this.preparedPromise === null) {
          this.instrumentation = await this.loadInstrumentationModule();
          this.preparedPromise = this.prepareImpl().then(() => {
            this.prepared = true;
            this.preparedPromise = null;
          });
        }
        return this.preparedPromise;
      }
      async prepareImpl() {
      }
      async loadInstrumentationModule() {
      }
      // Backwards compatibility
      async close() {
      }
      getAppPathRoutes() {
        const appPathRoutes = {};
        Object.keys(this.appPathsManifest || {}).forEach((entry) => {
          const normalizedPath = (0, _apppaths.normalizeAppPath)(entry);
          if (!appPathRoutes[normalizedPath]) {
            appPathRoutes[normalizedPath] = [];
          }
          appPathRoutes[normalizedPath].push(entry);
        });
        return appPathRoutes;
      }
      async run(req, res, parsedUrl) {
        return (0, _tracer.getTracer)().trace(_constants1.BaseServerSpan.run, async () => this.runImpl(req, res, parsedUrl));
      }
      async runImpl(req, res, parsedUrl) {
        await this.handleCatchallRenderRequest(req, res, parsedUrl);
      }
      async pipe(fn, partialContext) {
        return (0, _tracer.getTracer)().trace(_constants1.BaseServerSpan.pipe, async () => this.pipeImpl(fn, partialContext));
      }
      async pipeImpl(fn, partialContext) {
        const isBotRequest = (0, _isbot.isBot)(partialContext.req.headers["user-agent"] || "");
        const ctx = {
          ...partialContext,
          renderOpts: {
            ...this.renderOpts,
            supportsDynamicResponse: !isBotRequest,
            isBot: !!isBotRequest
          }
        };
        const payload = await fn(ctx);
        if (payload === null) {
          return;
        }
        const { req, res } = ctx;
        const originalStatus = res.statusCode;
        const { body, type } = payload;
        let { revalidate } = payload;
        if (!res.sent) {
          const { generateEtags, poweredByHeader, dev } = this.renderOpts;
          if (dev) {
            res.setHeader("Cache-Control", "no-store, must-revalidate");
            revalidate = void 0;
          }
          await this.sendRenderResult(req, res, {
            result: body,
            type,
            generateEtags,
            poweredByHeader,
            revalidate,
            expireTime: this.nextConfig.expireTime
          });
          res.statusCode = originalStatus;
        }
      }
      async getStaticHTML(fn, partialContext) {
        const ctx = {
          ...partialContext,
          renderOpts: {
            ...this.renderOpts,
            supportsDynamicResponse: false
          }
        };
        const payload = await fn(ctx);
        if (payload === null) {
          return null;
        }
        return payload.body.toUnchunkedString();
      }
      async render(req, res, pathname, query = {}, parsedUrl, internalRender = false) {
        return (0, _tracer.getTracer)().trace(_constants1.BaseServerSpan.render, async () => this.renderImpl(req, res, pathname, query, parsedUrl, internalRender));
      }
      getWaitUntil() {
        const builtinRequestContext = (0, _builtinrequestcontext.getBuiltinRequestContext)();
        if (builtinRequestContext) {
          return builtinRequestContext.waitUntil;
        }
        if (this.minimalMode) {
          return void 0;
        }
        return Server.noopWaitUntil;
      }
      static noopWaitUntil(promise) {
        promise.catch((err) => {
          console.error(err);
        });
      }
      async renderImpl(req, res, pathname, query = {}, parsedUrl, internalRender = false) {
        var _req_url;
        if (!pathname.startsWith("/")) {
          console.warn(`Cannot render page with path "${pathname}", did you mean "/${pathname}"?. See more info here: https://nextjs.org/docs/messages/render-no-starting-slash`);
        }
        if (this.renderOpts.customServer && pathname === "/index" && !await this.hasPage("/index")) {
          pathname = "/";
        }
        if (!internalRender && !this.minimalMode && !query.__nextDataReq && (((_req_url = req.url) == null ? void 0 : _req_url.match(/^\/_next\//)) || this.hasStaticDir && req.url.match(/^\/static\//))) {
          return this.handleRequest(req, res, parsedUrl);
        }
        if ((0, _utils2.isBlockedPage)(pathname)) {
          return this.render404(req, res, parsedUrl);
        }
        return this.pipe((ctx) => this.renderToResponse(ctx), {
          req,
          res,
          pathname,
          query
        });
      }
      async getStaticPaths({ pathname }) {
        var _this_getPrerenderManifest_dynamicRoutes_pathname;
        const fallbackField = (_this_getPrerenderManifest_dynamicRoutes_pathname = this.getPrerenderManifest().dynamicRoutes[pathname]) == null ? void 0 : _this_getPrerenderManifest_dynamicRoutes_pathname.fallback;
        return {
          // `staticPaths` is intentionally set to `undefined` as it should've
          // been caught when checking disk data.
          staticPaths: void 0,
          fallbackMode: (0, _fallback.parseFallbackField)(fallbackField)
        };
      }
      async renderToResponseWithComponents(requestContext, findComponentsResult) {
        return (0, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderToResponseWithComponents, async () => this.renderToResponseWithComponentsImpl(requestContext, findComponentsResult));
      }
      pathCouldBeIntercepted(resolvedPathname) {
        return (0, _interceptionroutes.isInterceptionRouteAppPath)(resolvedPathname) || this.interceptionRoutePatterns.some((regexp) => {
          return regexp.test(resolvedPathname);
        });
      }
      setVaryHeader(req, res, isAppPath, resolvedPathname) {
        const baseVaryHeader = `${_approuterheaders.RSC_HEADER}, ${_approuterheaders.NEXT_ROUTER_STATE_TREE_HEADER}, ${_approuterheaders.NEXT_ROUTER_PREFETCH_HEADER}, ${_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER}`;
        const isRSCRequest = (0, _requestmeta.getRequestMeta)(req, "isRSCRequest") ?? false;
        let addedNextUrlToVary = false;
        if (isAppPath && this.pathCouldBeIntercepted(resolvedPathname)) {
          res.setHeader("vary", `${baseVaryHeader}, ${_approuterheaders.NEXT_URL}`);
          addedNextUrlToVary = true;
        } else if (isAppPath || isRSCRequest) {
          res.setHeader("vary", baseVaryHeader);
        }
        if (!addedNextUrlToVary) {
          delete req.headers[_approuterheaders.NEXT_URL];
        }
      }
      async renderToResponseWithComponentsImpl({ req, res, pathname, renderOpts: opts }, { components, query }) {
        var _components_Component, _this, _this_nextConfig_i18n, _this_nextConfig_i18n1, _cacheEntry_value, _cacheEntry_value1;
        if (pathname === _constants.UNDERSCORE_NOT_FOUND_ROUTE) {
          pathname = "/404";
        }
        const is404Page = pathname === "/404";
        const is500Page = pathname === "/500";
        const isAppPath = components.isAppPath === true;
        const hasServerProps = !!components.getServerSideProps;
        let hasGetStaticPaths = !!components.getStaticPaths;
        const isServerAction = (0, _serveractionrequestmeta.getIsServerAction)(req);
        const hasGetInitialProps = !!((_components_Component = components.Component) == null ? void 0 : _components_Component.getInitialProps);
        let isSSG = !!components.getStaticProps;
        let urlPathname = (0, _url.parse)(req.url || "").pathname || "/";
        let resolvedUrlPathname = (0, _requestmeta.getRequestMeta)(req, "rewroteURL") || urlPathname;
        this.setVaryHeader(req, res, isAppPath, resolvedUrlPathname);
        let staticPaths;
        let fallbackMode;
        let hasFallback = false;
        const isDynamic = (0, _utils1.isDynamicRoute)(components.page);
        const prerenderManifest = this.getPrerenderManifest();
        if (isAppPath && isDynamic) {
          const pathsResult = await this.getStaticPaths({
            pathname,
            page: components.page,
            isAppPath,
            requestHeaders: req.headers
          });
          staticPaths = pathsResult.staticPaths;
          fallbackMode = pathsResult.fallbackMode;
          hasFallback = typeof fallbackMode !== "undefined";
          if (this.nextConfig.output === "export") {
            const page = components.page;
            if (!staticPaths) {
              throw new Error(`Page "${page}" is missing exported function "generateStaticParams()", which is required with "output: export" config.`);
            }
            const resolvedWithoutSlash = (0, _removetrailingslash.removeTrailingSlash)(resolvedUrlPathname);
            if (!staticPaths.includes(resolvedWithoutSlash)) {
              throw new Error(`Page "${page}" is missing param "${resolvedWithoutSlash}" in "generateStaticParams()", which is required with "output: export" config.`);
            }
          }
          if (hasFallback) {
            hasGetStaticPaths = true;
          }
        }
        if (hasFallback || (staticPaths == null ? void 0 : staticPaths.includes(resolvedUrlPathname)) || // this signals revalidation in deploy environments
        // TODO: make this more generic
        req.headers["x-now-route-matches"]) {
          isSSG = true;
        } else if (!this.renderOpts.dev) {
          isSSG ||= !!prerenderManifest.routes[(0, _toroute.toRoute)(pathname)];
        }
        const isNextDataRequest = !!(query.__nextDataReq || req.headers["x-nextjs-data"] && this.serverOptions.webServerConfig) && (isSSG || hasServerProps);
        const isPrefetchRSCRequest = (0, _requestmeta.getRequestMeta)(req, "isPrefetchRSCRequest") ?? false;
        const isRSCRequest = (0, _requestmeta.getRequestMeta)(req, "isRSCRequest") ?? false;
        if (!isSSG && req.headers["x-middleware-prefetch"] && !(is404Page || pathname === "/_error")) {
          res.setHeader("x-matched-path", pathname);
          res.setHeader("x-middleware-skip", "1");
          res.setHeader("cache-control", "private, no-cache, no-store, max-age=0, must-revalidate");
          res.body("{}").send();
          return null;
        }
        delete query.__nextDataReq;
        if (isSSG && this.minimalMode && req.headers["x-matched-path"] && req.url.startsWith("/_next/data")) {
          req.url = this.stripNextDataPath(req.url);
        }
        if (!!req.headers["x-nextjs-data"] && (!res.statusCode || res.statusCode === 200)) {
          res.setHeader("x-nextjs-matched-path", `${query.__nextLocale ? `/${query.__nextLocale}` : ""}${pathname}`);
        }
        let routeModule;
        if (components.routeModule) {
          routeModule = components.routeModule;
        }
        const couldSupportPPR = this.isAppPPREnabled && typeof routeModule !== "undefined" && (0, _checks.isAppPageRouteModule)(routeModule);
        const hasDebugStaticShellQuery = process.env.__NEXT_EXPERIMENTAL_STATIC_SHELL_DEBUGGING === "1" && typeof query.__nextppronly !== "undefined" && couldSupportPPR;
        const hasDebugFallbackShellQuery = hasDebugStaticShellQuery && query.__nextppronly === "fallback";
        const isRoutePPREnabled = couldSupportPPR && (((_this = prerenderManifest.routes[pathname] ?? prerenderManifest.dynamicRoutes[pathname]) == null ? void 0 : _this.renderingMode) === "PARTIALLY_STATIC" || // Ideally we'd want to check the appConfig to see if this page has PPR
        // enabled or not, but that would require plumbing the appConfig through
        // to the server during development. We assume that the page supports it
        // but only during development.
        hasDebugStaticShellQuery && (this.renderOpts.dev === true || this.experimentalTestProxy === true));
        const isDebugStaticShell = hasDebugStaticShellQuery && isRoutePPREnabled;
        const isDebugDynamicAccesses = isDebugStaticShell && this.renderOpts.dev === true;
        const isDebugFallbackShell = hasDebugFallbackShellQuery && isRoutePPREnabled;
        const minimalPostponed = isRoutePPREnabled ? (0, _requestmeta.getRequestMeta)(req, "postponed") : void 0;
        const isDynamicRSCRequest = isRoutePPREnabled && isRSCRequest && !isPrefetchRSCRequest;
        const segmentPrefetchHeader = req.headers[_approuterheaders.NEXT_ROUTER_SEGMENT_PREFETCH_HEADER.toLowerCase()];
        if (is404Page && !isNextDataRequest && !isRSCRequest) {
          res.statusCode = 404;
        }
        if (_constants.STATIC_STATUS_PAGES.includes(pathname)) {
          res.statusCode = parseInt(pathname.slice(1), 10);
        }
        if (
          // Server actions can use non-GET/HEAD methods.
          !isServerAction && // Resume can use non-GET/HEAD methods.
          !minimalPostponed && !is404Page && !is500Page && pathname !== "/_error" && req.method !== "HEAD" && req.method !== "GET" && (typeof components.Component === "string" || isSSG)
        ) {
          res.statusCode = 405;
          res.setHeader("Allow", [
            "GET",
            "HEAD"
          ]);
          await this.renderError(null, req, res, pathname);
          return null;
        }
        if (typeof components.Component === "string") {
          return {
            type: "html",
            // TODO: Static pages should be serialized as RenderResult
            body: _renderresult.default.fromStatic(components.Component)
          };
        }
        if ("amp" in query && !query.amp)
          delete query.amp;
        if (opts.supportsDynamicResponse === true) {
          var _components_Document;
          const isBotRequest = (0, _isbot.isBot)(req.headers["user-agent"] || "");
          const isSupportedDocument = typeof ((_components_Document = components.Document) == null ? void 0 : _components_Document.getInitialProps) !== "function" || // The built-in `Document` component also supports dynamic HTML for concurrent mode.
          _constants.NEXT_BUILTIN_DOCUMENT in components.Document;
          opts.supportsDynamicResponse = !isSSG && !isBotRequest && !query.amp && isSupportedDocument;
          opts.isBot = isBotRequest;
        }
        if (!isNextDataRequest && isAppPath && opts.dev) {
          opts.supportsDynamicResponse = true;
        }
        const defaultLocale = isSSG ? (_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.defaultLocale : query.__nextDefaultLocale;
        const locale = query.__nextLocale;
        const locales = (_this_nextConfig_i18n1 = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n1.locales;
        let previewData;
        let isPreviewMode = false;
        if (hasServerProps || isSSG || isAppPath) {
          if (true) {
            const { tryGetPreviewData } = require_try_get_preview_data();
            previewData = tryGetPreviewData(req, res, this.renderOpts.previewProps, !!this.nextConfig.experimental.multiZoneDraftMode);
            isPreviewMode = previewData !== false;
          }
        }
        if (isAppPath && !opts.dev && !isPreviewMode && isSSG && isRSCRequest && !isDynamicRSCRequest && (!(0, _isedgeruntime.isEdgeRuntime)(opts.runtime) || this.serverOptions.webServerConfig)) {
          (0, _stripflightheaders.stripFlightHeaders)(req.headers);
        }
        let isOnDemandRevalidate = false;
        let revalidateOnlyGenerated = false;
        if (isSSG) {
          ({ isOnDemandRevalidate, revalidateOnlyGenerated } = (0, _apiutils.checkIsOnDemandRevalidate)(req, this.renderOpts.previewProps));
        }
        if (isSSG && this.minimalMode && req.headers["x-matched-path"]) {
          resolvedUrlPathname = urlPathname;
        }
        urlPathname = (0, _removetrailingslash.removeTrailingSlash)(urlPathname);
        resolvedUrlPathname = (0, _removetrailingslash.removeTrailingSlash)(resolvedUrlPathname);
        if (this.localeNormalizer) {
          resolvedUrlPathname = this.localeNormalizer.normalize(resolvedUrlPathname);
        }
        const handleRedirect = (pageData) => {
          const redirect = {
            destination: pageData.pageProps.__N_REDIRECT,
            statusCode: pageData.pageProps.__N_REDIRECT_STATUS,
            basePath: pageData.pageProps.__N_REDIRECT_BASE_PATH
          };
          const statusCode = (0, _redirectstatus.getRedirectStatus)(redirect);
          const { basePath } = this.nextConfig;
          if (basePath && redirect.basePath !== false && redirect.destination.startsWith("/")) {
            redirect.destination = `${basePath}${redirect.destination}`;
          }
          if (redirect.destination.startsWith("/")) {
            redirect.destination = (0, _utils.normalizeRepeatedSlashes)(redirect.destination);
          }
          res.redirect(redirect.destination, statusCode).body(redirect.destination).send();
        };
        if (isNextDataRequest) {
          resolvedUrlPathname = this.stripNextDataPath(resolvedUrlPathname);
          urlPathname = this.stripNextDataPath(urlPathname);
        }
        let ssgCacheKey = null;
        if (!isPreviewMode && isSSG && !opts.supportsDynamicResponse && !isServerAction && !minimalPostponed && !isDynamicRSCRequest) {
          ssgCacheKey = `${locale ? `/${locale}` : ""}${(pathname === "/" || resolvedUrlPathname === "/") && locale ? "" : resolvedUrlPathname}${query.amp ? ".amp" : ""}`;
        }
        if ((is404Page || is500Page) && isSSG) {
          ssgCacheKey = `${locale ? `/${locale}` : ""}${pathname}${query.amp ? ".amp" : ""}`;
        }
        if (ssgCacheKey) {
          ssgCacheKey = ssgCacheKey.split("/").map((seg) => {
            try {
              seg = (0, _escapepathdelimiters.default)(decodeURIComponent(seg), true);
            } catch (_) {
              throw new _utils.DecodeError("failed to decode param");
            }
            return seg;
          }).join("/");
          ssgCacheKey = ssgCacheKey === "/index" && pathname === "/" ? "/" : ssgCacheKey;
        }
        let protocol = "https:";
        try {
          const parsedFullUrl = new URL((0, _requestmeta.getRequestMeta)(req, "initURL") || "/", "http://n");
          protocol = parsedFullUrl.protocol;
        } catch {
        }
        const incrementalCache = globalThis.__incrementalCache || await this.getIncrementalCache({
          requestHeaders: Object.assign({}, req.headers),
          requestProtocol: protocol.substring(0, protocol.length - 1)
        });
        incrementalCache.resetRequestCache();
        const doRender = async ({ postponed, fallbackRouteParams, isDevWarmup }) => {
          let supportsDynamicResponse = (
            // If we're in development, we always support dynamic HTML, unless it's
            // a data request, in which case we only produce static HTML.
            !isNextDataRequest && opts.dev === true || // If this is not SSG or does not have static paths, then it supports
            // dynamic HTML.
            !isSSG && !hasGetStaticPaths || // If this request has provided postponed data, it supports dynamic
            // HTML.
            typeof postponed === "string" || // If this is a dynamic RSC request, then this render supports dynamic
            // HTML (it's dynamic).
            isDynamicRSCRequest
          );
          const origQuery = (0, _url.parse)(req.url || "", true).query;
          if (opts.params) {
            Object.keys(opts.params).forEach((key) => {
              delete origQuery[key];
            });
          }
          const hadTrailingSlash = urlPathname !== "/" && this.nextConfig.trailingSlash;
          const resolvedUrl = (0, _url.format)({
            pathname: `${resolvedUrlPathname}${hadTrailingSlash ? "/" : ""}`,
            // make sure to only add query values from original URL
            query: origQuery
          });
          const renderOpts = {
            ...components,
            ...opts,
            ...isAppPath ? {
              incrementalCache,
              // This is a revalidation request if the request is for a static
              // page and it is not being resumed from a postponed render and
              // it is not a dynamic RSC request then it is a revalidation
              // request.
              isRevalidate: isSSG && !postponed && !isDynamicRSCRequest,
              serverActions: this.nextConfig.experimental.serverActions
            } : {},
            isNextDataRequest,
            resolvedUrl,
            locale,
            locales,
            defaultLocale,
            multiZoneDraftMode: this.nextConfig.experimental.multiZoneDraftMode,
            // For getServerSideProps and getInitialProps we need to ensure we use the original URL
            // and not the resolved URL to prevent a hydration mismatch on
            // asPath
            resolvedAsPath: hasServerProps || hasGetInitialProps ? (0, _url.format)({
              // we use the original URL pathname less the _next/data prefix if
              // present
              pathname: `${urlPathname}${hadTrailingSlash ? "/" : ""}`,
              query: origQuery
            }) : resolvedUrl,
            experimental: {
              ...opts.experimental,
              isRoutePPREnabled
            },
            supportsDynamicResponse,
            isOnDemandRevalidate,
            isDraftMode: isPreviewMode,
            isServerAction,
            isDevWarmup,
            postponed,
            waitUntil: this.getWaitUntil(),
            onClose: res.onClose.bind(res),
            onAfterTaskError: void 0,
            // only available in dev
            setAppIsrStatus: this.setAppIsrStatus
          };
          if (isDebugStaticShell || isDebugDynamicAccesses) {
            supportsDynamicResponse = false;
            renderOpts.nextExport = true;
            renderOpts.supportsDynamicResponse = false;
            renderOpts.isStaticGeneration = true;
            renderOpts.isRevalidate = true;
            renderOpts.isDebugStaticShell = isDebugStaticShell;
            renderOpts.isDebugDynamicAccesses = isDebugDynamicAccesses;
          }
          let result;
          if (routeModule) {
            if ((0, _checks.isAppRouteRouteModule)(routeModule)) {
              var _this_nextConfig_experimental;
              if (
                // The type check here ensures that `req` is correctly typed, and the
                // environment variable check provides dead code elimination.
                !(0, _helpers.isNodeNextRequest)(req) || !(0, _helpers.isNodeNextResponse)(res)
              ) {
                throw new Error("Invariant: App Route Route Modules cannot be used in the edge runtime");
              }
              const context = {
                params: opts.params,
                prerenderManifest,
                renderOpts: {
                  experimental: {
                    after: renderOpts.experimental.after,
                    dynamicIO: renderOpts.experimental.dynamicIO
                  },
                  supportsDynamicResponse,
                  incrementalCache,
                  cacheLifeProfiles: (_this_nextConfig_experimental = this.nextConfig.experimental) == null ? void 0 : _this_nextConfig_experimental.cacheLife,
                  isRevalidate: isSSG,
                  waitUntil: this.getWaitUntil(),
                  onClose: res.onClose.bind(res),
                  onAfterTaskError: void 0,
                  onInstrumentationRequestError: this.renderOpts.onInstrumentationRequestError,
                  buildId: this.renderOpts.buildId
                }
              };
              try {
                const request = _nextrequest.NextRequestAdapter.fromNodeNextRequest(req, (0, _nextrequest.signalFromNodeResponse)(res.originalResponse));
                const response = await routeModule.handle(request, context);
                req.fetchMetrics = context.renderOpts.fetchMetrics;
                const cacheTags2 = context.renderOpts.collectedTags;
                if (isSSG) {
                  const blob = await response.blob();
                  const headers2 = (0, _utils3.toNodeOutgoingHttpHeaders)(response.headers);
                  if (cacheTags2) {
                    headers2[_constants2.NEXT_CACHE_TAGS_HEADER] = cacheTags2;
                  }
                  if (!headers2["content-type"] && blob.type) {
                    headers2["content-type"] = blob.type;
                  }
                  const revalidate2 = typeof context.renderOpts.collectedRevalidate === "undefined" || context.renderOpts.collectedRevalidate >= _constants2.INFINITE_CACHE ? false : context.renderOpts.collectedRevalidate;
                  const cacheEntry2 = {
                    value: {
                      kind: _responsecache.CachedRouteKind.APP_ROUTE,
                      status: response.status,
                      body: Buffer.from(await blob.arrayBuffer()),
                      headers: headers2
                    },
                    revalidate: revalidate2,
                    isFallback: false
                  };
                  return cacheEntry2;
                }
                await (0, _sendresponse.sendResponse)(req, res, response, context.renderOpts.pendingWaitUntil);
                return null;
              } catch (err) {
                await this.instrumentationOnRequestError(err, req, {
                  routerKind: "App Router",
                  routePath: pathname,
                  routeType: "route",
                  revalidateReason: (0, _utils4.getRevalidateReason)(renderOpts)
                });
                if (isSSG)
                  throw err;
                _log.error(err);
                await (0, _sendresponse.sendResponse)(req, res, new Response(null, {
                  status: 500
                }));
                return null;
              }
            } else if ((0, _checks.isPagesRouteModule)(routeModule) || (0, _checks.isAppPageRouteModule)(routeModule)) {
              if (req.method === "OPTIONS" && !is404Page) {
                await (0, _sendresponse.sendResponse)(req, res, new Response(null, {
                  status: 400
                }));
                return null;
              }
              if ((0, _checks.isPagesRouteModule)(routeModule)) {
                renderOpts.nextFontManifest = this.nextFontManifest;
                renderOpts.clientReferenceManifest = components.clientReferenceManifest;
                const request = (0, _helpers.isNodeNextRequest)(req) ? req.originalRequest : req;
                const response = (0, _helpers.isNodeNextResponse)(res) ? res.originalResponse : res;
                try {
                  result = await routeModule.render(
                    // TODO: fix this type
                    // @ts-expect-error - preexisting accepted this
                    request,
                    response,
                    {
                      page: pathname,
                      params: opts.params,
                      query,
                      renderOpts
                    }
                  );
                } catch (err) {
                  await this.instrumentationOnRequestError(err, req, {
                    routerKind: "Pages Router",
                    routePath: pathname,
                    routeType: "render",
                    revalidateReason: (0, _utils4.getRevalidateReason)({
                      isRevalidate: isSSG,
                      isOnDemandRevalidate: renderOpts.isOnDemandRevalidate
                    })
                  });
                  throw err;
                }
              } else {
                const module1 = components.routeModule;
                renderOpts.nextFontManifest = this.nextFontManifest;
                result = await module1.render(req, res, {
                  page: is404Page ? "/404" : pathname,
                  params: opts.params,
                  query,
                  fallbackRouteParams,
                  renderOpts,
                  serverComponentsHmrCache: this.getServerComponentsHmrCache()
                });
              }
            } else {
              throw new Error("Invariant: Unknown route module type");
            }
          } else {
            result = await this.renderHTML(req, res, pathname, query, renderOpts);
          }
          const { metadata } = result;
          const {
            headers = {},
            // Add any fetch tags that were on the page to the response headers.
            fetchTags: cacheTags
          } = metadata;
          if (cacheTags) {
            headers[_constants2.NEXT_CACHE_TAGS_HEADER] = cacheTags;
          }
          req.fetchMetrics = metadata.fetchMetrics;
          if (isAppPath && isSSG && metadata.revalidate === 0 && !this.renderOpts.dev && !isRoutePPREnabled) {
            const staticBailoutInfo = metadata.staticBailoutInfo;
            const err = new Error(`Page changed from static to dynamic at runtime ${urlPathname}${(staticBailoutInfo == null ? void 0 : staticBailoutInfo.description) ? `, reason: ${staticBailoutInfo.description}` : ``}
see more here https://nextjs.org/docs/messages/app-static-to-dynamic-error`);
            if (staticBailoutInfo == null ? void 0 : staticBailoutInfo.stack) {
              const stack = staticBailoutInfo.stack;
              err.stack = err.message + stack.substring(stack.indexOf("\n"));
            }
            throw err;
          }
          if ("isNotFound" in metadata && metadata.isNotFound) {
            return {
              value: null,
              revalidate: metadata.revalidate,
              isFallback: false
            };
          }
          if (metadata.isRedirect) {
            return {
              value: {
                kind: _responsecache.CachedRouteKind.REDIRECT,
                props: metadata.pageData ?? metadata.flightData
              },
              revalidate: metadata.revalidate,
              isFallback: false
            };
          }
          if (result.isNull) {
            return null;
          }
          if (isAppPath) {
            return {
              value: {
                kind: _responsecache.CachedRouteKind.APP_PAGE,
                html: result,
                headers,
                rscData: metadata.flightData,
                postponed: metadata.postponed,
                status: res.statusCode,
                segmentData: void 0
              },
              revalidate: metadata.revalidate,
              isFallback: !!fallbackRouteParams
            };
          }
          return {
            value: {
              kind: _responsecache.CachedRouteKind.PAGES,
              html: result,
              pageData: metadata.pageData ?? metadata.flightData,
              headers,
              status: isAppPath ? res.statusCode : void 0
            },
            revalidate: metadata.revalidate,
            isFallback: query.__nextFallback === "true"
          };
        };
        let responseGenerator = async ({ hasResolved, previousCacheEntry, isRevalidating, isDevWarmup }) => {
          const isProduction = !this.renderOpts.dev;
          const didRespond = hasResolved || res.sent;
          if (!staticPaths && isDynamic) {
            if (hasGetStaticPaths) {
              const pathsResult = await this.getStaticPaths({
                pathname,
                requestHeaders: req.headers,
                isAppPath,
                page: components.page
              });
              staticPaths = pathsResult.staticPaths;
              fallbackMode = pathsResult.fallbackMode;
            } else {
              staticPaths = void 0;
              fallbackMode = _fallback.FallbackMode.NOT_FOUND;
            }
          }
          if (fallbackMode === _fallback.FallbackMode.PRERENDER && (0, _isbot.isBot)(req.headers["user-agent"] || "")) {
            fallbackMode = _fallback.FallbackMode.BLOCKING_STATIC_RENDER;
          }
          if (isOnDemandRevalidate && revalidateOnlyGenerated && !previousCacheEntry && !this.minimalMode) {
            await this.render404(req, res);
            return null;
          }
          if ((previousCacheEntry == null ? void 0 : previousCacheEntry.isStale) === -1) {
            isOnDemandRevalidate = true;
          }
          if (isOnDemandRevalidate && (fallbackMode !== _fallback.FallbackMode.NOT_FOUND || previousCacheEntry)) {
            fallbackMode = _fallback.FallbackMode.BLOCKING_STATIC_RENDER;
          }
          let staticPathKey = ssgCacheKey ?? (opts.dev && isAppPath ? resolvedUrlPathname : null);
          if (staticPathKey && query.amp) {
            staticPathKey = staticPathKey.replace(/\.amp$/, "");
          }
          const isPageIncludedInStaticPaths = staticPathKey && (staticPaths == null ? void 0 : staticPaths.includes(staticPathKey));
          if (this.nextConfig.experimental.isExperimentalCompile) {
            fallbackMode = _fallback.FallbackMode.BLOCKING_STATIC_RENDER;
          }
          if (!this.minimalMode && fallbackMode !== _fallback.FallbackMode.BLOCKING_STATIC_RENDER && staticPathKey && !didRespond && !isPreviewMode && isDynamic && (isProduction || !staticPaths || !isPageIncludedInStaticPaths)) {
            if (
              // In development, fall through to render to handle missing
              // getStaticPaths.
              (isProduction || staticPaths && (staticPaths == null ? void 0 : staticPaths.length) > 0) && // When fallback isn't present, abort this render so we 404
              fallbackMode === _fallback.FallbackMode.NOT_FOUND
            ) {
              throw new NoFallbackError();
            }
            let fallbackResponse;
            if ((0, _checks.isPagesRouteModule)(components.routeModule) && !isNextDataRequest) {
              fallbackResponse = await this.responseCache.get(
                isProduction ? locale ? `/${locale}${pathname}` : pathname : null,
                // This is the response generator for the fallback shell.
                async ({ previousCacheEntry: previousFallbackCacheEntry = null }) => {
                  if (isProduction) {
                    return (0, _utils5.toResponseCacheEntry)(previousFallbackCacheEntry);
                  }
                  query.__nextFallback = "true";
                  return doRender({
                    postponed: void 0,
                    fallbackRouteParams: null
                  });
                },
                {
                  routeKind: _routekind.RouteKind.PAGES,
                  incrementalCache,
                  isRoutePPREnabled,
                  isFallback: true
                }
              );
            } else if (isRoutePPREnabled && (0, _checks.isAppPageRouteModule)(components.routeModule) && !isRSCRequest) {
              fallbackResponse = await this.responseCache.get(
                isProduction ? pathname : null,
                // This is the response generator for the fallback shell.
                async () => doRender({
                  // We pass `undefined` as rendering a fallback isn't resumed
                  // here.
                  postponed: void 0,
                  fallbackRouteParams: (
                    // If we're in production of we're debugging the fallback
                    // shell then we should postpone when dynamic params are
                    // accessed.
                    isProduction || isDebugFallbackShell ? (0, _fallbackparams.getFallbackRouteParams)(pathname) : null
                  )
                }),
                {
                  routeKind: _routekind.RouteKind.APP_PAGE,
                  incrementalCache,
                  isRoutePPREnabled,
                  isFallback: true
                }
              );
            }
            if (fallbackResponse === null)
              return null;
            if (fallbackResponse) {
              delete fallbackResponse.revalidate;
              return fallbackResponse;
            }
          }
          const postponed = !isOnDemandRevalidate && !isRevalidating && minimalPostponed ? minimalPostponed : void 0;
          if ((isDebugStaticShell || isDebugDynamicAccesses) && typeof postponed !== "undefined") {
            return {
              revalidate: 1,
              isFallback: false,
              value: {
                kind: _responsecache.CachedRouteKind.PAGES,
                html: _renderresult.default.fromStatic(""),
                pageData: {},
                headers: void 0,
                status: void 0
              }
            };
          }
          const fallbackRouteParams = isDynamic && isRoutePPREnabled && ((0, _requestmeta.getRequestMeta)(req, "didSetDefaultRouteMatches") || isDebugFallbackShell) ? (0, _fallbackparams.getFallbackRouteParams)(pathname) : null;
          const result = await doRender({
            postponed,
            fallbackRouteParams,
            isDevWarmup
          });
          if (!result)
            return null;
          return {
            ...result,
            revalidate: result.revalidate
          };
        };
        if (this.nextConfig.experimental.dynamicIO) {
          const originalResponseGenerator = responseGenerator;
          responseGenerator = async (state) => {
            if (this.renderOpts.dev) {
              let cache = this.prefetchCacheScopesDev.get(urlPathname);
              if (!cache && !isPrefetchRSCRequest && (routeModule == null ? void 0 : routeModule.definition.kind) === _routekind.RouteKind.APP_PAGE && !isServerAction) {
                cache = /* @__PURE__ */ new Map();
                await (0, _cachescopeexternal.runWithCacheScope)({
                  cache
                }, () => originalResponseGenerator({
                  ...state,
                  isDevWarmup: true
                }));
                this.prefetchCacheScopesDev.set(urlPathname, cache);
              }
              if (cache) {
                return (0, _cachescopeexternal.runWithCacheScope)({
                  cache
                }, () => originalResponseGenerator(state)).finally(() => {
                  if (isPrefetchRSCRequest) {
                    this.prefetchCacheScopesDev.set(urlPathname, cache);
                  } else {
                    this.prefetchCacheScopesDev.del(urlPathname);
                  }
                });
              }
            }
            return originalResponseGenerator(state);
          };
        }
        const cacheEntry = await this.responseCache.get(ssgCacheKey, responseGenerator, {
          routeKind: (
            // If the route module is not defined, we can assume it's a page being
            // rendered and thus check isAppPath.
            (routeModule == null ? void 0 : routeModule.definition.kind) ?? (isAppPath ? _routekind.RouteKind.APP_PAGE : _routekind.RouteKind.PAGES)
          ),
          incrementalCache,
          isOnDemandRevalidate,
          isPrefetch: req.headers.purpose === "prefetch",
          isRoutePPREnabled
        });
        if (isRoutePPREnabled && isPrefetchRSCRequest && typeof segmentPrefetchHeader === "string") {
          var _cacheEntry_value2;
          if ((cacheEntry == null ? void 0 : (_cacheEntry_value2 = cacheEntry.value) == null ? void 0 : _cacheEntry_value2.kind) === _responsecache.CachedRouteKind.APP_PAGE) {
            if (cacheEntry.value.segmentData) {
              const matchedSegment = cacheEntry.value.segmentData[segmentPrefetchHeader];
              if (matchedSegment !== void 0) {
                return {
                  type: "rsc",
                  body: _renderresult.default.fromStatic(matchedSegment),
                  // TODO: Eventually this should use revalidate time of the
                  // individual segment, not the whole page.
                  revalidate: cacheEntry.revalidate
                };
              }
            }
            res.statusCode = 404;
            return {
              type: "rsc",
              body: _renderresult.default.fromStatic(""),
              revalidate: cacheEntry.revalidate
            };
          } else {
            res.statusCode = 404;
            return {
              type: "rsc",
              body: _renderresult.default.fromStatic("")
            };
          }
        }
        if (isPreviewMode) {
          res.setHeader("Cache-Control", "private, no-cache, no-store, max-age=0, must-revalidate");
        }
        if (!cacheEntry) {
          if (ssgCacheKey && !(isOnDemandRevalidate && revalidateOnlyGenerated)) {
            throw new Error("invariant: cache entry required but not generated");
          }
          return null;
        }
        if (ssgCacheKey && !this.minimalMode && isRoutePPREnabled && ((_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) === _responsecache.CachedRouteKind.APP_PAGE && cacheEntry.isFallback && !isOnDemandRevalidate && // When we're debugging the fallback shell, we don't want to regenerate
        // the route shell.
        !isDebugFallbackShell) {
          (0, _scheduler.scheduleOnNextTick)(async () => {
            try {
              await this.responseCache.get(ssgCacheKey, () => doRender({
                // We're an on-demand request, so we don't need to pass in the
                // fallbackRouteParams.
                fallbackRouteParams: null,
                postponed: void 0
              }), {
                routeKind: _routekind.RouteKind.APP_PAGE,
                incrementalCache,
                isOnDemandRevalidate: true,
                isPrefetch: false,
                isRoutePPREnabled: true
              });
            } catch (err) {
              console.error("Error occurred while rendering dynamic shell", err);
            }
          });
        }
        const didPostpone = ((_cacheEntry_value1 = cacheEntry.value) == null ? void 0 : _cacheEntry_value1.kind) === _responsecache.CachedRouteKind.APP_PAGE && typeof cacheEntry.value.postponed === "string";
        if (isSSG && // We don't want to send a cache header for requests that contain dynamic
        // data. If this is a Dynamic RSC request or wasn't a Prefetch RSC
        // request, then we should set the cache header.
        !isDynamicRSCRequest && (!didPostpone || isPrefetchRSCRequest)) {
          if (!this.minimalMode) {
            res.setHeader("x-nextjs-cache", isOnDemandRevalidate ? "REVALIDATED" : cacheEntry.isMiss ? "MISS" : cacheEntry.isStale ? "STALE" : "HIT");
          }
          res.setHeader(_approuterheaders.NEXT_IS_PRERENDER_HEADER, "1");
        }
        const { value: cachedData } = cacheEntry;
        if ((cachedData == null ? void 0 : cachedData.kind) === _responsecache.CachedRouteKind.IMAGE) {
          throw new Error("invariant SSG should not return an image cache value");
        }
        let revalidate;
        if (minimalPostponed) {
          revalidate = 0;
        } else if (this.minimalMode && isRSCRequest && !isPrefetchRSCRequest && isRoutePPREnabled) {
          revalidate = 0;
        } else if (!this.renderOpts.dev || hasServerProps && !isNextDataRequest) {
          if (isPreviewMode) {
            revalidate = 0;
          } else if (!isSSG) {
            if (!res.getHeader("Cache-Control")) {
              revalidate = 0;
            }
          } else if (is404Page) {
            const notFoundRevalidate = (0, _requestmeta.getRequestMeta)(req, "notFoundRevalidate");
            revalidate = typeof notFoundRevalidate === "undefined" ? 0 : notFoundRevalidate;
          } else if (typeof cacheEntry.revalidate === "number") {
            if (cacheEntry.revalidate < 1) {
              throw new Error(`Invalid revalidate configuration provided: ${cacheEntry.revalidate} < 1`);
            }
            revalidate = cacheEntry.revalidate;
          } else if (cacheEntry.revalidate === false) {
            revalidate = _constants2.CACHE_ONE_YEAR;
          }
        }
        cacheEntry.revalidate = revalidate;
        const onCacheEntry = (0, _requestmeta.getRequestMeta)(req, "onCacheEntry");
        if (onCacheEntry) {
          var _cacheEntry_value3, _cacheEntry_value4;
          const finished = await onCacheEntry({
            ...cacheEntry,
            // TODO: remove this when upstream doesn't
            // always expect this value to be "PAGE"
            value: {
              ...cacheEntry.value,
              kind: ((_cacheEntry_value3 = cacheEntry.value) == null ? void 0 : _cacheEntry_value3.kind) === _responsecache.CachedRouteKind.APP_PAGE ? "PAGE" : (_cacheEntry_value4 = cacheEntry.value) == null ? void 0 : _cacheEntry_value4.kind
            }
          }, {
            url: (0, _requestmeta.getRequestMeta)(req, "initURL")
          });
          if (finished) {
            return null;
          }
        }
        if (!cachedData) {
          (0, _requestmeta.addRequestMeta)(req, "notFoundRevalidate", cacheEntry.revalidate);
          if (cacheEntry.revalidate && !res.getHeader("Cache-Control")) {
            res.setHeader("Cache-Control", (0, _revalidate.formatRevalidate)({
              revalidate: cacheEntry.revalidate,
              expireTime: this.nextConfig.expireTime
            }));
          }
          if (isNextDataRequest) {
            res.statusCode = 404;
            res.body('{"notFound":true}').send();
            return null;
          }
          if (this.renderOpts.dev) {
            query.__nextNotFoundSrcPage = pathname;
          }
          await this.render404(req, res, {
            pathname,
            query
          }, false);
          return null;
        } else if (cachedData.kind === _responsecache.CachedRouteKind.REDIRECT) {
          if (cacheEntry.revalidate && !res.getHeader("Cache-Control")) {
            res.setHeader("Cache-Control", (0, _revalidate.formatRevalidate)({
              revalidate: cacheEntry.revalidate,
              expireTime: this.nextConfig.expireTime
            }));
          }
          if (isNextDataRequest) {
            return {
              type: "json",
              body: _renderresult.default.fromStatic(
                // @TODO: Handle flight data.
                JSON.stringify(cachedData.props)
              ),
              revalidate: cacheEntry.revalidate
            };
          } else {
            await handleRedirect(cachedData.props);
            return null;
          }
        } else if (cachedData.kind === _responsecache.CachedRouteKind.APP_ROUTE) {
          const headers = {
            ...cachedData.headers
          };
          if (!(this.minimalMode && isSSG)) {
            delete headers[_constants2.NEXT_CACHE_TAGS_HEADER];
          }
          await (0, _sendresponse.sendResponse)(req, res, new Response(cachedData.body, {
            headers: (0, _utils3.fromNodeOutgoingHttpHeaders)(headers),
            status: cachedData.status || 200
          }));
          return null;
        } else if (cachedData.kind === _responsecache.CachedRouteKind.APP_PAGE) {
          var _cachedData_headers;
          if (didPostpone && minimalPostponed) {
            throw new Error("Invariant: postponed state should not be present on a resume request");
          }
          if (cachedData.headers) {
            const headers = {
              ...cachedData.headers
            };
            if (!this.minimalMode || !isSSG) {
              delete headers[_constants2.NEXT_CACHE_TAGS_HEADER];
            }
            for (let [key, value] of Object.entries(headers)) {
              if (typeof value === "undefined")
                continue;
              if (Array.isArray(value)) {
                for (const v of value) {
                  res.appendHeader(key, v);
                }
              } else if (typeof value === "number") {
                value = value.toString();
                res.appendHeader(key, value);
              } else {
                res.appendHeader(key, value);
              }
            }
          }
          if (this.minimalMode && isSSG && ((_cachedData_headers = cachedData.headers) == null ? void 0 : _cachedData_headers[_constants2.NEXT_CACHE_TAGS_HEADER])) {
            res.setHeader(_constants2.NEXT_CACHE_TAGS_HEADER, cachedData.headers[_constants2.NEXT_CACHE_TAGS_HEADER]);
          }
          if (cachedData.status && (!isRSCRequest || !isRoutePPREnabled)) {
            res.statusCode = cachedData.status;
          }
          if (didPostpone) {
            res.setHeader(_approuterheaders.NEXT_DID_POSTPONE_HEADER, "1");
          }
          if (isRSCRequest && !isPreviewMode) {
            if (typeof cachedData.rscData === "undefined") {
              if (cachedData.postponed) {
                throw new Error("Invariant: Expected postponed to be undefined");
              }
              return {
                type: "rsc",
                body: cachedData.html,
                // Dynamic RSC responses cannot be cached, even if they're
                // configured with `force-static` because we have no way of
                // distinguishing between `force-static` and pages that have no
                // postponed state.
                // TODO: distinguish `force-static` from pages with no postponed state (static)
                revalidate: isDynamicRSCRequest ? 0 : cacheEntry.revalidate
              };
            }
            return {
              type: "rsc",
              body: _renderresult.default.fromStatic(cachedData.rscData),
              revalidate: cacheEntry.revalidate
            };
          }
          let body = cachedData.html;
          if (!didPostpone || this.minimalMode) {
            return {
              type: "html",
              body,
              revalidate: cacheEntry.revalidate
            };
          }
          if (isDebugStaticShell || isDebugDynamicAccesses) {
            body.chain(new ReadableStream({
              start(controller) {
                controller.enqueue(_encodedTags.ENCODED_TAGS.CLOSED.BODY_AND_HTML);
                controller.close();
              }
            }));
            return {
              type: "html",
              body,
              revalidate: 0
            };
          }
          const transformer = new TransformStream();
          body.chain(transformer.readable);
          doRender({
            postponed: cachedData.postponed,
            // This is a resume render, not a fallback render, so we don't need to
            // set this.
            fallbackRouteParams: null
          }).then(async (result) => {
            var _result_value;
            if (!result) {
              throw new Error("Invariant: expected a result to be returned");
            }
            if (((_result_value = result.value) == null ? void 0 : _result_value.kind) !== _responsecache.CachedRouteKind.APP_PAGE) {
              var _result_value1;
              throw new Error(`Invariant: expected a page response, got ${(_result_value1 = result.value) == null ? void 0 : _result_value1.kind}`);
            }
            await result.value.html.pipeTo(transformer.writable);
          }).catch((err) => {
            transformer.writable.abort(err).catch((e) => {
              console.error("couldn't abort transformer", e);
            });
          });
          return {
            type: "html",
            body,
            // We don't want to cache the response if it has postponed data because
            // the response being sent to the client it's dynamic parts are streamed
            // to the client on the same request.
            revalidate: 0
          };
        } else if (isNextDataRequest) {
          return {
            type: "json",
            body: _renderresult.default.fromStatic(JSON.stringify(cachedData.pageData)),
            revalidate: cacheEntry.revalidate
          };
        } else {
          return {
            type: "html",
            body: cachedData.html,
            revalidate: cacheEntry.revalidate
          };
        }
      }
      stripNextDataPath(path, stripLocale = true) {
        if (path.includes(this.buildId)) {
          const splitPath = path.substring(path.indexOf(this.buildId) + this.buildId.length);
          path = (0, _denormalizepagepath.denormalizePagePath)(splitPath.replace(/\.json$/, ""));
        }
        if (this.localeNormalizer && stripLocale) {
          return this.localeNormalizer.normalize(path);
        }
        return path;
      }
      // map the route to the actual bundle name
      getOriginalAppPaths(route) {
        if (this.enabledDirectories.app) {
          var _this_appPathRoutes;
          const originalAppPath = (_this_appPathRoutes = this.appPathRoutes) == null ? void 0 : _this_appPathRoutes[route];
          if (!originalAppPath) {
            return null;
          }
          return originalAppPath;
        }
        return null;
      }
      async renderPageComponent(ctx, bubbleNoFallback) {
        var _this_nextConfig_experimental_sri;
        const { query, pathname } = ctx;
        const appPaths = this.getOriginalAppPaths(pathname);
        const isAppPath = Array.isArray(appPaths);
        let page = pathname;
        if (isAppPath) {
          page = appPaths[appPaths.length - 1];
        }
        const result = await this.findPageComponents({
          page,
          query,
          params: ctx.renderOpts.params || {},
          isAppPath,
          sriEnabled: !!((_this_nextConfig_experimental_sri = this.nextConfig.experimental.sri) == null ? void 0 : _this_nextConfig_experimental_sri.algorithm),
          appPaths,
          // Ensuring for loading page component routes is done via the matcher.
          shouldEnsure: false
        });
        if (result) {
          (0, _tracer.getTracer)().setRootSpanAttribute("next.route", pathname);
          try {
            return await this.renderToResponseWithComponents(ctx, result);
          } catch (err) {
            const isNoFallbackError = err instanceof NoFallbackError;
            if (!isNoFallbackError || isNoFallbackError && bubbleNoFallback) {
              throw err;
            }
          }
        }
        return false;
      }
      async renderToResponse(ctx) {
        return (0, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderToResponse, {
          spanName: `rendering page`,
          attributes: {
            "next.route": ctx.pathname
          }
        }, async () => {
          return this.renderToResponseImpl(ctx);
        });
      }
      async renderToResponseImpl(ctx) {
        var _this_i18nProvider;
        const { res, query, pathname } = ctx;
        let page = pathname;
        const bubbleNoFallback = !!query._nextBubbleNoFallback;
        delete query[_approuterheaders.NEXT_RSC_UNION_QUERY];
        delete query._nextBubbleNoFallback;
        const options = {
          i18n: (_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.fromQuery(pathname, query)
        };
        try {
          for await (const match of this.matchers.matchAll(pathname, options)) {
            const invokeOutput = (0, _requestmeta.getRequestMeta)(ctx.req, "invokeOutput");
            if (!this.minimalMode && typeof invokeOutput === "string" && (0, _utils1.isDynamicRoute)(invokeOutput || "") && invokeOutput !== match.definition.pathname) {
              continue;
            }
            const result = await this.renderPageComponent({
              ...ctx,
              pathname: match.definition.pathname,
              renderOpts: {
                ...ctx.renderOpts,
                params: match.params
              }
            }, bubbleNoFallback);
            if (result !== false)
              return result;
          }
          if (this.serverOptions.webServerConfig) {
            ctx.pathname = this.serverOptions.webServerConfig.page;
            const result = await this.renderPageComponent(ctx, bubbleNoFallback);
            if (result !== false)
              return result;
          }
        } catch (error) {
          const err = (0, _iserror.getProperError)(error);
          if (error instanceof _utils.MissingStaticPage) {
            console.error("Invariant: failed to load static page", JSON.stringify({
              page,
              url: ctx.req.url,
              matchedPath: ctx.req.headers["x-matched-path"],
              initUrl: (0, _requestmeta.getRequestMeta)(ctx.req, "initURL"),
              didRewrite: !!(0, _requestmeta.getRequestMeta)(ctx.req, "rewroteURL"),
              rewroteUrl: (0, _requestmeta.getRequestMeta)(ctx.req, "rewroteURL")
            }, null, 2));
            throw err;
          }
          if (err instanceof NoFallbackError && bubbleNoFallback) {
            throw err;
          }
          if (err instanceof _utils.DecodeError || err instanceof _utils.NormalizeError) {
            res.statusCode = 400;
            return await this.renderErrorToResponse(ctx, err);
          }
          res.statusCode = 500;
          if (await this.hasPage("/500")) {
            ctx.query.__nextCustomErrorRender = "1";
            await this.renderErrorToResponse(ctx, err);
            delete ctx.query.__nextCustomErrorRender;
          }
          const isWrappedError = err instanceof WrappedBuildError;
          if (!isWrappedError) {
            if (this.minimalMode && true || this.renderOpts.dev) {
              if ((0, _iserror.default)(err))
                err.page = page;
              throw err;
            }
            this.logError((0, _iserror.getProperError)(err));
          }
          const response = await this.renderErrorToResponse(ctx, isWrappedError ? err.innerError : err);
          return response;
        }
        if (this.getMiddleware() && !!ctx.req.headers["x-nextjs-data"] && (!res.statusCode || res.statusCode === 200 || res.statusCode === 404)) {
          res.setHeader("x-nextjs-matched-path", `${query.__nextLocale ? `/${query.__nextLocale}` : ""}${pathname}`);
          res.statusCode = 200;
          res.setHeader("content-type", "application/json");
          res.body("{}");
          res.send();
          return null;
        }
        res.statusCode = 404;
        return this.renderErrorToResponse(ctx, null);
      }
      async renderToHTML(req, res, pathname, query = {}) {
        return (0, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderToHTML, async () => {
          return this.renderToHTMLImpl(req, res, pathname, query);
        });
      }
      async renderToHTMLImpl(req, res, pathname, query = {}) {
        return this.getStaticHTML((ctx) => this.renderToResponse(ctx), {
          req,
          res,
          pathname,
          query
        });
      }
      async renderError(err, req, res, pathname, query = {}, setHeaders = true) {
        return (0, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderError, async () => {
          return this.renderErrorImpl(err, req, res, pathname, query, setHeaders);
        });
      }
      async renderErrorImpl(err, req, res, pathname, query = {}, setHeaders = true) {
        if (setHeaders) {
          res.setHeader("Cache-Control", "private, no-cache, no-store, max-age=0, must-revalidate");
        }
        return this.pipe(async (ctx) => {
          const response = await this.renderErrorToResponse(ctx, err);
          if (this.minimalMode && res.statusCode === 500) {
            throw err;
          }
          return response;
        }, {
          req,
          res,
          pathname,
          query
        });
      }
      async renderErrorToResponse(ctx, err) {
        return (0, _tracer.getTracer)().trace(_constants1.BaseServerSpan.renderErrorToResponse, async () => {
          return this.renderErrorToResponseImpl(ctx, err);
        });
      }
      async renderErrorToResponseImpl(ctx, err) {
        if (this.renderOpts.dev && ctx.pathname === "/favicon.ico") {
          return {
            type: "html",
            body: _renderresult.default.fromStatic("")
          };
        }
        const { res, query } = ctx;
        try {
          let result = null;
          const is404 = res.statusCode === 404;
          let using404Page = false;
          if (is404) {
            if (this.enabledDirectories.app) {
              result = await this.findPageComponents({
                page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,
                query,
                params: {},
                isAppPath: true,
                shouldEnsure: true,
                url: ctx.req.url
              });
              using404Page = result !== null;
            }
            if (!result && await this.hasPage("/404")) {
              result = await this.findPageComponents({
                page: "/404",
                query,
                params: {},
                isAppPath: false,
                // Ensuring can't be done here because you never "match" a 404 route.
                shouldEnsure: true,
                url: ctx.req.url
              });
              using404Page = result !== null;
            }
          }
          let statusPage = `/${res.statusCode}`;
          if (!ctx.query.__nextCustomErrorRender && !result && _constants.STATIC_STATUS_PAGES.includes(statusPage)) {
            if (statusPage !== "/500" || !this.renderOpts.dev) {
              result = await this.findPageComponents({
                page: statusPage,
                query,
                params: {},
                isAppPath: false,
                // Ensuring can't be done here because you never "match" a 500
                // route.
                shouldEnsure: true,
                url: ctx.req.url
              });
            }
          }
          if (!result) {
            result = await this.findPageComponents({
              page: "/_error",
              query,
              params: {},
              isAppPath: false,
              // Ensuring can't be done here because you never "match" an error
              // route.
              shouldEnsure: true,
              url: ctx.req.url
            });
            statusPage = "/_error";
          }
          if (false) {
            this.customErrorNo404Warn();
          }
          if (!result) {
            if (this.renderOpts.dev) {
              return {
                type: "html",
                // wait for dev-server to restart before refreshing
                body: _renderresult.default.fromStatic(`
              <pre>missing required error components, refreshing...</pre>
              <script>
                async function check() {
                  const res = await fetch(location.href).catch(() => ({}))

                  if (res.status === 200) {
                    location.reload()
                  } else {
                    setTimeout(check, 1000)
                  }
                }
                check()
              </script>`)
              };
            }
            throw new WrappedBuildError(new Error("missing required error components"));
          }
          if (result.components.routeModule) {
            (0, _requestmeta.addRequestMeta)(ctx.req, "match", {
              definition: result.components.routeModule.definition,
              params: void 0
            });
          } else {
            (0, _requestmeta.removeRequestMeta)(ctx.req, "match");
          }
          try {
            return await this.renderToResponseWithComponents({
              ...ctx,
              pathname: statusPage,
              renderOpts: {
                ...ctx.renderOpts,
                err
              }
            }, result);
          } catch (maybeFallbackError) {
            if (maybeFallbackError instanceof NoFallbackError) {
              throw new Error("invariant: failed to render error page");
            }
            throw maybeFallbackError;
          }
        } catch (error) {
          const renderToHtmlError = (0, _iserror.getProperError)(error);
          const isWrappedError = renderToHtmlError instanceof WrappedBuildError;
          if (!isWrappedError) {
            this.logError(renderToHtmlError);
          }
          res.statusCode = 500;
          const fallbackComponents = await this.getFallbackErrorComponents(ctx.req.url);
          if (fallbackComponents) {
            (0, _requestmeta.addRequestMeta)(ctx.req, "match", {
              definition: fallbackComponents.routeModule.definition,
              params: void 0
            });
            return this.renderToResponseWithComponents({
              ...ctx,
              pathname: "/_error",
              renderOpts: {
                ...ctx.renderOpts,
                // We render `renderToHtmlError` here because `err` is
                // already captured in the stacktrace.
                err: isWrappedError ? renderToHtmlError.innerError : renderToHtmlError
              }
            }, {
              query,
              components: fallbackComponents
            });
          }
          return {
            type: "html",
            body: _renderresult.default.fromStatic("Internal Server Error")
          };
        }
      }
      async renderErrorToHTML(err, req, res, pathname, query = {}) {
        return this.getStaticHTML((ctx) => this.renderErrorToResponse(ctx, err), {
          req,
          res,
          pathname,
          query
        });
      }
      async render404(req, res, parsedUrl, setHeaders = true) {
        const { pathname, query } = parsedUrl ? parsedUrl : (0, _url.parse)(req.url, true);
        if (this.nextConfig.i18n) {
          query.__nextLocale ||= this.nextConfig.i18n.defaultLocale;
          query.__nextDefaultLocale ||= this.nextConfig.i18n.defaultLocale;
        }
        res.statusCode = 404;
        return this.renderError(null, req, res, pathname, query, setHeaders);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/lru-cache.js
var require_lru_cache = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/lru-cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "LRUCache", {
      enumerable: true,
      get: function() {
        return LRUCache;
      }
    });
    var LRUCache = class {
      constructor(maxSize, calculateSize) {
        this.cache = /* @__PURE__ */ new Map();
        this.sizes = /* @__PURE__ */ new Map();
        this.totalSize = 0;
        this.maxSize = maxSize;
        this.calculateSize = calculateSize || (() => 1);
      }
      set(key, value) {
        if (!key || !value)
          return;
        const size = this.calculateSize(value);
        if (size > this.maxSize) {
          console.warn("Single item size exceeds maxSize");
          return;
        }
        if (this.cache.has(key)) {
          this.totalSize -= this.sizes.get(key) || 0;
        }
        this.cache.set(key, value);
        this.sizes.set(key, size);
        this.totalSize += size;
        this.touch(key);
      }
      has(key) {
        if (!key)
          return false;
        this.touch(key);
        return Boolean(this.cache.get(key));
      }
      get(key) {
        if (!key)
          return;
        const value = this.cache.get(key);
        if (value === void 0) {
          return void 0;
        }
        this.touch(key);
        return value;
      }
      touch(key) {
        const value = this.cache.get(key);
        if (value !== void 0) {
          this.cache.delete(key);
          this.cache.set(key, value);
          this.evictIfNecessary();
        }
      }
      evictIfNecessary() {
        while (this.totalSize > this.maxSize && this.cache.size > 0) {
          this.evictLeastRecentlyUsed();
        }
      }
      evictLeastRecentlyUsed() {
        const lruKey = this.cache.keys().next().value;
        const lruSize = this.sizes.get(lruKey) || 0;
        this.totalSize -= lruSize;
        this.cache.delete(lruKey);
        this.sizes.delete(lruKey);
      }
      reset() {
        this.cache.clear();
        this.sizes.clear();
        this.totalSize = 0;
      }
      keys() {
        return [
          ...this.cache.keys()
        ];
      }
      remove(key) {
        if (this.cache.has(key)) {
          this.totalSize -= this.sizes.get(key) || 0;
          this.cache.delete(key);
          this.sizes.delete(key);
        }
      }
      clear() {
        this.cache.clear();
        this.sizes.clear();
        this.totalSize = 0;
      }
      get size() {
        return this.cache.size;
      }
      get currentSize() {
        return this.totalSize;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/deep-freeze.js
var require_deep_freeze = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/deep-freeze.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "deepFreeze", {
      enumerable: true,
      get: function() {
        return deepFreeze;
      }
    });
    function deepFreeze(obj) {
      if (Object.isFrozen(obj))
        return obj;
      if (Array.isArray(obj)) {
        for (const item of obj) {
          if (!item || typeof item !== "object")
            continue;
          deepFreeze(item);
        }
        return Object.freeze(obj);
      }
      for (const value of Object.values(obj)) {
        if (!value || typeof value !== "object")
          continue;
        deepFreeze(value);
      }
      return Object.freeze(obj);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/load-manifest.js
var require_load_manifest = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/load-manifest.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      clearManifestCache: function() {
        return clearManifestCache;
      },
      evalManifest: function() {
        return evalManifest;
      },
      loadManifest: function() {
        return loadManifest;
      }
    });
    var _fs = require("fs");
    var _vm = require("vm");
    var _deepfreeze = require_deep_freeze();
    var sharedCache = /* @__PURE__ */ new Map();
    function loadManifest(path, shouldCache = true, cache = sharedCache) {
    
          if (path.endsWith(".next/routes-manifest.json")) {
            return {"version":3,"pages404":true,"caseSensitive":false,"basePath":"","redirects":[{"source":"/:path+/","destination":"/:path+","internal":true,"statusCode":308,"regex":"^(?:/((?:[^/]+?)(?:/(?:[^/]+?))*))/$"}],"headers":[],"dynamicRoutes":[{"page":"/api/houses/[slug]","regex":"^/api/houses/([^/]+?)(?:/)?$","routeKeys":{"nxtPslug":"nxtPslug"},"namedRegex":"^/api/houses/(?<nxtPslug>[^/]+?)(?:/)?$"},{"page":"/store/[id]","regex":"^/store/([^/]+?)(?:/)?$","routeKeys":{"nxtPid":"nxtPid"},"namedRegex":"^/store/(?<nxtPid>[^/]+?)(?:/)?$"}],"staticRoutes":[{"page":"/","regex":"^/(?:/)?$","routeKeys":{},"namedRegex":"^/(?:/)?$"},{"page":"/_not-found","regex":"^/_not\\-found(?:/)?$","routeKeys":{},"namedRegex":"^/_not\\-found(?:/)?$"},{"page":"/favicon.ico","regex":"^/favicon\\.ico(?:/)?$","routeKeys":{},"namedRegex":"^/favicon\\.ico(?:/)?$"}],"dataRoutes":[],"rsc":{"header":"RSC","varyHeader":"RSC, Next-Router-State-Tree, Next-Router-Prefetch, Next-Router-Segment-Prefetch","prefetchHeader":"Next-Router-Prefetch","didPostponeHeader":"x-nextjs-postponed","contentTypeHeader":"text/x-component","suffix":".rsc","prefetchSuffix":".prefetch.rsc"},"rewrites":[]};
          }
        

          if (path.endsWith(".next/react-loadable-manifest.json")) {
            return {};
          }
        

          if (path.endsWith(".next/prerender-manifest.json")) {
            return {"version":4,"routes":{"/favicon.ico":{"initialHeaders":{"cache-control":"public, max-age=0, must-revalidate","content-type":"image/x-icon","x-next-cache-tags":"_N_T_/layout,_N_T_/favicon.ico/layout,_N_T_/favicon.ico/route,_N_T_/favicon.ico"},"experimentalBypassFor":[{"type":"header","key":"Next-Action"},{"type":"header","key":"content-type","value":"multipart/form-data;.*"}],"initialRevalidateSeconds":false,"srcRoute":"/favicon.ico","dataRoute":null},"/api/houses":{"initialHeaders":{"content-type":"application/json","x-next-cache-tags":"_N_T_/layout,_N_T_/api/layout,_N_T_/api/houses/layout,_N_T_/api/houses/route,_N_T_/api/houses"},"experimentalBypassFor":[{"type":"header","key":"Next-Action"},{"type":"header","key":"content-type","value":"multipart/form-data;.*"}],"initialRevalidateSeconds":false,"srcRoute":"/api/houses","dataRoute":null},"/":{"experimentalBypassFor":[{"type":"header","key":"Next-Action"},{"type":"header","key":"content-type","value":"multipart/form-data;.*"}],"initialRevalidateSeconds":false,"srcRoute":"/","dataRoute":"/index.rsc"},"/api":{"experimentalBypassFor":[{"type":"header","key":"Next-Action"},{"type":"header","key":"content-type","value":"multipart/form-data;.*"}],"initialRevalidateSeconds":false,"srcRoute":"/api","dataRoute":"/api.rsc"}},"dynamicRoutes":{"/api/houses/[slug]":{"experimentalBypassFor":[{"type":"header","key":"Next-Action"},{"type":"header","key":"content-type","value":"multipart/form-data;.*"}],"routeRegex":"^/api/houses/([^/]+?)(?:/)?$","dataRoute":null,"fallback":null,"dataRouteRegex":null}},"notFoundRoutes":[],"preview":{"previewModeId":"708093bde28238eca2224a1b029a5a69","previewModeSigningKey":"e419f4862212d7fa6506f657e75c6efadcdca40be5f8e03ecbdba809a045ee32","previewModeEncryptionKey":"ab4a103f42b86362e1de4f8ad9c17ae14d09bd2b299174f805e8f513fa726111"}};
          }
        

          if (path.endsWith(".next/build-manifest.json")) {
            return {
  "polyfillFiles": [
    "static/chunks/polyfills-42372ed130431b0a.js"
  ],
  "devFiles": [],
  "ampDevFiles": [],
  "lowPriorityFiles": [
    "static/z2fBFOvp2whhL7a5Yf29l/_buildManifest.js",
    "static/z2fBFOvp2whhL7a5Yf29l/_ssgManifest.js"
  ],
  "rootMainFiles": [
    "static/chunks/webpack-5c3e9a685b088842.js",
    "static/chunks/4bd1b696-a03e661a1f85c7c6.js",
    "static/chunks/215-7b9a77d1904bfb79.js",
    "static/chunks/main-app-89e0f013ec7fadd9.js"
  ],
  "rootMainFilesTree": {},
  "pages": {
    "/_app": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/framework-d61873523a8b382f.js",
      "static/chunks/main-ecc9b667fd846ef0.js",
      "static/chunks/pages/_app-6a626577ffa902a4.js"
    ],
    "/_error": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/framework-d61873523a8b382f.js",
      "static/chunks/main-ecc9b667fd846ef0.js",
      "static/chunks/pages/_error-1be831200e60c5c0.js"
    ]
  },
  "ampFirstPages": []
};
          }
        

          if (path.endsWith(".next/app-path-routes-manifest.json")) {
            return {"/_not-found/page":"/_not-found","/favicon.ico/route":"/favicon.ico","/api/houses/route":"/api/houses","/api/houses/[slug]/route":"/api/houses/[slug]","/api/page":"/api","/page":"/","/store/[id]/page":"/store/[id]"};
          }
        

          if (path.endsWith(".next/app-build-manifest.json")) {
            return {
  "pages": {
    "/_not-found/page": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/4bd1b696-a03e661a1f85c7c6.js",
      "static/chunks/215-7b9a77d1904bfb79.js",
      "static/chunks/main-app-89e0f013ec7fadd9.js",
      "static/chunks/app/_not-found/page-232e26cfe9a586c1.js"
    ],
    "/layout": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/4bd1b696-a03e661a1f85c7c6.js",
      "static/chunks/215-7b9a77d1904bfb79.js",
      "static/chunks/main-app-89e0f013ec7fadd9.js",
      "static/css/b4a8b932208d2c42.css",
      "static/chunks/app/layout-458aa0e57f542953.js"
    ],
    "/api/houses/route": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/4bd1b696-a03e661a1f85c7c6.js",
      "static/chunks/215-7b9a77d1904bfb79.js",
      "static/chunks/main-app-89e0f013ec7fadd9.js",
      "static/chunks/app/api/houses/route-82da12f6ac9f51f3.js"
    ],
    "/api/houses/[slug]/route": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/4bd1b696-a03e661a1f85c7c6.js",
      "static/chunks/215-7b9a77d1904bfb79.js",
      "static/chunks/main-app-89e0f013ec7fadd9.js",
      "static/chunks/app/api/houses/[slug]/route-d0b582285c0be8d8.js"
    ],
    "/api/page": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/4bd1b696-a03e661a1f85c7c6.js",
      "static/chunks/215-7b9a77d1904bfb79.js",
      "static/chunks/main-app-89e0f013ec7fadd9.js",
      "static/chunks/app/api/page-3680aee17d796aca.js"
    ],
    "/page": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/4bd1b696-a03e661a1f85c7c6.js",
      "static/chunks/215-7b9a77d1904bfb79.js",
      "static/chunks/main-app-89e0f013ec7fadd9.js",
      "static/css/e907f6698822faeb.css",
      "static/chunks/app/page-e17fef5175b741cb.js"
    ],
    "/store/[id]/page": [
      "static/chunks/webpack-5c3e9a685b088842.js",
      "static/chunks/4bd1b696-a03e661a1f85c7c6.js",
      "static/chunks/215-7b9a77d1904bfb79.js",
      "static/chunks/main-app-89e0f013ec7fadd9.js",
      "static/css/e907f6698822faeb.css",
      "static/chunks/app/store/[id]/page-b58c083cbda1f170.js"
    ]
  }
};
          }
        

          if (path.endsWith(".next/server/server-reference-manifest.json")) {
            return {"node":{},"edge":{},"encryptionKey":"iu0wNhuEalTDr24gu5AxRY663hV3rrOPL/PPd4wlbXg="};
          }
        

          if (path.endsWith(".next/server/pages-manifest.json")) {
            return {"/_app":"pages/_app.js","/_error":"pages/_error.js","/_document":"pages/_document.js","/404":"pages/404.html"};
          }
        

          if (path.endsWith(".next/server/next-font-manifest.json")) {
            return {"pages":{},"app":{"/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/app/layout":["static/media/463dafcda517f24f-s.p.woff","static/media/4473ecc91f70f139-s.p.woff"]},"appUsingSizeAdjust":true,"pagesUsingSizeAdjust":false};
          }
        

          if (path.endsWith(".next/server/middleware-manifest.json")) {
            return {
  "version": 3,
  "middleware": {},
  "functions": {},
  "sortedMiddleware": []
};
          }
        

          if (path.endsWith(".next/server/app-paths-manifest.json")) {
            return {
  "/_not-found/page": "app/_not-found/page.js",
  "/favicon.ico/route": "app/favicon.ico/route.js",
  "/api/houses/route": "app/api/houses/route.js",
  "/api/houses/[slug]/route": "app/api/houses/[slug]/route.js",
  "/api/page": "app/api/page.js",
  "/page": "app/page.js",
  "/store/[id]/page": "app/store/[id]/page.js"
};
          }
        
    throw new Error("Unknown loadManifest: " + path);
    
      const cached = shouldCache && cache.get(path);
      if (cached) {
        return cached;
      }
      let manifest = JSON.parse((0, _fs.readFileSync)(path, "utf8"));
      if (shouldCache) {
        manifest = (0, _deepfreeze.deepFreeze)(manifest);
      }
      if (shouldCache) {
        cache.set(path, manifest);
      }
      return manifest;
    }
    function evalManifest(path, shouldCache = true, cache = sharedCache) {
		
			  if (path.endsWith(".next/server/app/page_client-reference-manifest.js")) {
				require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/page_client-reference-manifest.js");
				return {
				  __RSC_MANIFEST: {
					"/page": globalThis.__RSC_MANIFEST["/page"],
				  },
				};
			  }
			

			  if (path.endsWith(".next/server/app/store/[id]/page_client-reference-manifest.js")) {
				require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/store/[id]/page_client-reference-manifest.js");
				return {
				  __RSC_MANIFEST: {
					"/store/[id]/page": globalThis.__RSC_MANIFEST["/store/[id]/page"],
				  },
				};
			  }
			

			  if (path.endsWith(".next/server/app/api/page_client-reference-manifest.js")) {
				require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/api/page_client-reference-manifest.js");
				return {
				  __RSC_MANIFEST: {
					"/api/page": globalThis.__RSC_MANIFEST["/api/page"],
				  },
				};
			  }
			

			  if (path.endsWith(".next/server/app/api/houses/route_client-reference-manifest.js")) {
				require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/api/houses/route_client-reference-manifest.js");
				return {
				  __RSC_MANIFEST: {
					"/api/houses/route": globalThis.__RSC_MANIFEST["/api/houses/route"],
				  },
				};
			  }
			

			  if (path.endsWith(".next/server/app/api/houses/[slug]/route_client-reference-manifest.js")) {
				require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/api/houses/[slug]/route_client-reference-manifest.js");
				return {
				  __RSC_MANIFEST: {
					"/api/houses/[slug]/route": globalThis.__RSC_MANIFEST["/api/houses/[slug]/route"],
				  },
				};
			  }
			

			  if (path.endsWith(".next/server/app/_not-found/page_client-reference-manifest.js")) {
				require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/_not-found/page_client-reference-manifest.js");
				return {
				  __RSC_MANIFEST: {
					"/_not-found/page": globalThis.__RSC_MANIFEST["/_not-found/page"],
				  },
				};
			  }
			
		throw new Error("Unknown evalManifest: " + path);
		
      const cached = shouldCache && cache.get(path);
      if (cached) {
        return cached;
      }
      const content = (0, _fs.readFileSync)(path, "utf8");
      if (content.length === 0) {
        throw new Error("Manifest file is empty");
      }
      let contextObject = {};
      (0, _vm.runInNewContext)(content, contextObject);
      if (shouldCache) {
        contextObject = (0, _deepfreeze.deepFreeze)(contextObject);
      }
      if (shouldCache) {
        cache.set(path, contextObject);
      }
      return contextObject;
    }
    function clearManifestCache(path, cache = sharedCache) {
      return cache.delete(path);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/require.js
var require_require = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/require.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getMaybePagePath: function() {
        return getMaybePagePath;
      },
      getPagePath: function() {
        return getPagePath;
      },
      requirePage: function() {
        return requirePage;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require("path"));
    var _constants = require_constants3();
    var _normalizelocalepath = require_normalize_locale_path();
    var _normalizepagepath = require_normalize_page_path();
    var _denormalizepagepath = require_denormalize_page_path();
    var _utils = require_utils3();
    var _lrucache = require_lru_cache();
    var _loadmanifest = require_load_manifest();
    var _fs = require("fs");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var isDev = false;
    var pagePathCache = !isDev ? new _lrucache.LRUCache(1e3) : null;
    function getMaybePagePath(page, distDir, locales, isAppPath) {
      const cacheKey = `${page}:${distDir}:${locales}:${isAppPath}`;
      let pagePath = pagePathCache == null ? void 0 : pagePathCache.get(cacheKey);
      if (pagePath)
        return pagePath;
      const serverBuildPath = _path.default.join(distDir, _constants.SERVER_DIRECTORY);
      let appPathsManifest;
      if (isAppPath) {
        appPathsManifest = (0, _loadmanifest.loadManifest)(_path.default.join(serverBuildPath, _constants.APP_PATHS_MANIFEST), !isDev);
      }
      const pagesManifest = (0, _loadmanifest.loadManifest)(_path.default.join(serverBuildPath, _constants.PAGES_MANIFEST), !isDev);
      try {
        page = (0, _denormalizepagepath.denormalizePagePath)((0, _normalizepagepath.normalizePagePath)(page));
      } catch (err) {
        console.error(err);
        throw new _utils.PageNotFoundError(page);
      }
      const checkManifest = (manifest) => {
        let curPath = manifest[page];
        if (!manifest[curPath] && locales) {
          const manifestNoLocales = {};
          for (const key of Object.keys(manifest)) {
            manifestNoLocales[(0, _normalizelocalepath.normalizeLocalePath)(key, locales).pathname] = pagesManifest[key];
          }
          curPath = manifestNoLocales[page];
        }
        return curPath;
      };
      if (appPathsManifest) {
        pagePath = checkManifest(appPathsManifest);
      }
      if (!pagePath) {
        pagePath = checkManifest(pagesManifest);
      }
      if (!pagePath) {
        pagePathCache == null ? void 0 : pagePathCache.set(cacheKey, null);
        return null;
      }
      pagePath = _path.default.join(serverBuildPath, pagePath);
      pagePathCache == null ? void 0 : pagePathCache.set(cacheKey, pagePath);
      return pagePath;
    }
    function getPagePath(page, distDir, locales, isAppPath) {
      const pagePath = getMaybePagePath(page, distDir, locales, isAppPath);
      if (!pagePath) {
        throw new _utils.PageNotFoundError(page);
      }
      return pagePath;
    }
    async function requirePage(page, distDir, isAppPath) {
      const pagePath = getPagePath(page, distDir, void 0, isAppPath);
    
          if (pagePath.endsWith(".next/server/pages/404.html")) {
            return "<!DOCTYPE html><html lang=\"en\"><head><meta charSet=\"utf-8\"/><meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"/><link rel=\"preload\" href=\"/_next/static/media/4473ecc91f70f139-s.p.woff\" as=\"font\" crossorigin=\"\" type=\"font/woff\"/><link rel=\"preload\" href=\"/_next/static/media/463dafcda517f24f-s.p.woff\" as=\"font\" crossorigin=\"\" type=\"font/woff\"/><link rel=\"stylesheet\" href=\"/_next/static/css/b4a8b932208d2c42.css\" data-precedence=\"next\"/><link rel=\"preload\" as=\"script\" fetchPriority=\"low\" href=\"/_next/static/chunks/webpack-5c3e9a685b088842.js\"/><script src=\"/_next/static/chunks/4bd1b696-a03e661a1f85c7c6.js\" async=\"\"></script><script src=\"/_next/static/chunks/215-7b9a77d1904bfb79.js\" async=\"\"></script><script src=\"/_next/static/chunks/main-app-89e0f013ec7fadd9.js\" async=\"\"></script><meta name=\"robots\" content=\"noindex\"/><meta name=\"next-size-adjust\"/><title>404: This page could not be found.</title><title>Create Next App</title><meta name=\"description\" content=\"Generated by create next app\"/><script src=\"/_next/static/chunks/polyfills-42372ed130431b0a.js\" noModule=\"\"></script></head><body class=\"__variable_1e4310 __variable_c3aa02 antialiased\"><div style=\"font-family:system-ui,&quot;Segoe UI&quot;,Roboto,Helvetica,Arial,sans-serif,&quot;Apple Color Emoji&quot;,&quot;Segoe UI Emoji&quot;;height:100vh;text-align:center;display:flex;flex-direction:column;align-items:center;justify-content:center\"><div><style>body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}</style><h1 class=\"next-error-h1\" style=\"display:inline-block;margin:0 20px 0 0;padding:0 23px 0 0;font-size:24px;font-weight:500;vertical-align:top;line-height:49px\">404</h1><div style=\"display:inline-block\"><h2 style=\"font-size:14px;font-weight:400;line-height:49px;margin:0\">This page could not be found.</h2></div></div></div><script src=\"/_next/static/chunks/webpack-5c3e9a685b088842.js\" async=\"\"></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,\"4:\\\"$Sreact.fragment\\\"\\n5:I[9275,[],\\\"\\\"]\\n6:I[1343,[],\\\"\\\"]\\n7:I[3120,[],\\\"OutletBoundary\\\"]\\n9:I[3120,[],\\\"MetadataBoundary\\\"]\\nb:I[3120,[],\\\"ViewportBoundary\\\"]\\nd:I[6130,[],\\\"\\\"]\\n1:HL[\\\"/_next/static/media/4473ecc91f70f139-s.p.woff\\\",\\\"font\\\",{\\\"crossOrigin\\\":\\\"\\\",\\\"type\\\":\\\"font/woff\\\"}]\\n2:HL[\\\"/_next/static/media/463dafcda517f24f-s.p.woff\\\",\\\"font\\\",{\\\"crossOrigin\\\":\\\"\\\",\\\"type\\\":\\\"font/woff\\\"}]\\n3:HL[\\\"/_next/static/css/b4a8b932208d2c42.css\\\",\\\"style\\\"]\\n\"])</script><script>self.__next_f.push([1,\"0:{\\\"P\\\":null,\\\"b\\\":\\\"z2fBFOvp2whhL7a5Yf29l\\\",\\\"p\\\":\\\"\\\",\\\"c\\\":[\\\"\\\",\\\"_not-found\\\"],\\\"i\\\":false,\\\"f\\\":[[[\\\"\\\",{\\\"children\\\":[\\\"/_not-found\\\",{\\\"children\\\":[\\\"__PAGE__\\\",{}]}]},\\\"$undefined\\\",\\\"$undefined\\\",true],[\\\"\\\",[\\\"$\\\",\\\"$4\\\",\\\"c\\\",{\\\"children\\\":[[[\\\"$\\\",\\\"link\\\",\\\"0\\\",{\\\"rel\\\":\\\"stylesheet\\\",\\\"href\\\":\\\"/_next/static/css/b4a8b932208d2c42.css\\\",\\\"precedence\\\":\\\"next\\\",\\\"crossOrigin\\\":\\\"$undefined\\\",\\\"nonce\\\":\\\"$undefined\\\"}]],[\\\"$\\\",\\\"html\\\",null,{\\\"lang\\\":\\\"en\\\",\\\"children\\\":[\\\"$\\\",\\\"body\\\",null,{\\\"className\\\":\\\"__variable_1e4310 __variable_c3aa02 antialiased\\\",\\\"children\\\":[\\\"$\\\",\\\"$L5\\\",null,{\\\"parallelRouterKey\\\":\\\"children\\\",\\\"segmentPath\\\":[\\\"children\\\"],\\\"error\\\":\\\"$undefined\\\",\\\"errorStyles\\\":\\\"$undefined\\\",\\\"errorScripts\\\":\\\"$undefined\\\",\\\"template\\\":[\\\"$\\\",\\\"$L6\\\",null,{}],\\\"templateStyles\\\":\\\"$undefined\\\",\\\"templateScripts\\\":\\\"$undefined\\\",\\\"notFound\\\":[[\\\"$\\\",\\\"title\\\",null,{\\\"children\\\":\\\"404: This page could not be found.\\\"}],[\\\"$\\\",\\\"div\\\",null,{\\\"style\\\":{\\\"fontFamily\\\":\\\"system-ui,\\\\\\\"Segoe UI\\\\\\\",Roboto,Helvetica,Arial,sans-serif,\\\\\\\"Apple Color Emoji\\\\\\\",\\\\\\\"Segoe UI Emoji\\\\\\\"\\\",\\\"height\\\":\\\"100vh\\\",\\\"textAlign\\\":\\\"center\\\",\\\"display\\\":\\\"flex\\\",\\\"flexDirection\\\":\\\"column\\\",\\\"alignItems\\\":\\\"center\\\",\\\"justifyContent\\\":\\\"center\\\"},\\\"children\\\":[\\\"$\\\",\\\"div\\\",null,{\\\"children\\\":[[\\\"$\\\",\\\"style\\\",null,{\\\"dangerouslySetInnerHTML\\\":{\\\"__html\\\":\\\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\\\"}}],[\\\"$\\\",\\\"h1\\\",null,{\\\"className\\\":\\\"next-error-h1\\\",\\\"style\\\":{\\\"display\\\":\\\"inline-block\\\",\\\"margin\\\":\\\"0 20px 0 0\\\",\\\"padding\\\":\\\"0 23px 0 0\\\",\\\"fontSize\\\":24,\\\"fontWeight\\\":500,\\\"verticalAlign\\\":\\\"top\\\",\\\"lineHeight\\\":\\\"49px\\\"},\\\"children\\\":\\\"404\\\"}],[\\\"$\\\",\\\"div\\\",null,{\\\"style\\\":{\\\"display\\\":\\\"inline-block\\\"},\\\"children\\\":[\\\"$\\\",\\\"h2\\\",null,{\\\"style\\\":{\\\"fontSize\\\":14,\\\"fontWeight\\\":400,\\\"lineHeight\\\":\\\"49px\\\",\\\"margin\\\":0},\\\"children\\\":\\\"This page could not be found.\\\"}]}]]}]}]],\\\"notFoundStyles\\\":[]}]}]}]]}],{\\\"children\\\":[\\\"/_not-found\\\",[\\\"$\\\",\\\"$4\\\",\\\"c\\\",{\\\"children\\\":[null,[\\\"$\\\",\\\"$L5\\\",null,{\\\"parallelRouterKey\\\":\\\"children\\\",\\\"segmentPath\\\":[\\\"children\\\",\\\"/_not-found\\\",\\\"children\\\"],\\\"error\\\":\\\"$undefined\\\",\\\"errorStyles\\\":\\\"$undefined\\\",\\\"errorScripts\\\":\\\"$undefined\\\",\\\"template\\\":[\\\"$\\\",\\\"$L6\\\",null,{}],\\\"templateStyles\\\":\\\"$undefined\\\",\\\"templateScripts\\\":\\\"$undefined\\\",\\\"notFound\\\":\\\"$undefined\\\",\\\"notFoundStyles\\\":\\\"$undefined\\\"}]]}],{\\\"children\\\":[\\\"__PAGE__\\\",[\\\"$\\\",\\\"$4\\\",\\\"c\\\",{\\\"children\\\":[[[\\\"$\\\",\\\"title\\\",null,{\\\"children\\\":\\\"404: This page could not be found.\\\"}],[\\\"$\\\",\\\"div\\\",null,{\\\"style\\\":\\\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:props:style\\\",\\\"children\\\":[\\\"$\\\",\\\"div\\\",null,{\\\"children\\\":[[\\\"$\\\",\\\"style\\\",null,{\\\"dangerouslySetInnerHTML\\\":{\\\"__html\\\":\\\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\\\"}}],[\\\"$\\\",\\\"h1\\\",null,{\\\"className\\\":\\\"next-error-h1\\\",\\\"style\\\":\\\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:props:children:props:children:1:props:style\\\",\\\"children\\\":\\\"404\\\"}],[\\\"$\\\",\\\"div\\\",null,{\\\"style\\\":\\\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:props:children:props:children:2:props:style\\\",\\\"children\\\":[\\\"$\\\",\\\"h2\\\",null,{\\\"style\\\":\\\"$0:f:0:1:1:props:children:1:props:children:props:children:props:notFound:1:props:children:props:children:2:props:children:props:style\\\",\\\"children\\\":\\\"This page could not be found.\\\"}]}]]}]}]],null,[\\\"$\\\",\\\"$L7\\\",null,{\\\"children\\\":\\\"$L8\\\"}]]}],{},null]},null]},null],[\\\"$\\\",\\\"$4\\\",\\\"h\\\",{\\\"children\\\":[[\\\"$\\\",\\\"meta\\\",null,{\\\"name\\\":\\\"robots\\\",\\\"content\\\":\\\"noindex\\\"}],[\\\"$\\\",\\\"$4\\\",\\\"rDcojfRJtysLEiVidjYZs\\\",{\\\"children\\\":[[\\\"$\\\",\\\"$L9\\\",null,{\\\"children\\\":\\\"$La\\\"}],[\\\"$\\\",\\\"$Lb\\\",null,{\\\"children\\\":\\\"$Lc\\\"}],[\\\"$\\\",\\\"meta\\\",null,{\\\"name\\\":\\\"next-size-adjust\\\"}]]}]]}]]],\\\"m\\\":\\\"$undefined\\\",\\\"G\\\":\\\"$d\\\",\\\"s\\\":false,\\\"S\\\":true}\\n\"])</script><script>self.__next_f.push([1,\"c:[[\\\"$\\\",\\\"meta\\\",\\\"0\\\",{\\\"name\\\":\\\"viewport\\\",\\\"content\\\":\\\"width=device-width, initial-scale=1\\\"}]]\\na:[[\\\"$\\\",\\\"meta\\\",\\\"0\\\",{\\\"charSet\\\":\\\"utf-8\\\"}],[\\\"$\\\",\\\"title\\\",\\\"1\\\",{\\\"children\\\":\\\"Create Next App\\\"}],[\\\"$\\\",\\\"meta\\\",\\\"2\\\",{\\\"name\\\":\\\"description\\\",\\\"content\\\":\\\"Generated by create next app\\\"}]]\\n\"])</script><script>self.__next_f.push([1,\"8:null\\n\"])</script></body></html>";
          }
        
    
          if (pagePath.endsWith(".next/server/pages/_app.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/pages/_app.js");
          }
        

          if (pagePath.endsWith(".next/server/pages/_error.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/pages/_error.js");
          }
        

          if (pagePath.endsWith(".next/server/pages/_document.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/pages/_document.js");
          }
        

          if (pagePath.endsWith(".next/server/app/_not-found/page.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/_not-found/page.js");
          }
        

          if (pagePath.endsWith(".next/server/app/favicon.ico/route.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/favicon.ico/route.js");
          }
        

          if (pagePath.endsWith(".next/server/app/api/houses/route.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/api/houses/route.js");
          }
        

          if (pagePath.endsWith(".next/server/app/api/houses/[slug]/route.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/api/houses/[slug]/route.js");
          }
        

          if (pagePath.endsWith(".next/server/app/api/page.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/api/page.js");
          }
        

          if (pagePath.endsWith(".next/server/app/page.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/page.js");
          }
        

          if (pagePath.endsWith(".next/server/app/store/[id]/page.js")) {
            return require("/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf/.worker-next/.next/standalone/.next/server/app/store/[id]/page.js");
          }
        
    throw new Error("Unknown pagePath: " + pagePath);
    
      if (pagePath.endsWith(".html")) {
        return _fs.promises.readFile(pagePath, "utf8").catch((err) => {
          throw new _utils.MissingStaticPage(page, err.message);
        });
      }
      try {
        process.env.__NEXT_PRIVATE_RUNTIME_TYPE = isAppPath ? "app" : "pages";
        const mod = true ? require(pagePath) : require(pagePath);
        return mod;
      } finally {
        process.env.__NEXT_PRIVATE_RUNTIME_TYPE = "";
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/interop-default.js
var require_interop_default = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/interop-default.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "interopDefault", {
      enumerable: true,
      get: function() {
        return interopDefault;
      }
    });
    function interopDefault(mod) {
      return mod.default || mod;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/wait.js
var require_wait = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/wait.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "wait", {
      enumerable: true,
      get: function() {
        return wait;
      }
    });
    async function wait(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/encryption-utils.js
var require_encryption_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/encryption-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      arrayBufferToString: function() {
        return arrayBufferToString;
      },
      decrypt: function() {
        return decrypt;
      },
      encrypt: function() {
        return encrypt;
      },
      getActionEncryptionKey: function() {
        return getActionEncryptionKey;
      },
      getClientReferenceManifestSingleton: function() {
        return getClientReferenceManifestSingleton;
      },
      getServerModuleMap: function() {
        return getServerModuleMap;
      },
      setReferenceManifestsSingleton: function() {
        return setReferenceManifestsSingleton;
      },
      stringToUint8Array: function() {
        return stringToUint8Array;
      }
    });
    var __next_loaded_action_key;
    function arrayBufferToString(buffer) {
      const bytes = new Uint8Array(buffer);
      const len = bytes.byteLength;
      if (len < 65535) {
        return String.fromCharCode.apply(null, bytes);
      }
      let binary = "";
      for (let i = 0; i < len; i++) {
        binary += String.fromCharCode(bytes[i]);
      }
      return binary;
    }
    function stringToUint8Array(binary) {
      const len = binary.length;
      const arr = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        arr[i] = binary.charCodeAt(i);
      }
      return arr;
    }
    function encrypt(key, iv, data) {
      return crypto.subtle.encrypt({
        name: "AES-GCM",
        iv
      }, key, data);
    }
    function decrypt(key, iv, data) {
      return crypto.subtle.decrypt({
        name: "AES-GCM",
        iv
      }, key, data);
    }
    var SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for("next.server.action-manifests");
    function setReferenceManifestsSingleton({ clientReferenceManifest, serverActionsManifest, serverModuleMap }) {
      globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {
        clientReferenceManifest,
        serverActionsManifest,
        serverModuleMap
      };
    }
    function getServerModuleMap() {
      const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
      if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
      }
      return serverActionsManifestSingleton.serverModuleMap;
    }
    function getClientReferenceManifestSingleton() {
      const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
      if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
      }
      return serverActionsManifestSingleton.clientReferenceManifest;
    }
    async function getActionEncryptionKey() {
      if (__next_loaded_action_key) {
        return __next_loaded_action_key;
      }
      const serverActionsManifestSingleton = globalThis[SERVER_ACTION_MANIFESTS_SINGLETON];
      if (!serverActionsManifestSingleton) {
        throw new Error("Missing manifest for Server Actions. This is a bug in Next.js");
      }
      const rawKey = process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY || serverActionsManifestSingleton.serverActionsManifest.encryptionKey;
      if (rawKey === void 0) {
        throw new Error("Missing encryption key for Server Actions");
      }
      __next_loaded_action_key = await crypto.subtle.importKey("raw", stringToUint8Array(atob(rawKey)), "AES-GCM", true, [
        "encrypt",
        "decrypt"
      ]);
      return __next_loaded_action_key;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/app-render/action-utils.js
var require_action_utils = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/app-render/action-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      createServerModuleMap: function() {
        return createServerModuleMap;
      },
      selectWorkerForForwarding: function() {
        return selectWorkerForForwarding;
      }
    });
    var _apppaths = require_app_paths();
    var _pathhasprefix = require_path_has_prefix();
    var _removepathprefix = require_remove_path_prefix();
    function createServerModuleMap({ serverActionsManifest, pageName }) {
      return new Proxy({}, {
        get: (_, id) => {
          return {
            id: serverActionsManifest[false ? "edge" : "node"][id].workers[normalizeWorkerPageName(pageName)],
            name: id,
            chunks: []
          };
        }
      });
    }
    function selectWorkerForForwarding(actionId, pageName, serverActionsManifest) {
      var _serverActionsManifest__actionId;
      const workers = (_serverActionsManifest__actionId = serverActionsManifest[false ? "edge" : "node"][actionId]) == null ? void 0 : _serverActionsManifest__actionId.workers;
      const workerName = normalizeWorkerPageName(pageName);
      if (!workers)
        return;
      if (workers[workerName]) {
        return;
      }
      return denormalizeWorkerPageName(Object.keys(workers)[0]);
    }
    function normalizeWorkerPageName(pageName) {
      if ((0, _pathhasprefix.pathHasPrefix)(pageName, "app")) {
        return pageName;
      }
      return "app" + pageName;
    }
    function denormalizeWorkerPageName(bundlePath) {
      return (0, _apppaths.normalizeAppPath)((0, _removepathprefix.removePathPrefix)(bundlePath, "app"));
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/load-components.js
var require_load_components = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/load-components.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      evalManifestWithRetries: function() {
        return evalManifestWithRetries;
      },
      loadComponents: function() {
        return loadComponents;
      },
      loadManifestWithRetries: function() {
        return loadManifestWithRetries;
      }
    });
    var _constants = require_constants3();
    var _path = require("path");
    var _require = require_require();
    var _interopdefault = require_interop_default();
    var _tracer = require_tracer();
    var _constants1 = require_constants2();
    var _loadmanifest = require_load_manifest();
    var _wait = require_wait();
    var _encryptionutils = require_encryption_utils();
    var _actionutils = require_action_utils();
    var _ismetadataroute = require_is_metadata_route();
    async function loadManifestWithRetries(manifestPath, attempts = 3) {
      while (true) {
        try {
          return (0, _loadmanifest.loadManifest)(manifestPath);
        } catch (err) {
          attempts--;
          if (attempts <= 0)
            throw err;
          await (0, _wait.wait)(100);
        }
      }
    }
    async function evalManifestWithRetries(manifestPath, attempts = 3) {
      while (true) {
        try {
          return (0, _loadmanifest.evalManifest)(manifestPath);
        } catch (err) {
          attempts--;
          if (attempts <= 0)
            throw err;
          await (0, _wait.wait)(100);
        }
      }
    }
    async function loadClientReferenceManifest(manifestPath, entryName) {
      try {
        const context = await evalManifestWithRetries(manifestPath);
        return context.__RSC_MANIFEST[entryName];
      } catch (err) {
        return void 0;
      }
    }
    async function loadComponentsImpl({ distDir, page, isAppPath }) {
      let DocumentMod = {};
      let AppMod = {};
      if (!isAppPath) {
        [DocumentMod, AppMod] = await Promise.all([
          (0, _require.requirePage)("/_document", distDir, false),
          (0, _require.requirePage)("/_app", distDir, false)
        ]);
      }
      const hasClientManifest = isAppPath && !(0, _ismetadataroute.isMetadataRoute)(page);
      const [buildManifest, reactLoadableManifest, clientReferenceManifest, serverActionsManifest] = await Promise.all([
        loadManifestWithRetries((0, _path.join)(distDir, _constants.BUILD_MANIFEST)),
        loadManifestWithRetries((0, _path.join)(distDir, _constants.REACT_LOADABLE_MANIFEST)),
        hasClientManifest ? loadClientReferenceManifest((0, _path.join)(distDir, "server", "app", page.replace(/%5F/g, "_") + "_" + _constants.CLIENT_REFERENCE_MANIFEST + ".js"), page.replace(/%5F/g, "_")) : void 0,
        isAppPath ? loadManifestWithRetries((0, _path.join)(distDir, "server", _constants.SERVER_REFERENCE_MANIFEST + ".json")).catch(() => null) : null
      ]);
      if (serverActionsManifest && clientReferenceManifest) {
        (0, _encryptionutils.setReferenceManifestsSingleton)({
          clientReferenceManifest,
          serverActionsManifest,
          serverModuleMap: (0, _actionutils.createServerModuleMap)({
            serverActionsManifest,
            pageName: page
          })
        });
      }
      const ComponentMod = await (0, _require.requirePage)(page, distDir, isAppPath);
      const Component = (0, _interopdefault.interopDefault)(ComponentMod);
      const Document = (0, _interopdefault.interopDefault)(DocumentMod);
      const App = (0, _interopdefault.interopDefault)(AppMod);
      const { getServerSideProps, getStaticProps, getStaticPaths, routeModule } = ComponentMod;
      return {
        App,
        Document,
        Component,
        buildManifest,
        reactLoadableManifest,
        pageConfig: ComponentMod.config || {},
        ComponentMod,
        getServerSideProps,
        getStaticProps,
        getStaticPaths,
        clientReferenceManifest,
        serverActionsManifest,
        isAppPath,
        page,
        routeModule
      };
    }
    var loadComponents = (0, _tracer.getTracer)().wrap(_constants1.LoadComponentsSpan.loadComponents, loadComponentsImpl);
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/middleware-route-matcher.js
var require_middleware_route_matcher = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/shared/lib/router/utils/middleware-route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getMiddlewareRouteMatcher", {
      enumerable: true,
      get: function() {
        return getMiddlewareRouteMatcher;
      }
    });
    var _preparedestination = require_prepare_destination();
    function getMiddlewareRouteMatcher(matchers) {
      return (pathname, req, query) => {
        for (const matcher of matchers) {
          const routeMatch = new RegExp(matcher.regexp).exec(pathname);
          if (!routeMatch) {
            continue;
          }
          if (matcher.has || matcher.missing) {
            const hasParams = (0, _preparedestination.matchHas)(req, query, matcher.has, matcher.missing);
            if (!hasParams) {
              continue;
            }
          }
          return true;
        }
        return false;
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/@opennextjs/cloudflare/cli/templates/shims/env.ts
var env_exports = {};
__export2(env_exports, {
  loadEnvConfig: () => loadEnvConfig
});
function loadEnvConfig() {
}
var init_env = __esm({
  ".worker-next/.next/standalone/node_modules/@opennextjs/cloudflare/cli/templates/shims/env.ts"() {
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/body-streams.js
var require_body_streams = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/body-streams.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      getCloneableBody: function() {
        return getCloneableBody;
      },
      requestToBodyStream: function() {
        return requestToBodyStream;
      }
    });
    var _stream = require("stream");
    function requestToBodyStream(context, KUint8Array, stream) {
      return new context.ReadableStream({
        start: async (controller) => {
          for await (const chunk of stream) {
            controller.enqueue(new KUint8Array(chunk));
          }
          controller.close();
        }
      });
    }
    function replaceRequestBody(base, stream) {
      for (const key in stream) {
        let v = stream[key];
        if (typeof v === "function") {
          v = v.bind(base);
        }
        base[key] = v;
      }
      return base;
    }
    function getCloneableBody(readable) {
      let buffered = null;
      const endPromise = new Promise((resolve, reject) => {
        readable.on("end", resolve);
        readable.on("error", reject);
      }).catch((error) => {
        return {
          error
        };
      });
      return {
        /**
        * Replaces the original request body if necessary.
        * This is done because once we read the body from the original request,
        * we can't read it again.
        */
        async finalize() {
          if (buffered) {
            const res = await endPromise;
            if (res && typeof res === "object" && res.error) {
              throw res.error;
            }
            replaceRequestBody(readable, buffered);
            buffered = readable;
          }
        },
        /**
        * Clones the body stream
        * to pass into a middleware
        */
        cloneBodyStream() {
          const input = buffered ?? readable;
          const p1 = new _stream.PassThrough();
          const p2 = new _stream.PassThrough();
          input.on("data", (chunk) => {
            p1.push(chunk);
            p2.push(chunk);
          });
          input.on("end", () => {
            p1.push(null);
            p2.push(null);
          });
          buffered = p2;
          return p1;
        }
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/fetch-cache.js
var require_fetch_cache = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/fetch-cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FetchCache;
      }
    });
    var _responsecache = require_response_cache();
    var _lrucache = require_lru_cache();
    var _constants = require_constants();
    var rateLimitedUntil = 0;
    var memoryCache;
    var CACHE_TAGS_HEADER = "x-vercel-cache-tags";
    var CACHE_HEADERS_HEADER = "x-vercel-sc-headers";
    var CACHE_STATE_HEADER = "x-vercel-cache-state";
    var CACHE_REVALIDATE_HEADER = "x-vercel-revalidate";
    var CACHE_FETCH_URL_HEADER = "x-vercel-cache-item-name";
    var CACHE_CONTROL_VALUE_HEADER = "x-vercel-cache-control";
    var DEBUG = Boolean(process.env.NEXT_PRIVATE_DEBUG_CACHE);
    async function fetchRetryWithTimeout(url, init, retryIndex = 0) {
      const controller = new AbortController();
      const timeout = setTimeout(() => {
        controller.abort();
      }, 500);
      return fetch(url, {
        ...init || {},
        signal: controller.signal
      }).catch((err) => {
        if (retryIndex === 3) {
          throw err;
        } else {
          if (DEBUG) {
            console.log(`Fetch failed for ${url} retry ${retryIndex}`);
          }
          return fetchRetryWithTimeout(url, init, retryIndex + 1);
        }
      }).finally(() => {
        clearTimeout(timeout);
      });
    }
    var FetchCache = class {
      hasMatchingTags(arr1, arr2) {
        if (arr1.length !== arr2.length)
          return false;
        const set1 = new Set(arr1);
        const set2 = new Set(arr2);
        if (set1.size !== set2.size)
          return false;
        for (let tag of set1) {
          if (!set2.has(tag))
            return false;
        }
        return true;
      }
      static isAvailable(ctx) {
        return !!(ctx._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL);
      }
      constructor(ctx) {
        this.headers = {};
        this.headers["Content-Type"] = "application/json";
        if (CACHE_HEADERS_HEADER in ctx._requestHeaders) {
          const newHeaders = JSON.parse(ctx._requestHeaders[CACHE_HEADERS_HEADER]);
          for (const k in newHeaders) {
            this.headers[k] = newHeaders[k];
          }
          delete ctx._requestHeaders[CACHE_HEADERS_HEADER];
        }
        const scHost = ctx._requestHeaders["x-vercel-sc-host"] || process.env.SUSPENSE_CACHE_URL;
        const scBasePath = ctx._requestHeaders["x-vercel-sc-basepath"] || process.env.SUSPENSE_CACHE_BASEPATH;
        if (process.env.SUSPENSE_CACHE_AUTH_TOKEN) {
          this.headers["Authorization"] = `Bearer ${process.env.SUSPENSE_CACHE_AUTH_TOKEN}`;
        }
        if (scHost) {
          const scProto = process.env.SUSPENSE_CACHE_PROTO || "https";
          this.cacheEndpoint = `${scProto}://${scHost}${scBasePath || ""}`;
          if (DEBUG) {
            console.log("using cache endpoint", this.cacheEndpoint);
          }
        } else if (DEBUG) {
          console.log("no cache endpoint available");
        }
        if (ctx.maxMemoryCacheSize) {
          if (!memoryCache) {
            if (DEBUG) {
              console.log("using memory store for fetch cache");
            }
            memoryCache = new _lrucache.LRUCache(ctx.maxMemoryCacheSize, function length({ value }) {
              var _JSON_stringify;
              if (!value) {
                return 25;
              } else if (value.kind === _responsecache.CachedRouteKind.REDIRECT) {
                return JSON.stringify(value.props).length;
              } else if (value.kind === _responsecache.CachedRouteKind.IMAGE) {
                throw new Error("invariant image should not be incremental-cache");
              } else if (value.kind === _responsecache.CachedRouteKind.FETCH) {
                return JSON.stringify(value.data || "").length;
              } else if (value.kind === _responsecache.CachedRouteKind.APP_ROUTE) {
                return value.body.length;
              }
              return value.html.length + (((_JSON_stringify = JSON.stringify(value.kind === _responsecache.CachedRouteKind.APP_PAGE ? value.rscData : value.pageData)) == null ? void 0 : _JSON_stringify.length) || 0);
            });
          }
        } else {
          if (DEBUG) {
            console.log("not using memory store for fetch cache");
          }
        }
      }
      resetRequestCache() {
        memoryCache == null ? void 0 : memoryCache.reset();
      }
      async revalidateTag(...args) {
        let [tags] = args;
        tags = typeof tags === "string" ? [
          tags
        ] : tags;
        if (DEBUG) {
          console.log("revalidateTag", tags);
        }
        if (!tags.length)
          return;
        if (Date.now() < rateLimitedUntil) {
          if (DEBUG) {
            console.log("rate limited ", rateLimitedUntil);
          }
          return;
        }
        for (let i = 0; i < Math.ceil(tags.length / 64); i++) {
          const currentTags = tags.slice(i * 64, i * 64 + 64);
          try {
            const res = await fetchRetryWithTimeout(`${this.cacheEndpoint}/v1/suspense-cache/revalidate?tags=${currentTags.map((tag) => encodeURIComponent(tag)).join(",")}`, {
              method: "POST",
              headers: this.headers,
              // @ts-expect-error not on public type
              next: {
                internal: true
              }
            });
            if (res.status === 429) {
              const retryAfter = res.headers.get("retry-after") || "60000";
              rateLimitedUntil = Date.now() + parseInt(retryAfter);
            }
            if (!res.ok) {
              throw new Error(`Request failed with status ${res.status}.`);
            }
          } catch (err) {
            console.warn(`Failed to revalidate tag`, currentTags, err);
          }
        }
      }
      async get(...args) {
        var _data_value;
        const [key, ctx] = args;
        const { tags, softTags, kind: kindHint, fetchIdx, fetchUrl } = ctx;
        if (kindHint !== _responsecache.IncrementalCacheKind.FETCH) {
          return null;
        }
        if (Date.now() < rateLimitedUntil) {
          if (DEBUG) {
            console.log("rate limited");
          }
          return null;
        }
        let data = memoryCache == null ? void 0 : memoryCache.get(key);
        const hasFetchKindAndMatchingTags = (data == null ? void 0 : (_data_value = data.value) == null ? void 0 : _data_value.kind) === _responsecache.CachedRouteKind.FETCH && this.hasMatchingTags(tags ?? [], data.value.tags ?? []);
        if (this.cacheEndpoint && (!data || !hasFetchKindAndMatchingTags)) {
          try {
            const start = Date.now();
            const fetchParams = {
              internal: true,
              fetchType: "cache-get",
              fetchUrl,
              fetchIdx
            };
            const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${key}`, {
              method: "GET",
              headers: {
                ...this.headers,
                [CACHE_FETCH_URL_HEADER]: fetchUrl,
                [CACHE_TAGS_HEADER]: (tags == null ? void 0 : tags.join(",")) || "",
                [_constants.NEXT_CACHE_SOFT_TAGS_HEADER]: (softTags == null ? void 0 : softTags.join(",")) || ""
              },
              next: fetchParams
            });
            if (res.status === 429) {
              const retryAfter = res.headers.get("retry-after") || "60000";
              rateLimitedUntil = Date.now() + parseInt(retryAfter);
            }
            if (res.status === 404) {
              if (DEBUG) {
                console.log(`no fetch cache entry for ${key}, duration: ${Date.now() - start}ms`);
              }
              return null;
            }
            if (!res.ok) {
              console.error(await res.text());
              throw new Error(`invalid response from cache ${res.status}`);
            }
            const cached = await res.json();
            if (!cached || cached.kind !== _responsecache.CachedRouteKind.FETCH) {
              DEBUG && console.log({
                cached
              });
              throw new Error("invalid cache value");
            }
            if (cached.kind === _responsecache.CachedRouteKind.FETCH) {
              cached.tags ??= [];
              for (const tag of tags ?? []) {
                if (!cached.tags.includes(tag)) {
                  cached.tags.push(tag);
                }
              }
            }
            const cacheState = res.headers.get(CACHE_STATE_HEADER);
            const age = res.headers.get("age");
            data = {
              value: cached,
              // if it's already stale set it to a time in the past
              // if not derive last modified from age
              lastModified: cacheState !== "fresh" ? Date.now() - _constants.CACHE_ONE_YEAR : Date.now() - parseInt(age || "0", 10) * 1e3
            };
            if (DEBUG) {
              console.log(`got fetch cache entry for ${key}, duration: ${Date.now() - start}ms, size: ${Object.keys(cached).length}, cache-state: ${cacheState} tags: ${tags == null ? void 0 : tags.join(",")} softTags: ${softTags == null ? void 0 : softTags.join(",")}`);
            }
            if (data) {
              memoryCache == null ? void 0 : memoryCache.set(key, data);
            }
          } catch (err) {
            if (DEBUG) {
              console.error(`Failed to get from fetch-cache`, err);
            }
          }
        }
        return data || null;
      }
      async set(...args) {
        const [key, data, ctx] = args;
        const { fetchCache, fetchIdx, fetchUrl, tags } = ctx;
        if (!fetchCache)
          return;
        if (Date.now() < rateLimitedUntil) {
          if (DEBUG) {
            console.log("rate limited");
          }
          return;
        }
        memoryCache == null ? void 0 : memoryCache.set(key, {
          value: data,
          lastModified: Date.now()
        });
        if (this.cacheEndpoint) {
          try {
            const start = Date.now();
            if (data !== null && "revalidate" in data) {
              this.headers[CACHE_REVALIDATE_HEADER] = data.revalidate.toString();
            }
            if (!this.headers[CACHE_REVALIDATE_HEADER] && data !== null && "data" in data) {
              this.headers[CACHE_CONTROL_VALUE_HEADER] = data.data.headers["cache-control"];
            }
            const body = JSON.stringify({
              ...data,
              // we send the tags in the header instead
              // of in the body here
              tags: void 0
            });
            if (DEBUG) {
              console.log("set cache", key);
            }
            const fetchParams = {
              internal: true,
              fetchType: "cache-set",
              fetchUrl,
              fetchIdx
            };
            const res = await fetch(`${this.cacheEndpoint}/v1/suspense-cache/${key}`, {
              method: "POST",
              headers: {
                ...this.headers,
                [CACHE_FETCH_URL_HEADER]: fetchUrl || "",
                [CACHE_TAGS_HEADER]: (tags == null ? void 0 : tags.join(",")) || ""
              },
              body,
              next: fetchParams
            });
            if (res.status === 429) {
              const retryAfter = res.headers.get("retry-after") || "60000";
              rateLimitedUntil = Date.now() + parseInt(retryAfter);
            }
            if (!res.ok) {
              DEBUG && console.log(await res.text());
              throw new Error(`invalid response ${res.status}`);
            }
            if (DEBUG) {
              console.log(`successfully set to fetch-cache for ${key}, duration: ${Date.now() - start}ms, size: ${body.length}`);
            }
          } catch (err) {
            if (DEBUG) {
              console.error(`Failed to update fetch cache`, err);
            }
          }
        }
        return;
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/tags-manifest.external.js
var require_tags_manifest_external = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/tags-manifest.external.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      isTagStale: function() {
        return isTagStale;
      },
      tagsManifest: function() {
        return tagsManifest;
      }
    });
    var tagsManifest = {
      items: {}
    };
    var isTagStale = (tags, timestamp) => {
      for (const tag of tags) {
        const tagEntry = tagsManifest.items[tag];
        if (typeof (tagEntry == null ? void 0 : tagEntry.revalidatedAt) === "number" && // TODO: use performance.now and update file-system-cache?
        tagEntry.revalidatedAt >= timestamp) {
          return true;
        }
      }
      return false;
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/file-system-cache.js
var require_file_system_cache = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/file-system-cache.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return FileSystemCache;
      }
    });
    var _responsecache = require_response_cache();
    var _lrucache = require_lru_cache();
    var _path = /* @__PURE__ */ _interop_require_default(require_path());
    var _constants = require_constants();
    var _tagsmanifestexternal = require_tags_manifest_external();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var memoryCache;
    var FileSystemCache = class {
      constructor(ctx) {
        this.fs = ctx.fs;
        this.flushToDisk = ctx.flushToDisk;
        this.serverDistDir = ctx.serverDistDir;
        this.revalidatedTags = ctx.revalidatedTags;
        this.debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE;
        if (ctx.maxMemoryCacheSize) {
          if (!memoryCache) {
            if (this.debug) {
              console.log("using memory store for fetch cache");
            }
            memoryCache = new _lrucache.LRUCache(ctx.maxMemoryCacheSize, function length({ value }) {
              var _JSON_stringify;
              if (!value) {
                return 25;
              } else if (value.kind === _responsecache.CachedRouteKind.REDIRECT) {
                return JSON.stringify(value.props).length;
              } else if (value.kind === _responsecache.CachedRouteKind.IMAGE) {
                throw new Error("invariant image should not be incremental-cache");
              } else if (value.kind === _responsecache.CachedRouteKind.FETCH) {
                return JSON.stringify(value.data || "").length;
              } else if (value.kind === _responsecache.CachedRouteKind.APP_ROUTE) {
                return value.body.length;
              }
              return value.html.length + (((_JSON_stringify = JSON.stringify(value.kind === _responsecache.CachedRouteKind.APP_PAGE ? value.rscData : value.pageData)) == null ? void 0 : _JSON_stringify.length) || 0);
            });
          }
        } else if (this.debug) {
          console.log("not using memory store for fetch cache");
        }
      }
      resetRequestCache() {
      }
      async revalidateTag(...args) {
        let [tags] = args;
        tags = typeof tags === "string" ? [
          tags
        ] : tags;
        if (this.debug) {
          console.log("revalidateTag", tags);
        }
        if (tags.length === 0) {
          return;
        }
        for (const tag of tags) {
          const data = _tagsmanifestexternal.tagsManifest.items[tag] || {};
          data.revalidatedAt = Date.now();
          _tagsmanifestexternal.tagsManifest.items[tag] = data;
        }
      }
      async get(...args) {
        var _data_value, _data_value1, _data_value2;
        const [key, ctx] = args;
        const { tags, softTags, kind, isRoutePPREnabled, isFallback } = ctx;
        let data = memoryCache == null ? void 0 : memoryCache.get(key);
        if (this.debug) {
          console.log("get", key, tags, kind, !!data);
        }
        if (!data && true) {
          if (kind === _responsecache.IncrementalCacheKind.APP_ROUTE) {
            try {
              const filePath = this.getFilePath(`${key}.body`, _responsecache.IncrementalCacheKind.APP_ROUTE);
              const fileData = await this.fs.readFile(filePath);
              const { mtime } = await this.fs.stat(filePath);
              const meta = JSON.parse(await this.fs.readFile(filePath.replace(/\.body$/, _constants.NEXT_META_SUFFIX), "utf8"));
              const cacheEntry = {
                lastModified: mtime.getTime(),
                value: {
                  kind: _responsecache.CachedRouteKind.APP_ROUTE,
                  body: fileData,
                  headers: meta.headers,
                  status: meta.status
                }
              };
              return cacheEntry;
            } catch {
              return null;
            }
          }
          try {
            const filePath = this.getFilePath(kind === _responsecache.IncrementalCacheKind.FETCH ? key : `${key}.html`, kind);
            const fileData = await this.fs.readFile(filePath, "utf8");
            const { mtime } = await this.fs.stat(filePath);
            if (kind === _responsecache.IncrementalCacheKind.FETCH) {
              var _data_value3;
              if (!this.flushToDisk)
                return null;
              const lastModified = mtime.getTime();
              const parsedData = JSON.parse(fileData);
              data = {
                lastModified,
                value: parsedData
              };
              if (((_data_value3 = data.value) == null ? void 0 : _data_value3.kind) === _responsecache.CachedRouteKind.FETCH) {
                var _data_value4;
                const storedTags = (_data_value4 = data.value) == null ? void 0 : _data_value4.tags;
                if (!(tags == null ? void 0 : tags.every((tag) => storedTags == null ? void 0 : storedTags.includes(tag)))) {
                  if (this.debug) {
                    console.log("tags vs storedTags mismatch", tags, storedTags);
                  }
                  await this.set(key, data.value, {
                    tags,
                    isRoutePPREnabled
                  });
                }
              }
            } else if (kind === _responsecache.IncrementalCacheKind.APP_PAGE) {
              let meta;
              try {
                meta = JSON.parse(await this.fs.readFile(filePath.replace(/\.html$/, _constants.NEXT_META_SUFFIX), "utf8"));
              } catch {
              }
              let maybeSegmentData;
              if (meta == null ? void 0 : meta.segmentPaths) {
                const segmentData = {};
                maybeSegmentData = segmentData;
                const segmentsDir = key + _constants.RSC_SEGMENTS_DIR_SUFFIX;
                await Promise.all(meta.segmentPaths.map(async (segmentPath) => {
                  const segmentDataFilePath = this.getFilePath(segmentPath === "/" ? segmentsDir + "/_index" + _constants.RSC_SEGMENT_SUFFIX : segmentsDir + segmentPath + _constants.RSC_SEGMENT_SUFFIX, _responsecache.IncrementalCacheKind.APP_PAGE);
                  try {
                    segmentData[segmentPath] = await this.fs.readFile(segmentDataFilePath, "utf8");
                  } catch {
                  }
                }));
              }
              let rscData;
              if (!isFallback) {
                rscData = await this.fs.readFile(this.getFilePath(`${key}${isRoutePPREnabled ? _constants.RSC_PREFETCH_SUFFIX : _constants.RSC_SUFFIX}`, _responsecache.IncrementalCacheKind.APP_PAGE));
              }
              data = {
                lastModified: mtime.getTime(),
                value: {
                  kind: _responsecache.CachedRouteKind.APP_PAGE,
                  html: fileData,
                  rscData,
                  postponed: meta == null ? void 0 : meta.postponed,
                  headers: meta == null ? void 0 : meta.headers,
                  status: meta == null ? void 0 : meta.status,
                  segmentData: maybeSegmentData
                }
              };
            } else if (kind === _responsecache.IncrementalCacheKind.PAGES) {
              let meta;
              let pageData = {};
              if (!isFallback) {
                pageData = JSON.parse(await this.fs.readFile(this.getFilePath(`${key}${_constants.NEXT_DATA_SUFFIX}`, _responsecache.IncrementalCacheKind.PAGES), "utf8"));
              }
              data = {
                lastModified: mtime.getTime(),
                value: {
                  kind: _responsecache.CachedRouteKind.PAGES,
                  html: fileData,
                  pageData,
                  headers: meta == null ? void 0 : meta.headers,
                  status: meta == null ? void 0 : meta.status
                }
              };
            } else {
              throw new Error(`Invariant: Unexpected route kind ${kind} in file system cache.`);
            }
            if (data) {
              memoryCache == null ? void 0 : memoryCache.set(key, data);
            }
          } catch {
            return null;
          }
        }
        if ((data == null ? void 0 : (_data_value = data.value) == null ? void 0 : _data_value.kind) === _responsecache.CachedRouteKind.APP_PAGE || (data == null ? void 0 : (_data_value1 = data.value) == null ? void 0 : _data_value1.kind) === _responsecache.CachedRouteKind.PAGES) {
          var _data_value_headers;
          let cacheTags;
          const tagsHeader = (_data_value_headers = data.value.headers) == null ? void 0 : _data_value_headers[_constants.NEXT_CACHE_TAGS_HEADER];
          if (typeof tagsHeader === "string") {
            cacheTags = tagsHeader.split(",");
          }
          if (cacheTags == null ? void 0 : cacheTags.length) {
            const isStale = cacheTags.some((tag) => {
              var _tagsManifest_items_tag;
              return (_tagsmanifestexternal.tagsManifest == null ? void 0 : (_tagsManifest_items_tag = _tagsmanifestexternal.tagsManifest.items[tag]) == null ? void 0 : _tagsManifest_items_tag.revalidatedAt) && (_tagsmanifestexternal.tagsManifest == null ? void 0 : _tagsmanifestexternal.tagsManifest.items[tag].revalidatedAt) >= ((data == null ? void 0 : data.lastModified) || Date.now());
            });
            if (isStale) {
              return null;
            }
          }
        } else if ((data == null ? void 0 : (_data_value2 = data.value) == null ? void 0 : _data_value2.kind) === _responsecache.CachedRouteKind.FETCH) {
          const combinedTags = [
            ...tags || [],
            ...softTags || []
          ];
          const wasRevalidated = combinedTags.some((tag) => {
            var _tagsManifest_items_tag;
            if (this.revalidatedTags.includes(tag)) {
              return true;
            }
            return (_tagsmanifestexternal.tagsManifest == null ? void 0 : (_tagsManifest_items_tag = _tagsmanifestexternal.tagsManifest.items[tag]) == null ? void 0 : _tagsManifest_items_tag.revalidatedAt) && (_tagsmanifestexternal.tagsManifest == null ? void 0 : _tagsmanifestexternal.tagsManifest.items[tag].revalidatedAt) >= ((data == null ? void 0 : data.lastModified) || Date.now());
          });
          if (wasRevalidated) {
            data = void 0;
          }
        }
        return data ?? null;
      }
      async set(...args) {
        const [key, data, ctx] = args;
        const { isFallback } = ctx;
        memoryCache == null ? void 0 : memoryCache.set(key, {
          value: data,
          lastModified: Date.now()
        });
        if (this.debug) {
          console.log("set", key);
        }
        if (!this.flushToDisk || !data)
          return;
        if (data.kind === _responsecache.CachedRouteKind.APP_ROUTE) {
          const filePath = this.getFilePath(`${key}.body`, _responsecache.IncrementalCacheKind.APP_ROUTE);
          await this.fs.mkdir(_path.default.dirname(filePath));
          await this.fs.writeFile(filePath, data.body);
          const meta = {
            headers: data.headers,
            status: data.status,
            postponed: void 0,
            segmentPaths: void 0
          };
          await this.fs.writeFile(filePath.replace(/\.body$/, _constants.NEXT_META_SUFFIX), JSON.stringify(meta, null, 2));
        } else if (data.kind === _responsecache.CachedRouteKind.PAGES || data.kind === _responsecache.CachedRouteKind.APP_PAGE) {
          const isAppPath = data.kind === _responsecache.CachedRouteKind.APP_PAGE;
          const htmlPath = this.getFilePath(`${key}.html`, isAppPath ? _responsecache.IncrementalCacheKind.APP_PAGE : _responsecache.IncrementalCacheKind.PAGES);
          await this.fs.mkdir(_path.default.dirname(htmlPath));
          await this.fs.writeFile(htmlPath, data.html);
          if (!isFallback) {
            await this.fs.writeFile(this.getFilePath(`${key}${isAppPath ? ctx.isRoutePPREnabled ? _constants.RSC_PREFETCH_SUFFIX : _constants.RSC_SUFFIX : _constants.NEXT_DATA_SUFFIX}`, isAppPath ? _responsecache.IncrementalCacheKind.APP_PAGE : _responsecache.IncrementalCacheKind.PAGES), isAppPath ? data.rscData : JSON.stringify(data.pageData));
          }
          if ((data == null ? void 0 : data.kind) === _responsecache.CachedRouteKind.APP_PAGE) {
            const meta = {
              headers: data.headers,
              status: data.status,
              postponed: data.postponed,
              segmentPaths: void 0
            };
            await this.fs.writeFile(htmlPath.replace(/\.html$/, _constants.NEXT_META_SUFFIX), JSON.stringify(meta));
          }
        } else if (data.kind === _responsecache.CachedRouteKind.FETCH) {
          const filePath = this.getFilePath(key, _responsecache.IncrementalCacheKind.FETCH);
          await this.fs.mkdir(_path.default.dirname(filePath));
          await this.fs.writeFile(filePath, JSON.stringify({
            ...data,
            tags: ctx.tags
          }));
        }
      }
      getFilePath(pathname, kind) {
        switch (kind) {
          case _responsecache.IncrementalCacheKind.FETCH:
            return _path.default.join(this.serverDistDir, "..", "cache", "fetch-cache", pathname);
          case _responsecache.IncrementalCacheKind.PAGES:
            return _path.default.join(this.serverDistDir, "pages", pathname);
          case _responsecache.IncrementalCacheKind.IMAGE:
          case _responsecache.IncrementalCacheKind.APP_PAGE:
          case _responsecache.IncrementalCacheKind.APP_ROUTE:
            return _path.default.join(this.serverDistDir, "app", pathname);
          default:
            throw new Error(`Unexpected file path kind: ${kind}`);
        }
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/shared-revalidate-timings.js
var require_shared_revalidate_timings = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/shared-revalidate-timings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "SharedRevalidateTimings", {
      enumerable: true,
      get: function() {
        return SharedRevalidateTimings;
      }
    });
    var __;
    var _SharedRevalidateTimings = class {
      constructor(prerenderManifest) {
        this.prerenderManifest = prerenderManifest;
      }
      /**
      * Try to get the revalidate timings for a route. This will first try to get
      * the timings from the in-memory cache. If the timings are not present in the
      * in-memory cache, then the timings will be sourced from the prerender
      * manifest.
      *
      * @param route the route to get the revalidate timings for
      * @returns the revalidate timings for the route, or undefined if the timings
      *          are not present in the in-memory cache or the prerender manifest
      */
      get(route) {
        var _this_prerenderManifest_routes_route, _this_prerenderManifest_dynamicRoutes_route;
        let revalidate = _SharedRevalidateTimings.timings.get(route);
        if (typeof revalidate !== "undefined")
          return revalidate;
        revalidate = (_this_prerenderManifest_routes_route = this.prerenderManifest.routes[route]) == null ? void 0 : _this_prerenderManifest_routes_route.initialRevalidateSeconds;
        if (typeof revalidate !== "undefined")
          return revalidate;
        revalidate = (_this_prerenderManifest_dynamicRoutes_route = this.prerenderManifest.dynamicRoutes[route]) == null ? void 0 : _this_prerenderManifest_dynamicRoutes_route.fallbackRevalidate;
        if (typeof revalidate !== "undefined")
          return revalidate;
        return void 0;
      }
      /**
      * Set the revalidate timings for a route.
      *
      * @param route the route to set the revalidate timings for
      * @param revalidate the revalidate timings for the route
      */
      set(route, revalidate) {
        _SharedRevalidateTimings.timings.set(route, revalidate);
      }
      /**
      * Clear the in-memory cache of revalidate timings for routes.
      */
      clear() {
        _SharedRevalidateTimings.timings.clear();
      }
    };
    var SharedRevalidateTimings = _SharedRevalidateTimings;
    __ = new WeakMap();
    __privateAdd(
      SharedRevalidateTimings,
      __,
      /**
      * The in-memory cache of revalidate timings for routes. This cache is
      * populated when the cache is updated with new timings.
      */
      _SharedRevalidateTimings.timings = /* @__PURE__ */ new Map()
    );
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/index.js
var require_incremental_cache = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/incremental-cache/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      CacheHandler: function() {
        return CacheHandler;
      },
      IncrementalCache: function() {
        return IncrementalCache;
      }
    });
    var _responsecache = require_response_cache();
    var _cachescopeexternal = require_cache_scope_external();
    var _fetchcache = /* @__PURE__ */ _interop_require_default(require_fetch_cache());
    var _filesystemcache = /* @__PURE__ */ _interop_require_default(require_file_system_cache());
    var _normalizepagepath = require_normalize_page_path();
    var _constants = require_constants();
    var _toroute = require_to_route();
    var _sharedrevalidatetimings = require_shared_revalidate_timings();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var CacheHandler = class {
      // eslint-disable-next-line
      constructor(_ctx) {
      }
      async get(..._args) {
        return {};
      }
      async set(..._args) {
      }
      async revalidateTag(..._args) {
      }
      resetRequestCache() {
      }
    };
    var IncrementalCache = class {
      constructor({ fs, dev, dynamicIO, flushToDisk, fetchCache, minimalMode, serverDistDir, requestHeaders, requestProtocol, maxMemoryCacheSize, getPrerenderManifest, fetchCacheKeyPrefix, CurCacheHandler, allowedRevalidateHeaderKeys }) {
        var _this_prerenderManifest_preview, _this_prerenderManifest, _this_prerenderManifest_preview1, _this_prerenderManifest1;
        this.locks = /* @__PURE__ */ new Map();
        const debug = !!process.env.NEXT_PRIVATE_DEBUG_CACHE;
        this.hasCustomCacheHandler = Boolean(CurCacheHandler);
        const cacheHandlersSymbol = Symbol.for("@next/cache-handlers");
        const _globalThis = globalThis;
        if (!CurCacheHandler) {
          const globalCacheHandler = _globalThis[cacheHandlersSymbol];
          if (globalCacheHandler == null ? void 0 : globalCacheHandler.FetchCache) {
            CurCacheHandler = globalCacheHandler.FetchCache;
          } else {
            if (fs && serverDistDir) {
              if (debug) {
                console.log("using filesystem cache handler");
              }
              CurCacheHandler = _filesystemcache.default;
            }
            if (_fetchcache.default.isAvailable({
              _requestHeaders: requestHeaders
            }) && minimalMode && fetchCache) {
              if (debug) {
                console.log("using fetch cache handler");
              }
              CurCacheHandler = _fetchcache.default;
            }
          }
        } else if (debug) {
          console.log("using custom cache handler", CurCacheHandler.name);
        }
        if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {
          maxMemoryCacheSize = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10);
        }
        this.dev = dev;
        this.hasDynamicIO = dynamicIO;
        this.disableForTestmode = process.env.NEXT_PRIVATE_TEST_PROXY === "true";
        const minimalModeKey = "minimalMode";
        this[minimalModeKey] = minimalMode;
        this.requestHeaders = requestHeaders;
        this.requestProtocol = requestProtocol;
        this.allowedRevalidateHeaderKeys = allowedRevalidateHeaderKeys;
        this.prerenderManifest = getPrerenderManifest();
        this.revalidateTimings = new _sharedrevalidatetimings.SharedRevalidateTimings(this.prerenderManifest);
        this.fetchCacheKeyPrefix = fetchCacheKeyPrefix;
        let revalidatedTags = [];
        if (requestHeaders[_constants.PRERENDER_REVALIDATE_HEADER] === ((_this_prerenderManifest = this.prerenderManifest) == null ? void 0 : (_this_prerenderManifest_preview = _this_prerenderManifest.preview) == null ? void 0 : _this_prerenderManifest_preview.previewModeId)) {
          this.isOnDemandRevalidate = true;
        }
        if (minimalMode && typeof requestHeaders[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER] === "string" && requestHeaders[_constants.NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER] === ((_this_prerenderManifest1 = this.prerenderManifest) == null ? void 0 : (_this_prerenderManifest_preview1 = _this_prerenderManifest1.preview) == null ? void 0 : _this_prerenderManifest_preview1.previewModeId)) {
          revalidatedTags = requestHeaders[_constants.NEXT_CACHE_REVALIDATED_TAGS_HEADER].split(",");
        }
        if (CurCacheHandler) {
          this.cacheHandler = new CurCacheHandler({
            dev,
            fs,
            flushToDisk,
            serverDistDir,
            revalidatedTags,
            maxMemoryCacheSize,
            _requestHeaders: requestHeaders,
            fetchCacheKeyPrefix
          });
        }
      }
      calculateRevalidate(pathname, fromTime, dev, isFallback) {
        if (dev)
          return Math.floor(performance.timeOrigin + performance.now() - 1e3);
        const initialRevalidateSeconds = this.revalidateTimings.get((0, _toroute.toRoute)(pathname)) ?? (isFallback ? false : 1);
        const revalidateAfter = typeof initialRevalidateSeconds === "number" ? initialRevalidateSeconds * 1e3 + fromTime : initialRevalidateSeconds;
        return revalidateAfter;
      }
      _getPathname(pathname, fetchCache) {
        return fetchCache ? pathname : (0, _normalizepagepath.normalizePagePath)(pathname);
      }
      resetRequestCache() {
        var _this_cacheHandler_resetRequestCache, _this_cacheHandler;
        (_this_cacheHandler = this.cacheHandler) == null ? void 0 : (_this_cacheHandler_resetRequestCache = _this_cacheHandler.resetRequestCache) == null ? void 0 : _this_cacheHandler_resetRequestCache.call(_this_cacheHandler);
      }
      async lock(cacheKey) {
        let unlockNext = () => Promise.resolve();
        const existingLock = this.locks.get(cacheKey);
        if (existingLock) {
          await existingLock;
        }
        const newLock = new Promise((resolve) => {
          unlockNext = async () => {
            resolve();
            this.locks.delete(cacheKey);
          };
        });
        this.locks.set(cacheKey, newLock);
        return unlockNext;
      }
      async revalidateTag(tags) {
        var _this_cacheHandler_revalidateTag, _this_cacheHandler;
        return (_this_cacheHandler = this.cacheHandler) == null ? void 0 : (_this_cacheHandler_revalidateTag = _this_cacheHandler.revalidateTag) == null ? void 0 : _this_cacheHandler_revalidateTag.call(_this_cacheHandler, tags);
      }
      // x-ref: https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/react/src/ReactFetch.js#L23
      async generateCacheKey(url, init = {}) {
        const MAIN_KEY_PREFIX = "v3";
        const bodyChunks = [];
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        if (init.body) {
          if (typeof init.body.getReader === "function") {
            const readableBody = init.body;
            const chunks = [];
            try {
              await readableBody.pipeTo(new WritableStream({
                write(chunk) {
                  if (typeof chunk === "string") {
                    chunks.push(encoder.encode(chunk));
                    bodyChunks.push(chunk);
                  } else {
                    chunks.push(chunk);
                    bodyChunks.push(decoder.decode(chunk, {
                      stream: true
                    }));
                  }
                }
              }));
              bodyChunks.push(decoder.decode());
              const length = chunks.reduce((total, arr) => total + arr.length, 0);
              const arrayBuffer = new Uint8Array(length);
              let offset = 0;
              for (const chunk of chunks) {
                arrayBuffer.set(chunk, offset);
                offset += chunk.length;
              }
              init._ogBody = arrayBuffer;
            } catch (err) {
              console.error("Problem reading body", err);
            }
          } else if (typeof init.body.keys === "function") {
            const formData = init.body;
            init._ogBody = init.body;
            for (const key of /* @__PURE__ */ new Set([
              ...formData.keys()
            ])) {
              const values = formData.getAll(key);
              bodyChunks.push(`${key}=${(await Promise.all(values.map(async (val) => {
                if (typeof val === "string") {
                  return val;
                } else {
                  return await val.text();
                }
              }))).join(",")}`);
            }
          } else if (typeof init.body.arrayBuffer === "function") {
            const blob = init.body;
            const arrayBuffer = await blob.arrayBuffer();
            bodyChunks.push(await blob.text());
            init._ogBody = new Blob([
              arrayBuffer
            ], {
              type: blob.type
            });
          } else if (typeof init.body === "string") {
            bodyChunks.push(init.body);
            init._ogBody = init.body;
          }
        }
        const headers = typeof (init.headers || {}).keys === "function" ? Object.fromEntries(init.headers) : Object.assign({}, init.headers);
        if ("traceparent" in headers)
          delete headers["traceparent"];
        const cacheString = JSON.stringify([
          MAIN_KEY_PREFIX,
          this.fetchCacheKeyPrefix || "",
          url,
          init.method,
          headers,
          init.mode,
          init.redirect,
          init.credentials,
          init.referrer,
          init.referrerPolicy,
          init.integrity,
          init.cache,
          bodyChunks
        ]);
        if (false) {
          let bufferToHex = function(buffer2) {
            return Array.prototype.map.call(new Uint8Array(buffer2), (b) => b.toString(16).padStart(2, "0")).join("");
          };
          const buffer = encoder.encode(cacheString);
          return bufferToHex(await crypto.subtle.digest("SHA-256", buffer));
        } else {
          const crypto1 = require("crypto");
          return crypto1.createHash("sha256").update(cacheString).digest("hex");
        }
      }
      // get data from cache if available
      async get(cacheKey, ctx) {
        var _this_cacheHandler, _cacheData_value;
        if (this.hasDynamicIO && ctx.kind === _responsecache.IncrementalCacheKind.FETCH) {
          const cacheScope = _cachescopeexternal.cacheScopeAsyncLocalStorage.getStore();
          if (cacheScope) {
            const memoryCacheData = cacheScope.cache.get(cacheKey);
            if ((memoryCacheData == null ? void 0 : memoryCacheData.kind) === _responsecache.CachedRouteKind.FETCH) {
              return {
                isStale: false,
                value: memoryCacheData,
                revalidateAfter: false,
                isFallback: false
              };
            }
          }
        }
        if (this.disableForTestmode || this.dev && (ctx.kind !== _responsecache.IncrementalCacheKind.FETCH || this.requestHeaders["cache-control"] === "no-cache")) {
          return null;
        }
        const { isFallback } = ctx;
        cacheKey = this._getPathname(cacheKey, ctx.kind === _responsecache.IncrementalCacheKind.FETCH);
        let entry = null;
        let revalidate = ctx.revalidate;
        const cacheData = await ((_this_cacheHandler = this.cacheHandler) == null ? void 0 : _this_cacheHandler.get(cacheKey, ctx));
        if ((cacheData == null ? void 0 : (_cacheData_value = cacheData.value) == null ? void 0 : _cacheData_value.kind) === _responsecache.CachedRouteKind.FETCH) {
          const combinedTags = [
            ...ctx.tags || [],
            ...ctx.softTags || []
          ];
          if (combinedTags.some((tag) => {
            var _this_revalidatedTags;
            return (_this_revalidatedTags = this.revalidatedTags) == null ? void 0 : _this_revalidatedTags.includes(tag);
          })) {
            return null;
          }
          revalidate = revalidate || cacheData.value.revalidate;
          const age = (performance.timeOrigin + performance.now() - (cacheData.lastModified || 0)) / 1e3;
          const isStale2 = age > revalidate;
          const data = cacheData.value.data;
          return {
            isStale: isStale2,
            value: {
              kind: _responsecache.CachedRouteKind.FETCH,
              data,
              revalidate
            },
            revalidateAfter: performance.timeOrigin + performance.now() + revalidate * 1e3,
            isFallback
          };
        }
        const curRevalidate = this.revalidateTimings.get((0, _toroute.toRoute)(cacheKey));
        let isStale;
        let revalidateAfter;
        if ((cacheData == null ? void 0 : cacheData.lastModified) === -1) {
          isStale = -1;
          revalidateAfter = -1 * _constants.CACHE_ONE_YEAR;
        } else {
          revalidateAfter = this.calculateRevalidate(cacheKey, (cacheData == null ? void 0 : cacheData.lastModified) || performance.timeOrigin + performance.now(), this.dev ? ctx.kind !== _responsecache.IncrementalCacheKind.FETCH : false, ctx.isFallback);
          isStale = revalidateAfter !== false && revalidateAfter < performance.timeOrigin + performance.now() ? true : void 0;
        }
        if (cacheData) {
          entry = {
            isStale,
            curRevalidate,
            revalidateAfter,
            value: cacheData.value,
            isFallback
          };
        }
        if (!cacheData && this.prerenderManifest.notFoundRoutes.includes(cacheKey)) {
          entry = {
            isStale,
            value: null,
            curRevalidate,
            revalidateAfter,
            isFallback
          };
          this.set(cacheKey, entry.value, ctx);
        }
        return entry;
      }
      // populate the incremental cache with new data
      async set(pathname, data, ctx) {
        if (this.hasDynamicIO && (data == null ? void 0 : data.kind) === _responsecache.CachedRouteKind.FETCH) {
          const cacheScope = _cachescopeexternal.cacheScopeAsyncLocalStorage.getStore();
          if (cacheScope) {
            cacheScope.cache.set(pathname, data);
          }
        }
        if (this.disableForTestmode || this.dev && !ctx.fetchCache)
          return;
        pathname = this._getPathname(pathname, ctx.fetchCache);
        const itemSize = JSON.stringify(data).length;
        if (ctx.fetchCache && // we don't show this error/warning when a custom cache handler is being used
        // as it might not have this limit
        !this.hasCustomCacheHandler && itemSize > 2 * 1024 * 1024) {
          if (this.dev) {
            throw new Error(`Failed to set Next.js data cache, items over 2MB can not be cached (${itemSize} bytes)`);
          }
          return;
        }
        try {
          var _this_cacheHandler;
          if (typeof ctx.revalidate !== "undefined" && !ctx.fetchCache) {
            this.revalidateTimings.set((0, _toroute.toRoute)(pathname), ctx.revalidate);
          }
          await ((_this_cacheHandler = this.cacheHandler) == null ? void 0 : _this_cacheHandler.set(pathname, data, ctx));
        } catch (error) {
          console.warn("Failed to update prerender cache for", pathname, error);
        }
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/setup-http-agent-env.js
var require_setup_http_agent_env = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/setup-http-agent-env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "setHttpClientAndAgentOptions", {
      enumerable: true,
      get: function() {
        return setHttpClientAndAgentOptions;
      }
    });
    var _http = require("http");
    var _https = require("https");
    function setHttpClientAndAgentOptions(config) {
      if (globalThis.__NEXT_HTTP_AGENT) {
        return;
      }
      if (!config) {
        throw new Error("Expected config.httpAgentOptions to be an object");
      }
      globalThis.__NEXT_HTTP_AGENT_OPTIONS = config.httpAgentOptions;
      globalThis.__NEXT_HTTP_AGENT = new _http.Agent(config.httpAgentOptions);
      globalThis.__NEXT_HTTPS_AGENT = new _https.Agent(config.httpAgentOptions);
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-matches/pages-api-route-match.js
var require_pages_api_route_match = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-matches/pages-api-route-match.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isPagesAPIRouteMatch", {
      enumerable: true,
      get: function() {
        return isPagesAPIRouteMatch;
      }
    });
    var _routekind = require_route_kind();
    function isPagesAPIRouteMatch(match) {
      return match.definition.kind === _routekind.RouteKind.PAGES_API;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/module-loader/node-module-loader.js
var require_node_module_loader = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/module-loader/node-module-loader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NodeModuleLoader", {
      enumerable: true,
      get: function() {
        return NodeModuleLoader;
      }
    });
    var NodeModuleLoader = class {
      async load(id) {
        if (true) {
          return await (true ? require(id) : require(id));
        }
        throw new Error("NodeModuleLoader is not supported in edge runtime.");
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/lib/module-loader/route-module-loader.js
var require_route_module_loader = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/lib/module-loader/route-module-loader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "RouteModuleLoader", {
      enumerable: true,
      get: function() {
        return RouteModuleLoader;
      }
    });
    var _nodemoduleloader = require_node_module_loader();
    var RouteModuleLoader = class {
      static async load(id, loader = new _nodemoduleloader.NodeModuleLoader()) {
        const module2 = await loader.load(id);
        if ("routeModule" in module2) {
          return module2.routeModule;
        }
        throw new Error(`Module "${id}" does not export a routeModule.`);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-modules/app-page/module.render.js
var require_module_render = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-modules/app-page/module.render.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "lazyRenderAppPage", {
      enumerable: true,
      get: function() {
        return lazyRenderAppPage;
      }
    });
    var lazyRenderAppPage = (...args) => {
      if (true) {
        throw new Error("Can't use lazyRenderAppPage in minimal mode");
      } else {
        const render = null.renderToHTMLOrFlight;
        return render(...args);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/route-modules/pages/module.render.js
var require_module_render2 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/route-modules/pages/module.render.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "lazyRenderPagesPage", {
      enumerable: true,
      get: function() {
        return lazyRenderPagesPage;
      }
    });
    var lazyRenderPagesPage = (...args) => {
      if (true) {
        throw new Error("Can't use lazyRenderPagesPage in minimal mode");
      } else {
        const render = null.renderToHTML;
        return render(...args);
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/format-dynamic-import-path.js
var require_format_dynamic_import_path = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/format-dynamic-import-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "formatDynamicImportPath", {
      enumerable: true,
      get: function() {
        return formatDynamicImportPath;
      }
    });
    var _path = /* @__PURE__ */ _interop_require_default(require("path"));
    var _url = require("url");
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var formatDynamicImportPath = (dir, filePath) => {
      const absoluteFilePath = _path.default.isAbsolute(filePath) ? filePath : _path.default.join(dir, filePath);
      const formattedFilePath = (0, _url.pathToFileURL)(absoluteFilePath).toString();
      return formattedFilePath;
    };
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/generate-interception-routes-rewrites.js
var require_generate_interception_routes_rewrites = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/generate-interception-routes-rewrites.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      generateInterceptionRoutesRewrites: function() {
        return generateInterceptionRoutesRewrites;
      },
      isInterceptionRouteRewrite: function() {
        return isInterceptionRouteRewrite;
      }
    });
    var _pathtoregexp = require_path_to_regexp();
    var _approuterheaders = require_app_router_headers();
    var _interceptionroutes = require_interception_routes();
    function toPathToRegexpPath(path) {
      return path.replace(/\[\[?([^\]]+)\]\]?/g, (_, capture) => {
        const paramName = capture.replace(/\W+/g, "_");
        if (paramName.startsWith("...")) {
          return `:${paramName.slice(3)}*`;
        }
        return ":" + paramName;
      });
    }
    function generateInterceptionRoutesRewrites(appPaths, basePath = "") {
      const rewrites = [];
      for (const appPath of appPaths) {
        if ((0, _interceptionroutes.isInterceptionRouteAppPath)(appPath)) {
          const { interceptingRoute, interceptedRoute } = (0, _interceptionroutes.extractInterceptionRouteInformation)(appPath);
          const normalizedInterceptingRoute = `${interceptingRoute !== "/" ? toPathToRegexpPath(interceptingRoute) : ""}/(.*)?`;
          const normalizedInterceptedRoute = toPathToRegexpPath(interceptedRoute);
          const normalizedAppPath = toPathToRegexpPath(appPath);
          let interceptingRouteRegex = (0, _pathtoregexp.pathToRegexp)(normalizedInterceptingRoute).toString().slice(2, -3);
          rewrites.push({
            source: `${basePath}${normalizedInterceptedRoute}`,
            destination: `${basePath}${normalizedAppPath}`,
            has: [
              {
                type: "header",
                key: _approuterheaders.NEXT_URL,
                value: interceptingRouteRegex
              }
            ]
          });
        }
      }
      return rewrites;
    }
    function isInterceptionRouteRewrite(route) {
      var _route_has_, _route_has;
      return ((_route_has = route.has) == null ? void 0 : (_route_has_ = _route_has[0]) == null ? void 0 : _route_has_.key) === _approuterheaders.NEXT_URL;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/format-server-error.js
var require_format_server_error = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/format-server-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      formatServerError: function() {
        return formatServerError;
      },
      getStackWithoutErrorMessage: function() {
        return getStackWithoutErrorMessage;
      }
    });
    var invalidServerComponentReactHooks = [
      "useDeferredValue",
      "useEffect",
      "useImperativeHandle",
      "useInsertionEffect",
      "useLayoutEffect",
      "useReducer",
      "useRef",
      "useState",
      "useSyncExternalStore",
      "useTransition",
      "experimental_useOptimistic",
      "useOptimistic"
    ];
    function setMessage(error, message) {
      error.message = message;
      if (error.stack) {
        const lines = error.stack.split("\n");
        lines[0] = message;
        error.stack = lines.join("\n");
      }
    }
    function getStackWithoutErrorMessage(error) {
      const stack = error.stack;
      if (!stack)
        return "";
      return stack.replace(/^[^\n]*\n/, "");
    }
    function formatServerError(error) {
      if (typeof (error == null ? void 0 : error.message) !== "string")
        return;
      if (error.message.includes("Class extends value undefined is not a constructor or null")) {
        const addedMessage = "This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component";
        if (error.message.includes(addedMessage))
          return;
        setMessage(error, `${error.message}

${addedMessage}`);
        return;
      }
      if (error.message.includes("createContext is not a function")) {
        setMessage(error, 'createContext only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component');
        return;
      }
      for (const clientHook of invalidServerComponentReactHooks) {
        const regex = new RegExp(`\\b${clientHook}\\b.*is not a function`);
        if (regex.test(error.message)) {
          setMessage(error, `${clientHook} only works in Client Components. Add the "use client" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`);
          return;
        }
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/compiled/@mswjs/interceptors/ClientRequest/index.js
var require_ClientRequest = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/compiled/@mswjs/interceptors/ClientRequest/index.js"(exports, module) {
    (function() {
      var e = { 501: function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        function _interopRequireDefault(e3) {
          return e3 && e3.__esModule ? e3 : { default: e3 };
        }
        var n = r2(858);
        var s = r2(331);
        var i = r2(685);
        var o = _interopRequireDefault(i);
        var a = r2(687);
        var u = _interopRequireDefault(a);
        var c = r2(362);
        var l = r2(984);
        var f = new (0, l.Logger)("utils getUrlByRequestOptions");
        function normalizeClientRequestEndArgs(...e3) {
          f.info("arguments", e3);
          const t3 = new Array(3).fill(null).map((t4, r3) => e3[r3] || t4);
          t3.sort((e4, r3) => {
            if (typeof e4 === "function") {
              return 1;
            }
            if (typeof r3 === "function") {
              return -1;
            }
            if (typeof e4 === "string" && typeof r3 === "string") {
              return t3.indexOf(e4) - t3.indexOf(r3);
            }
            return 0;
          });
          f.info("normalized args", t3);
          return t3;
        }
        var h = new (0, l.Logger)("http normalizeWriteArgs");
        function normalizeClientRequestWriteArgs(e3) {
          h.info("normalizing ClientRequest.write arguments...", e3);
          const t3 = e3[0];
          const r3 = typeof e3[1] === "string" ? e3[1] : void 0;
          const n2 = typeof e3[1] === "function" ? e3[1] : e3[2];
          const s2 = [t3, r3, n2];
          h.info("successfully normalized ClientRequest.write arguments:", s2);
          return s2;
        }
        var p = r2(781);
        var d = Symbol("isClone");
        function cloneIncomingMessage(e3) {
          const t3 = e3.pipe(new (0, p.PassThrough)());
          inheritProperties(e3, t3);
          const r3 = Object.create(i.IncomingMessage.prototype);
          getPrototypes(t3).forEach((e4) => {
            inheritProperties(e4, r3);
          });
          Object.setPrototypeOf(t3, r3);
          Object.defineProperty(t3, d, { enumerable: true, value: true });
          return t3;
        }
        function getPrototypes(e3) {
          const t3 = [];
          let r3 = e3;
          while (r3 = Object.getPrototypeOf(r3)) {
            t3.push(r3);
          }
          return t3;
        }
        function inheritProperties(e3, t3) {
          const r3 = [...Object.getOwnPropertyNames(e3), ...Object.getOwnPropertySymbols(e3)];
          for (const n2 of r3) {
            if (t3.hasOwnProperty(n2)) {
              continue;
            }
            const r4 = Object.getOwnPropertyDescriptor(e3, n2);
            if (!r4) {
              continue;
            }
            Object.defineProperty(t3, n2, r4);
          }
        }
        var g = r2(426);
        function createResponse(e3) {
          const t3 = new ReadableStream({ start(t4) {
            e3.on("data", (e4) => t4.enqueue(e4));
            e3.on("end", () => t4.close());
          } });
          return new Response(t3, { status: e3.statusCode, statusText: e3.statusMessage, headers: g.objectToHeaders.call(void 0, e3.headers) });
        }
        function createRequest(e3) {
          const t3 = new (0, g.Headers)();
          const r3 = e3.getHeaders();
          for (const e4 in r3) {
            const n3 = r3[e4];
            if (!n3) {
              continue;
            }
            const s2 = Array.prototype.concat([], n3);
            for (const r4 of s2) {
              t3.append(e4, r4.toString());
            }
          }
          const n2 = e3.method || "GET";
          return new Request(e3.url, { method: n2, headers: t3, credentials: "same-origin", body: n2 === "HEAD" || n2 === "GET" ? null : e3.requestBuffer });
        }
        var m = r2(642);
        var v = class extends i.ClientRequest {
          constructor([e3, t3, r3], n2) {
            super(t3, r3);
            this.chunks = [];
            this.responseSource = "mock";
            this.logger = n2.logger.extend(`request ${t3.method} ${e3.href}`);
            this.logger.info("constructing ClientRequest using options:", { url: e3, requestOptions: t3, callback: r3 });
            this.url = e3;
            this.emitter = n2.emitter;
            this.requestBuffer = null;
            this.response = new (0, i.IncomingMessage)(this.socket);
          }
          writeRequestBodyChunk(e3, t3) {
            if (e3 == null) {
              return;
            }
            if (this.requestBuffer == null) {
              this.requestBuffer = Buffer.from([]);
            }
            const r3 = Buffer.isBuffer(e3) ? e3 : Buffer.from(e3, t3);
            this.requestBuffer = Buffer.concat([this.requestBuffer, r3]);
          }
          write(...e3) {
            var t3;
            const [r3, n2, s2] = normalizeClientRequestWriteArgs(e3);
            this.logger.info("write:", { chunk: r3, encoding: n2, callback: s2 });
            this.chunks.push({ chunk: r3, encoding: n2 });
            this.writeRequestBodyChunk(r3, n2);
            this.logger.info("chunk successfully stored!", (t3 = this.requestBuffer) == null ? void 0 : t3.byteLength);
            if (!r3 || r3.length === 0) {
              this.logger.info("written chunk is empty, skipping callback...");
            } else {
              s2 == null ? void 0 : s2();
            }
            return true;
          }
          end(...e3) {
            this.logger.info("end", e3);
            const t3 = n.uuidv4.call(void 0);
            const [r3, s2, i2] = normalizeClientRequestEndArgs(...e3);
            this.logger.info("normalized arguments:", { chunk: r3, encoding: s2, callback: i2 });
            this.writeRequestBodyChunk(r3, s2 || void 0);
            const o2 = createRequest(this);
            const a2 = n.toInteractiveRequest.call(void 0, o2);
            if (this.getHeader("X-Request-Id") != null) {
              this.removeHeader("X-Request-Id");
              return this.passthrough(r3, s2, i2);
            }
            this.logger.info('emitting the "request" event for %d listener(s)...', this.emitter.listenerCount("request"));
            this.emitter.emit("request", { request: a2, requestId: t3 });
            c.until.call(void 0, async () => {
              await this.emitter.untilIdle("request", ({ args: [{ requestId: e5 }] }) => e5 === t3);
              const [e4] = await a2.respondWith.invoked();
              this.logger.info("event.respondWith called with:", e4);
              return e4;
            }).then((e4) => {
              this.logger.info("the listeners promise awaited!");
              if (!this.headersSent) {
                for (const [e5, t4] of o2.headers) {
                  this.setHeader(e5, t4);
                }
              }
              if (e4.error) {
                this.logger.info("encountered resolver exception, aborting request...", e4.error);
                this.emit("error", e4.error);
                this.terminate();
                return this;
              }
              const n2 = e4.data;
              if (n2) {
                const e5 = n2.clone();
                this.logger.info("received mocked response:", n2);
                this.responseSource = "mock";
                this.respondWith(n2);
                this.logger.info(n2.status, n2.statusText, "(MOCKED)");
                i2 == null ? void 0 : i2();
                this.logger.info('emitting the custom "response" event...');
                this.emitter.emit("response", { response: e5, isMockedResponse: true, request: o2, requestId: t3 });
                this.logger.info("request (mock) is completed");
                return this;
              }
              this.logger.info("no mocked response received!");
              this.once("response-internal", (e5) => {
                this.logger.info(e5.statusCode, e5.statusMessage);
                this.logger.info("original response headers:", e5.headers);
                this.logger.info('emitting the custom "response" event...');
                this.emitter.emit("response", { response: createResponse(e5), isMockedResponse: false, request: o2, requestId: t3 });
              });
              return this.passthrough(r3, s2, i2);
            });
            return this;
          }
          emit(e3, ...t3) {
            this.logger.info("emit: %s", e3);
            if (e3 === "response") {
              this.logger.info('found "response" event, cloning the response...');
              try {
                const r3 = t3[0];
                const n2 = cloneIncomingMessage(r3);
                const s2 = cloneIncomingMessage(r3);
                this.emit("response-internal", s2);
                this.logger.info('response successfully cloned, emitting "response" event...');
                return super.emit(e3, n2, ...t3.slice(1));
              } catch (r3) {
                this.logger.info("error when cloning response:", r3);
                return super.emit(e3, ...t3);
              }
            }
            if (e3 === "error") {
              const e4 = t3[0];
              const r3 = e4.code || "";
              this.logger.info("error:\n", e4);
              if (this.responseSource === "mock" && v.suppressErrorCodes.includes(r3)) {
                if (!this.capturedError) {
                  this.capturedError = e4;
                  this.logger.info("captured the first error:", this.capturedError);
                }
                return false;
              }
            }
            return super.emit(e3, ...t3);
          }
          passthrough(e3, t3, r3) {
            this.responseSource = "bypass";
            if (this.capturedError) {
              this.emit("error", this.capturedError);
              return this;
            }
            this.logger.info("writing request chunks...", this.chunks);
            for (const { chunk: e4, encoding: t4 } of this.chunks) {
              if (t4) {
                super.write(e4, t4);
              } else {
                super.write(e4);
              }
            }
            this.once("error", (e4) => {
              this.logger.info("original request error:", e4);
            });
            this.once("abort", () => {
              this.logger.info("original request aborted!");
            });
            this.once("response-internal", (e4) => {
              this.logger.info(e4.statusCode, e4.statusMessage);
              this.logger.info("original response headers:", e4.headers);
            });
            this.logger.info("performing original request...");
            return super.end(...[e3, t3, r3].filter(Boolean));
          }
          respondWith(e3) {
            this.logger.info("responding with a mocked response...", e3);
            Object.defineProperties(this, { writableFinished: { value: true }, writableEnded: { value: true } });
            this.emit("finish");
            const { status: t3, statusText: r3, headers: n2, body: s2 } = e3;
            this.response.statusCode = t3;
            this.response.statusMessage = r3;
            if (n2) {
              this.response.headers = {};
              n2.forEach((e4, t4) => {
                this.response.rawHeaders.push(t4, e4);
                const r4 = t4.toLowerCase();
                const n3 = this.response.headers[r4];
                this.response.headers[r4] = n3 ? Array.prototype.concat([], n3, e4) : e4;
              });
            }
            this.logger.info("mocked response headers ready:", n2);
            const i2 = new (0, m.DeferredPromise)();
            const finishResponseStream = () => {
              this.logger.info("finished response stream!");
              i2.resolve();
            };
            if (s2) {
              const e4 = s2.getReader();
              const readNextChunk = async () => {
                const { done: t4, value: r4 } = await e4.read();
                if (t4) {
                  finishResponseStream();
                  return;
                }
                this.response.emit("data", r4);
                return readNextChunk();
              };
              readNextChunk();
            } else {
              finishResponseStream();
            }
            this.res = this.response;
            this.emit("response", this.response);
            i2.then(() => {
              this.logger.info("finalizing response...");
              this.response.push(null);
              this.response.complete = true;
              this.response.emit("end");
              this.terminate();
            });
          }
          terminate() {
            var e3;
            (e3 = this.agent) == null ? void 0 : e3.destroy();
          }
        };
        var y = v;
        y.suppressErrorCodes = ["ENOTFOUND", "ECONNREFUSED", "ECONNRESET", "EAI_AGAIN"];
        function getRequestOptionsByUrl(e3) {
          const t3 = { method: "GET", protocol: e3.protocol, hostname: typeof e3.hostname === "string" && e3.hostname.startsWith("[") ? e3.hostname.slice(1, -1) : e3.hostname, host: e3.host, path: `${e3.pathname}${e3.search || ""}` };
          if (!!e3.port) {
            t3.port = Number(e3.port);
          }
          if (e3.username || e3.password) {
            t3.auth = `${e3.username}:${e3.password}`;
          }
          return t3;
        }
        var b = new (0, l.Logger)("utils getUrlByRequestOptions");
        var O = "/";
        var w = "http:";
        var q = "localhost";
        var x = 443;
        function getAgent(e3) {
          return e3.agent instanceof i.Agent ? e3.agent : void 0;
        }
        function getProtocolByRequestOptions(e3) {
          var t3;
          if (e3.protocol) {
            return e3.protocol;
          }
          const r3 = getAgent(e3);
          const n2 = r3 == null ? void 0 : r3.protocol;
          if (n2) {
            return n2;
          }
          const s2 = getPortByRequestOptions(e3);
          const i2 = e3.cert || s2 === x;
          return i2 ? "https:" : ((t3 = e3.uri) == null ? void 0 : t3.protocol) || w;
        }
        function getPortByRequestOptions(e3) {
          if (e3.port) {
            return Number(e3.port);
          }
          if (e3.hostname != null) {
            const [, t4] = e3.hostname.match(/:(\d+)$/) || [];
            if (t4 != null) {
              return Number(t4);
            }
          }
          const t3 = getAgent(e3);
          if (t3 == null ? void 0 : t3.options.port) {
            return Number(t3.options.port);
          }
          if (t3 == null ? void 0 : t3.defaultPort) {
            return Number(t3.defaultPort);
          }
          return void 0;
        }
        function getHostByRequestOptions(e3) {
          const { hostname: t3, host: r3 } = e3;
          if (t3 != null) {
            return t3.replace(/:\d+$/, "");
          }
          return r3 || q;
        }
        function getAuthByRequestOptions(e3) {
          if (e3.auth) {
            const [t3, r3] = e3.auth.split(":");
            return { username: t3, password: r3 };
          }
        }
        function isRawIPv6Address(e3) {
          return e3.includes(":") && !e3.startsWith("[") && !e3.endsWith("]");
        }
        function getHostname(e3, t3) {
          const r3 = typeof t3 !== "undefined" ? `:${t3}` : "";
          if (isRawIPv6Address(e3)) {
            return `[${e3}]${r3}`;
          }
          if (typeof t3 === "undefined") {
            return e3;
          }
          return `${e3}${r3}`;
        }
        function getUrlByRequestOptions(e3) {
          b.info("request options", e3);
          if (e3.uri) {
            b.info('constructing url from explicitly provided "options.uri": %s', e3.uri);
            return new URL(e3.uri.href);
          }
          b.info("figuring out url from request options...");
          const t3 = getProtocolByRequestOptions(e3);
          b.info("protocol", t3);
          const r3 = getHostByRequestOptions(e3);
          b.info("host", r3);
          const n2 = getPortByRequestOptions(e3);
          b.info("port", n2);
          const s2 = getHostname(r3, n2);
          b.info("hostname", s2);
          const i2 = e3.path || O;
          b.info("path", i2);
          const o2 = getAuthByRequestOptions(e3);
          b.info("credentials", o2);
          const a2 = o2 ? `${o2.username}:${o2.password}@` : "";
          b.info("auth string:", a2);
          const u2 = new URL(`${t3}//${a2}${s2}${i2}`);
          b.info("created url:", u2);
          return u2;
        }
        var j = new (0, l.Logger)("cloneObject");
        function isPlainObject(e3) {
          var t3;
          j.info("is plain object?", e3);
          if (e3 == null || !((t3 = e3.constructor) == null ? void 0 : t3.name)) {
            j.info("given object is undefined, not a plain object...");
            return false;
          }
          j.info("checking the object constructor:", e3.constructor.name);
          return e3.constructor.name === "Object";
        }
        function cloneObject(e3) {
          j.info("cloning object:", e3);
          const t3 = Object.entries(e3).reduce((e4, [t4, r3]) => {
            j.info("analyzing key-value pair:", t4, r3);
            e4[t4] = isPlainObject(r3) ? cloneObject(r3) : r3;
            return e4;
          }, {});
          return isPlainObject(e3) ? t3 : Object.assign(Object.getPrototypeOf(e3), t3);
        }
        function isObject(e3) {
          return Object.prototype.toString.call(e3) === "[object Object]";
        }
        var P = new (0, l.Logger)("http normalizeClientRequestArgs");
        function resolveRequestOptions(e3, t3) {
          if (typeof e3[1] === "undefined" || typeof e3[1] === "function") {
            P.info("request options not provided, deriving from the url", t3);
            return getRequestOptionsByUrl(t3);
          }
          if (e3[1]) {
            P.info("has custom RequestOptions!", e3[1]);
            const r3 = getRequestOptionsByUrl(t3);
            P.info("derived RequestOptions from the URL:", r3);
            P.info("cloning RequestOptions...");
            const n2 = cloneObject(e3[1]);
            P.info("successfully cloned RequestOptions!", n2);
            return { ...r3, ...n2 };
          }
          P.info("using an empty object as request options");
          return {};
        }
        function resolveCallback(e3) {
          return typeof e3[1] === "function" ? e3[1] : e3[2];
        }
        function normalizeClientRequestArgs(e3, ...t3) {
          let r3;
          let n2;
          let s2;
          P.info("arguments", t3);
          P.info("using default protocol:", e3);
          if (typeof t3[0] === "string") {
            P.info("first argument is a location string:", t3[0]);
            r3 = new URL(t3[0]);
            P.info("created a url:", r3);
            const e4 = getRequestOptionsByUrl(r3);
            P.info("request options from url:", e4);
            n2 = resolveRequestOptions(t3, r3);
            P.info("resolved request options:", n2);
            s2 = resolveCallback(t3);
          } else if (t3[0] instanceof URL) {
            r3 = t3[0];
            P.info("first argument is a URL:", r3);
            n2 = resolveRequestOptions(t3, r3);
            P.info("derived request options:", n2);
            s2 = resolveCallback(t3);
          } else if ("hash" in t3[0] && !("method" in t3[0])) {
            const [r4] = t3;
            P.info("first argument is a legacy URL:", r4);
            if (r4.hostname === null) {
              P.info("given legacy URL is relative (no hostname)");
              return isObject(t3[1]) ? normalizeClientRequestArgs(e3, { path: r4.path, ...t3[1] }, t3[2]) : normalizeClientRequestArgs(e3, { path: r4.path }, t3[1]);
            }
            P.info("given legacy url is absolute");
            const n3 = new URL(r4.href);
            return t3[1] === void 0 ? normalizeClientRequestArgs(e3, n3) : typeof t3[1] === "function" ? normalizeClientRequestArgs(e3, n3, t3[1]) : normalizeClientRequestArgs(e3, n3, t3[1], t3[2]);
          } else if (isObject(t3[0])) {
            n2 = t3[0];
            P.info("first argument is RequestOptions:", n2);
            n2.protocol = n2.protocol || e3;
            P.info("normalized request options:", n2);
            r3 = getUrlByRequestOptions(n2);
            P.info("created a URL from RequestOptions:", r3.href);
            s2 = resolveCallback(t3);
          } else {
            throw new Error(`Failed to construct ClientRequest with these parameters: ${t3}`);
          }
          n2.protocol = n2.protocol || r3.protocol;
          n2.method = n2.method || "GET";
          if (typeof n2.agent === "undefined") {
            const e4 = n2.protocol === "https:" ? new (0, a.Agent)({ rejectUnauthorized: n2.rejectUnauthorized }) : new (0, i.Agent)();
            n2.agent = e4;
            P.info("resolved fallback agent:", e4);
          }
          if (!n2._defaultAgent) {
            P.info('has no default agent, setting the default agent for "%s"', n2.protocol);
            n2._defaultAgent = n2.protocol === "https:" ? a.globalAgent : i.globalAgent;
          }
          P.info("successfully resolved url:", r3.href);
          P.info("successfully resolved options:", n2);
          P.info("successfully resolved callback:", s2);
          return [r3, n2, s2];
        }
        function get(e3, t3) {
          return (...r3) => {
            const n2 = normalizeClientRequestArgs(`${e3}:`, ...r3);
            const s2 = new y(n2, t3);
            s2.end();
            return s2;
          };
        }
        var E = new (0, l.Logger)("http request");
        function request(e3, t3) {
          return (...r3) => {
            E.info('request call (protocol "%s"):', e3, r3);
            const n2 = normalizeClientRequestArgs(`${e3}:`, ...r3);
            return new y(n2, t3);
          };
        }
        var L = class extends s.Interceptor {
          constructor() {
            super(L.interceptorSymbol);
            this.modules = /* @__PURE__ */ new Map();
            this.modules.set("http", o.default);
            this.modules.set("https", u.default);
          }
          setup() {
            const e3 = this.logger.extend("setup");
            for (const [t3, r3] of this.modules) {
              const { request: n2, get: s2 } = r3;
              this.subscriptions.push(() => {
                r3.request = n2;
                r3.get = s2;
                e3.info('native "%s" module restored!', t3);
              });
              const i2 = { emitter: this.emitter, logger: this.logger };
              r3.request = request(t3, i2);
              r3.get = get(t3, i2);
              e3.info('native "%s" module patched!', t3);
            }
          }
        };
        var _ = L;
        _.interceptorSymbol = Symbol("http");
        t2.ClientRequestInterceptor = _;
      }, 331: function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = ((e3) => true ? __require : 0)(function(e3) {
          if (true)
            return require.apply(this, arguments);
          throw new Error('Dynamic require of "' + e3 + '" is not supported');
        });
        var s = r2(984);
        var i = r2(162);
        function nextTick(e3) {
          setTimeout(e3, 0);
        }
        var o = class extends i.Emitter {
          constructor() {
            super();
            this.logger = new (0, s.Logger)("async-event-emitter");
            this.queue = /* @__PURE__ */ new Map();
            this.readyState = "ACTIVE";
          }
          on(e3, t3) {
            const r3 = this.logger.extend("on");
            r3.info('adding "%s" listener...', e3);
            if (this.readyState === "DEACTIVATED") {
              r3.info("the emitter is destroyed, skipping!");
              return this;
            }
            return super.on(e3, async (...n2) => {
              const s2 = this.openListenerQueue(e3);
              r3.info('awaiting the "%s" listener...', e3);
              s2.push({ args: n2, done: new Promise(async (s3, i2) => {
                try {
                  await t3(...n2);
                  s3();
                  r3.info('"%s" listener has resolved!', e3);
                } catch (e4) {
                  r3.info('"%s" listener has rejected!', e4);
                  i2(e4);
                }
              }) });
            });
          }
          emit(e3, ...t3) {
            const r3 = this.logger.extend("emit");
            r3.info('emitting "%s" event...', e3);
            if (this.readyState === "DEACTIVATED") {
              r3.info("the emitter is destroyed, skipping!");
              return false;
            }
            if (this.isInternalEventName(e3)) {
              return super.emit(e3, ...t3);
            }
            this.openListenerQueue(e3);
            r3.info('appending a one-time cleanup "%s" listener...', e3);
            this.once(e3, () => {
              nextTick(() => {
                this.queue.delete(e3);
                r3.info('cleaned up "%s" listeners queue!', e3);
              });
            });
            return super.emit(e3, ...t3);
          }
          async untilIdle(e3, t3 = () => true) {
            const r3 = this.queue.get(e3) || [];
            await Promise.all(r3.filter(t3).map(({ done: e4 }) => e4)).finally(() => {
              this.queue.delete(e3);
            });
          }
          openListenerQueue(e3) {
            const t3 = this.logger.extend("openListenerQueue");
            t3.info('opening "%s" listeners queue...', e3);
            const r3 = this.queue.get(e3);
            if (!r3) {
              t3.info("no queue found, creating one...");
              this.queue.set(e3, []);
              return [];
            }
            t3.info("returning an exising queue:", r3);
            return r3;
          }
          removeAllListeners(e3) {
            const t3 = this.logger.extend("removeAllListeners");
            t3.info("event:", e3);
            if (e3) {
              this.queue.delete(e3);
              t3.info('cleared the "%s" listeners queue!', e3, this.queue.get(e3));
            } else {
              this.queue.clear();
              t3.info("cleared the listeners queue!", this.queue);
            }
            return super.removeAllListeners(e3);
          }
          activate() {
            const e3 = this.logger.extend("activate");
            this.readyState = "ACTIVE";
            e3.info("set state to:", this.readyState);
          }
          deactivate() {
            const e3 = this.logger.extend("deactivate");
            e3.info("removing all listeners...");
            this.removeAllListeners();
            this.readyState = "DEACTIVATED";
            e3.info("set state to:", this.readyState);
          }
          isInternalEventName(e3) {
            return e3 === "newListener" || e3 === "removeListener";
          }
        };
        function getGlobalSymbol(e3) {
          return globalThis[e3] || void 0;
        }
        function setGlobalSymbol(e3, t3) {
          globalThis[e3] = t3;
        }
        function deleteGlobalSymbol(e3) {
          delete globalThis[e3];
        }
        var a = ((e3) => {
          e3["INACTIVE"] = "INACTIVE";
          e3["APPLYING"] = "APPLYING";
          e3["APPLIED"] = "APPLIED";
          e3["DISPOSING"] = "DISPOSING";
          e3["DISPOSED"] = "DISPOSED";
          return e3;
        })(a || {});
        var u = class {
          constructor(e3) {
            this.symbol = e3;
            this.readyState = "INACTIVE";
            this.emitter = new o();
            this.subscriptions = [];
            this.logger = new (0, s.Logger)(e3.description);
            this.emitter.setMaxListeners(0);
            this.logger.info("constructing the interceptor...");
          }
          checkEnvironment() {
            return true;
          }
          apply() {
            const e3 = this.logger.extend("apply");
            e3.info("applying the interceptor...");
            if (this.readyState === "APPLIED") {
              e3.info("intercepted already applied!");
              return;
            }
            const t3 = this.checkEnvironment();
            if (!t3) {
              e3.info("the interceptor cannot be applied in this environment!");
              return;
            }
            this.readyState = "APPLYING";
            this.emitter.activate();
            e3.info("activated the emiter!", this.emitter.readyState);
            const r3 = this.getInstance();
            if (r3) {
              e3.info("found a running instance, reusing...");
              this.on = (t4, n2) => {
                e3.info('proxying the "%s" listener', t4);
                r3.emitter.addListener(t4, n2);
                this.subscriptions.push(() => {
                  r3.emitter.removeListener(t4, n2);
                  e3.info('removed proxied "%s" listener!', t4);
                });
              };
              this.readyState = "APPLIED";
              return;
            }
            e3.info("no running instance found, setting up a new instance...");
            this.setup();
            this.setInstance();
            this.readyState = "APPLIED";
          }
          setup() {
          }
          on(e3, t3) {
            const r3 = this.logger.extend("on");
            if (this.readyState === "DISPOSING" || this.readyState === "DISPOSED") {
              r3.info("cannot listen to events, already disposed!");
              return;
            }
            r3.info('adding "%s" event listener:', e3, t3.name);
            this.emitter.on(e3, t3);
          }
          dispose() {
            const e3 = this.logger.extend("dispose");
            if (this.readyState === "DISPOSED") {
              e3.info("cannot dispose, already disposed!");
              return;
            }
            e3.info("disposing the interceptor...");
            this.readyState = "DISPOSING";
            if (!this.getInstance()) {
              e3.info("no interceptors running, skipping dispose...");
              return;
            }
            this.clearInstance();
            e3.info("global symbol deleted:", getGlobalSymbol(this.symbol));
            if (this.subscriptions.length > 0) {
              e3.info("disposing of %d subscriptions...", this.subscriptions.length);
              for (const e4 of this.subscriptions) {
                e4();
              }
              this.subscriptions = [];
              e3.info("disposed of all subscriptions!", this.subscriptions.length);
            }
            this.emitter.deactivate();
            e3.info("destroyed the listener!");
            this.readyState = "DISPOSED";
          }
          getInstance() {
            var e3;
            const t3 = getGlobalSymbol(this.symbol);
            this.logger.info("retrieved global instance:", (e3 = t3 == null ? void 0 : t3.constructor) == null ? void 0 : e3.name);
            return t3;
          }
          setInstance() {
            setGlobalSymbol(this.symbol, this);
            this.logger.info("set global instance!", this.symbol.description);
          }
          clearInstance() {
            deleteGlobalSymbol(this.symbol);
            this.logger.info("cleared global instance!", this.symbol.description);
          }
        };
        t2.__require = n;
        t2.getGlobalSymbol = getGlobalSymbol;
        t2.deleteGlobalSymbol = deleteGlobalSymbol;
        t2.InterceptorReadyState = a;
        t2.Interceptor = u;
      }, 858: function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        var n = r2(270);
        function createLazyCallback(e3 = {}) {
          let t3 = 0;
          let r3;
          let n2;
          const s = new Promise((e4) => {
            n2 = e4;
          }).finally(() => {
            clearTimeout(r3);
          });
          const fn = function(...r4) {
            var s2;
            if (e3.maxCalls && t3 >= e3.maxCalls) {
              (s2 = e3.maxCallsCallback) == null ? void 0 : s2.call(e3);
            }
            n2(r4);
            t3++;
          };
          fn.invoked = async () => {
            r3 = setTimeout(() => {
              n2([]);
            }, 0);
            return s;
          };
          return fn;
        }
        function toInteractiveRequest(e3) {
          Object.defineProperty(e3, "respondWith", { writable: false, enumerable: true, value: createLazyCallback({ maxCalls: 1, maxCallsCallback() {
            throw new Error(n.format.call(void 0, 'Failed to respond to "%s %s" request: the "request" event has already been responded to.', e3.method, e3.url));
          } }) });
          return e3;
        }
        function uuidv4() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e3) {
            const t3 = Math.random() * 16 | 0;
            const r3 = e3 == "x" ? t3 : t3 & 3 | 8;
            return r3.toString(16);
          });
        }
        t2.toInteractiveRequest = toInteractiveRequest;
        t2.uuidv4 = uuidv4;
      }, 596: function(e2, t2, r2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.DeferredPromise = void 0;
        const n = r2(738);
        class DeferredPromise extends Promise {
          #e;
          resolve;
          reject;
          constructor(e3 = null) {
            const t3 = (0, n.createDeferredExecutor)();
            super((r3, n2) => {
              t3(r3, n2);
              e3?.(t3.resolve, t3.reject);
            });
            this.#e = t3;
            this.resolve = this.#e.resolve;
            this.reject = this.#e.reject;
          }
          get state() {
            return this.#e.state;
          }
          get rejectionReason() {
            return this.#e.rejectionReason;
          }
          then(e3, t3) {
            return this.#t(super.then(e3, t3));
          }
          catch(e3) {
            return this.#t(super.catch(e3));
          }
          finally(e3) {
            return this.#t(super.finally(e3));
          }
          #t(e3) {
            return Object.defineProperties(e3, { resolve: { configurable: true, value: this.resolve }, reject: { configurable: true, value: this.reject } });
          }
        }
        t2.DeferredPromise = DeferredPromise;
      }, 738: function(e2, t2) {
        "use strict";
        Object.defineProperty(t2, "__esModule", { value: true });
        t2.createDeferredExecutor = void 0;
        function createDeferredExecutor() {
          const executor = (e3, t3) => {
            executor.state = "pending";
            executor.resolve = (t4) => {
              if (executor.state !== "pending") {
                return;
              }
              executor.result = t4;
              const onFulfilled = (e4) => {
                executor.state = "fulfilled";
                return e4;
              };
              return e3(t4 instanceof Promise ? t4 : Promise.resolve(t4).then(onFulfilled));
            };
            executor.reject = (e4) => {
              if (executor.state !== "pending") {
                return;
              }
              queueMicrotask(() => {
                executor.state = "rejected";
              });
              return t3(executor.rejectionReason = e4);
            };
          };
          return executor;
        }
        t2.createDeferredExecutor = createDeferredExecutor;
      }, 642: function(e2, t2, r2) {
        "use strict";
        var n = this && this.__createBinding || (Object.create ? function(e3, t3, r3, n2) {
          if (n2 === void 0)
            n2 = r3;
          var s2 = Object.getOwnPropertyDescriptor(t3, r3);
          if (!s2 || ("get" in s2 ? !t3.__esModule : s2.writable || s2.configurable)) {
            s2 = { enumerable: true, get: function() {
              return t3[r3];
            } };
          }
          Object.defineProperty(e3, n2, s2);
        } : function(e3, t3, r3, n2) {
          if (n2 === void 0)
            n2 = r3;
          e3[n2] = t3[r3];
        });
        var s = this && this.__exportStar || function(e3, t3) {
          for (var r3 in e3)
            if (r3 !== "default" && !Object.prototype.hasOwnProperty.call(t3, r3))
              n(t3, e3, r3);
        };
        Object.defineProperty(t2, "__esModule", { value: true });
        s(r2(738), t2);
        s(r2(596), t2);
      }, 984: function(e2, t2, r2) {
        var n = Object.defineProperty;
        var s = Object.getOwnPropertyDescriptor;
        var i = Object.getOwnPropertyNames;
        var o = Object.prototype.hasOwnProperty;
        var __export3 = (e3, t3) => {
          for (var r3 in t3)
            n(e3, r3, { get: t3[r3], enumerable: true });
        };
        var __copyProps2 = (e3, t3, r3, a2) => {
          if (t3 && typeof t3 === "object" || typeof t3 === "function") {
            for (let u2 of i(t3))
              if (!o.call(e3, u2) && u2 !== r3)
                n(e3, u2, { get: () => t3[u2], enumerable: !(a2 = s(t3, u2)) || a2.enumerable });
          }
          return e3;
        };
        var __toCommonJS2 = (e3) => __copyProps2(n({}, "__esModule", { value: true }), e3);
        var a = {};
        __export3(a, { Logger: () => h });
        e2.exports = __toCommonJS2(a);
        var u = r2(576);
        var c = r2(270);
        var l = {};
        __export3(l, { blue: () => blue, gray: () => gray, green: () => green, red: () => red, yellow: () => yellow });
        function yellow(e3) {
          return `\x1B[33m${e3}\x1B[0m`;
        }
        function blue(e3) {
          return `\x1B[34m${e3}\x1B[0m`;
        }
        function gray(e3) {
          return `\x1B[90m${e3}\x1B[0m`;
        }
        function red(e3) {
          return `\x1B[31m${e3}\x1B[0m`;
        }
        function green(e3) {
          return `\x1B[32m${e3}\x1B[0m`;
        }
        var f = (0, u.isNodeProcess)();
        var h = class {
          constructor(e3) {
            this.name = e3;
            this.prefix = `[${this.name}]`;
            const t3 = getVariable("DEBUG");
            const r3 = getVariable("LOG_LEVEL");
            const n2 = t3 === "1" || t3 === "true" || typeof t3 !== "undefined" && this.name.startsWith(t3);
            if (n2) {
              this.debug = isDefinedAndNotEquals(r3, "debug") ? noop : this.debug;
              this.info = isDefinedAndNotEquals(r3, "info") ? noop : this.info;
              this.success = isDefinedAndNotEquals(r3, "success") ? noop : this.success;
              this.warning = isDefinedAndNotEquals(r3, "warning") ? noop : this.warning;
              this.error = isDefinedAndNotEquals(r3, "error") ? noop : this.error;
            } else {
              this.info = noop;
              this.success = noop;
              this.warning = noop;
              this.error = noop;
              this.only = noop;
            }
          }
          prefix;
          extend(e3) {
            return new h(`${this.name}:${e3}`);
          }
          debug(e3, ...t3) {
            this.logEntry({ level: "debug", message: gray(e3), positionals: t3, prefix: this.prefix, colors: { prefix: "gray" } });
          }
          info(e3, ...t3) {
            this.logEntry({ level: "info", message: e3, positionals: t3, prefix: this.prefix, colors: { prefix: "blue" } });
            const r3 = new p();
            return (e4, ...t4) => {
              r3.measure();
              this.logEntry({ level: "info", message: `${e4} ${gray(`${r3.deltaTime}ms`)}`, positionals: t4, prefix: this.prefix, colors: { prefix: "blue" } });
            };
          }
          success(e3, ...t3) {
            this.logEntry({ level: "info", message: e3, positionals: t3, prefix: `\u2714 ${this.prefix}`, colors: { timestamp: "green", prefix: "green" } });
          }
          warning(e3, ...t3) {
            this.logEntry({ level: "warning", message: e3, positionals: t3, prefix: `\u26A0 ${this.prefix}`, colors: { timestamp: "yellow", prefix: "yellow" } });
          }
          error(e3, ...t3) {
            this.logEntry({ level: "error", message: e3, positionals: t3, prefix: `\u2716 ${this.prefix}`, colors: { timestamp: "red", prefix: "red" } });
          }
          only(e3) {
            e3();
          }
          createEntry(e3, t3) {
            return { timestamp: /* @__PURE__ */ new Date(), level: e3, message: t3 };
          }
          logEntry(e3) {
            const { level: t3, message: r3, prefix: n2, colors: s2, positionals: i2 = [] } = e3;
            const o2 = this.createEntry(t3, r3);
            const a2 = s2?.timestamp || "gray";
            const u2 = s2?.prefix || "gray";
            const c2 = { timestamp: l[a2], prefix: l[u2] };
            const f2 = this.getWriter(t3);
            f2([c2.timestamp(this.formatTimestamp(o2.timestamp))].concat(n2 != null ? c2.prefix(n2) : []).concat(serializeInput(r3)).join(" "), ...i2.map(serializeInput));
          }
          formatTimestamp(e3) {
            return `${e3.toLocaleTimeString("en-GB")}:${e3.getMilliseconds()}`;
          }
          getWriter(e3) {
            switch (e3) {
              case "debug":
              case "success":
              case "info": {
                return log;
              }
              case "warning": {
                return warn;
              }
              case "error": {
                return error;
              }
            }
          }
        };
        var p = class {
          startTime;
          endTime;
          deltaTime;
          constructor() {
            this.startTime = performance.now();
          }
          measure() {
            this.endTime = performance.now();
            const e3 = this.endTime - this.startTime;
            this.deltaTime = e3.toFixed(2);
          }
        };
        var noop = () => void 0;
        function log(e3, ...t3) {
          if (f) {
            process.stdout.write((0, c.format)(e3, ...t3) + "\n");
            return;
          }
          console.log(e3, ...t3);
        }
        function warn(e3, ...t3) {
          if (f) {
            process.stderr.write((0, c.format)(e3, ...t3) + "\n");
            return;
          }
          console.warn(e3, ...t3);
        }
        function error(e3, ...t3) {
          if (f) {
            process.stderr.write((0, c.format)(e3, ...t3) + "\n");
            return;
          }
          console.error(e3, ...t3);
        }
        function getVariable(e3) {
          if (f) {
            return process.env[e3];
          }
          return globalThis[e3]?.toString();
        }
        function isDefinedAndNotEquals(e3, t3) {
          return e3 !== void 0 && e3 !== t3;
        }
        function serializeInput(e3) {
          if (typeof e3 === "undefined") {
            return "undefined";
          }
          if (e3 === null) {
            return "null";
          }
          if (typeof e3 === "string") {
            return e3;
          }
          if (typeof e3 === "object") {
            return JSON.stringify(e3);
          }
          return e3.toString();
        }
      }, 362: function(e2) {
        var t2 = Object.defineProperty;
        var r2 = Object.getOwnPropertyDescriptor;
        var n = Object.getOwnPropertyNames;
        var s = Object.prototype.hasOwnProperty;
        var __export3 = (e3, r3) => {
          for (var n2 in r3)
            t2(e3, n2, { get: r3[n2], enumerable: true });
        };
        var __copyProps2 = (e3, i2, o, a) => {
          if (i2 && typeof i2 === "object" || typeof i2 === "function") {
            for (let u of n(i2))
              if (!s.call(e3, u) && u !== o)
                t2(e3, u, { get: () => i2[u], enumerable: !(a = r2(i2, u)) || a.enumerable });
          }
          return e3;
        };
        var __toCommonJS2 = (e3) => __copyProps2(t2({}, "__esModule", { value: true }), e3);
        var i = {};
        __export3(i, { until: () => until });
        e2.exports = __toCommonJS2(i);
        var until = async (e3) => {
          try {
            const t3 = await e3().catch((e4) => {
              throw e4;
            });
            return { error: null, data: t3 };
          } catch (e4) {
            return { error: e4, data: null };
          }
        };
      }, 426: function(e2) {
        var t2 = Object.defineProperty;
        var r2 = Object.getOwnPropertyDescriptor;
        var n = Object.getOwnPropertyNames;
        var s = Object.prototype.hasOwnProperty;
        var __export3 = (e3, r3) => {
          for (var n2 in r3)
            t2(e3, n2, { get: r3[n2], enumerable: true });
        };
        var __copyProps2 = (e3, i2, o2, a2) => {
          if (i2 && typeof i2 === "object" || typeof i2 === "function") {
            for (let u2 of n(i2))
              if (!s.call(e3, u2) && u2 !== o2)
                t2(e3, u2, { get: () => i2[u2], enumerable: !(a2 = r2(i2, u2)) || a2.enumerable });
          }
          return e3;
        };
        var __toCommonJS2 = (e3) => __copyProps2(t2({}, "__esModule", { value: true }), e3);
        var i = {};
        __export3(i, { Headers: () => f, flattenHeadersList: () => flattenHeadersList, flattenHeadersObject: () => flattenHeadersObject, headersToList: () => headersToList, headersToObject: () => headersToObject, headersToString: () => headersToString, listToHeaders: () => listToHeaders, objectToHeaders: () => objectToHeaders, reduceHeadersObject: () => reduceHeadersObject, stringToHeaders: () => stringToHeaders });
        e2.exports = __toCommonJS2(i);
        var o = /[^a-z0-9\-#$%&'*+.^_`|~]/i;
        function normalizeHeaderName(e3) {
          if (typeof e3 !== "string") {
            e3 = String(e3);
          }
          if (o.test(e3) || e3.trim() === "") {
            throw new TypeError("Invalid character in header field name");
          }
          return e3.toLowerCase();
        }
        function normalizeHeaderValue(e3) {
          if (typeof e3 !== "string") {
            e3 = String(e3);
          }
          return e3;
        }
        var a = Symbol("normalizedHeaders");
        var u = Symbol("rawHeaderNames");
        var c, l;
        var f = class {
          constructor(e3) {
            this[c] = {};
            this[l] = /* @__PURE__ */ new Map();
            if (["Headers", "HeadersPolyfill"].includes(e3 == null ? void 0 : e3.constructor.name) || e3 instanceof f) {
              const t3 = e3;
              t3.forEach((e4, t4) => {
                this.append(t4, e4);
              }, this);
            } else if (Array.isArray(e3)) {
              e3.forEach(([e4, t3]) => {
                this.append(e4, Array.isArray(t3) ? t3.join(", ") : t3);
              });
            } else if (e3) {
              Object.getOwnPropertyNames(e3).forEach((t3) => {
                const r3 = e3[t3];
                this.append(t3, Array.isArray(r3) ? r3.join(", ") : r3);
              });
            }
          }
          [(c = a, l = u, Symbol.iterator)]() {
            return this.entries();
          }
          *keys() {
            for (const e3 of Object.keys(this[a])) {
              yield e3;
            }
          }
          *values() {
            for (const e3 of Object.values(this[a])) {
              yield e3;
            }
          }
          *entries() {
            for (const e3 of Object.keys(this[a])) {
              yield [e3, this.get(e3)];
            }
          }
          get(e3) {
            return this[a][normalizeHeaderName(e3)] || null;
          }
          set(e3, t3) {
            const r3 = normalizeHeaderName(e3);
            this[a][r3] = normalizeHeaderValue(t3);
            this[u].set(r3, e3);
          }
          append(e3, t3) {
            const r3 = normalizeHeaderName(e3);
            let n2 = this.has(r3) ? `${this.get(r3)}, ${t3}` : t3;
            this.set(e3, n2);
          }
          delete(e3) {
            if (!this.has(e3)) {
              return;
            }
            const t3 = normalizeHeaderName(e3);
            delete this[a][t3];
            this[u].delete(t3);
          }
          all() {
            return this[a];
          }
          raw() {
            const e3 = {};
            for (const [t3, r3] of this.entries()) {
              e3[this[u].get(t3)] = r3;
            }
            return e3;
          }
          has(e3) {
            return this[a].hasOwnProperty(normalizeHeaderName(e3));
          }
          forEach(e3, t3) {
            for (const r3 in this[a]) {
              if (this[a].hasOwnProperty(r3)) {
                e3.call(t3, this[a][r3], r3, this);
              }
            }
          }
        };
        function headersToList(e3) {
          const t3 = [];
          e3.forEach((e4, r3) => {
            const n2 = e4.includes(",") ? e4.split(",").map((e5) => e5.trim()) : e4;
            t3.push([r3, n2]);
          });
          return t3;
        }
        function headersToString(e3) {
          const t3 = headersToList(e3);
          const r3 = t3.map(([e4, t4]) => {
            const r4 = [].concat(t4);
            return `${e4}: ${r4.join(", ")}`;
          });
          return r3.join("\r\n");
        }
        var h = ["user-agent"];
        function headersToObject(e3) {
          const t3 = {};
          e3.forEach((e4, r3) => {
            const n2 = !h.includes(r3.toLowerCase()) && e4.includes(",");
            t3[r3] = n2 ? e4.split(",").map((e5) => e5.trim()) : e4;
          });
          return t3;
        }
        function stringToHeaders(e3) {
          const t3 = e3.trim().split(/[\r\n]+/);
          return t3.reduce((e4, t4) => {
            if (t4.trim() === "") {
              return e4;
            }
            const r3 = t4.split(": ");
            const n2 = r3.shift();
            const s2 = r3.join(": ");
            e4.append(n2, s2);
            return e4;
          }, new f());
        }
        function listToHeaders(e3) {
          const t3 = new f();
          e3.forEach(([e4, r3]) => {
            const n2 = [].concat(r3);
            n2.forEach((r4) => {
              t3.append(e4, r4);
            });
          });
          return t3;
        }
        function reduceHeadersObject(e3, t3, r3) {
          return Object.keys(e3).reduce((r4, n2) => t3(r4, n2, e3[n2]), r3);
        }
        function objectToHeaders(e3) {
          return reduceHeadersObject(e3, (e4, t3, r3) => {
            const n2 = [].concat(r3).filter(Boolean);
            n2.forEach((r4) => {
              e4.append(t3, r4);
            });
            return e4;
          }, new f());
        }
        function flattenHeadersList(e3) {
          return e3.map(([e4, t3]) => [e4, [].concat(t3).join(", ")]);
        }
        function flattenHeadersObject(e3) {
          return reduceHeadersObject(e3, (e4, t3, r3) => {
            e4[t3] = [].concat(r3).join(", ");
            return e4;
          }, {});
        }
      }, 576: function(e2) {
        var t2 = Object.defineProperty;
        var r2 = Object.getOwnPropertyDescriptor;
        var n = Object.getOwnPropertyNames;
        var s = Object.prototype.hasOwnProperty;
        var __export3 = (e3, r3) => {
          for (var n2 in r3)
            t2(e3, n2, { get: r3[n2], enumerable: true });
        };
        var __copyProps2 = (e3, i2, o, a) => {
          if (i2 && typeof i2 === "object" || typeof i2 === "function") {
            for (let u of n(i2))
              if (!s.call(e3, u) && u !== o)
                t2(e3, u, { get: () => i2[u], enumerable: !(a = r2(i2, u)) || a.enumerable });
          }
          return e3;
        };
        var __toCommonJS2 = (e3) => __copyProps2(t2({}, "__esModule", { value: true }), e3);
        var i = {};
        __export3(i, { isNodeProcess: () => isNodeProcess });
        e2.exports = __toCommonJS2(i);
        function isNodeProcess() {
          if (typeof navigator !== "undefined" && navigator.product === "ReactNative") {
            return true;
          }
          if (typeof process !== "undefined") {
            const e3 = process.type;
            if (e3 === "renderer" || e3 === "worker") {
              return false;
            }
            return !!(process.versions && process.versions.node);
          }
          return false;
        }
      }, 270: function(e2) {
        "use strict";
        var t2 = Object.defineProperty;
        var r2 = Object.getOwnPropertyDescriptor;
        var n = Object.getOwnPropertyNames;
        var s = Object.prototype.hasOwnProperty;
        var __export3 = (e3, r3) => {
          for (var n2 in r3)
            t2(e3, n2, { get: r3[n2], enumerable: true });
        };
        var __copyProps2 = (e3, i2, o2, a2) => {
          if (i2 && typeof i2 === "object" || typeof i2 === "function") {
            for (let u2 of n(i2))
              if (!s.call(e3, u2) && u2 !== o2)
                t2(e3, u2, { get: () => i2[u2], enumerable: !(a2 = r2(i2, u2)) || a2.enumerable });
          }
          return e3;
        };
        var __toCommonJS2 = (e3) => __copyProps2(t2({}, "__esModule", { value: true }), e3);
        var i = {};
        __export3(i, { InvariantError: () => u, format: () => format, invariant: () => invariant });
        e2.exports = __toCommonJS2(i);
        var o = /(%?)(%([sdjo]))/g;
        function serializePositional(e3, t3) {
          switch (t3) {
            case "s":
              return e3;
            case "d":
            case "i":
              return Number(e3);
            case "j":
              return JSON.stringify(e3);
            case "o": {
              if (typeof e3 === "string") {
                return e3;
              }
              const t4 = JSON.stringify(e3);
              if (t4 === "{}" || t4 === "[]" || /^\[object .+?\]$/.test(t4)) {
                return e3;
              }
              return t4;
            }
          }
        }
        function format(e3, ...t3) {
          if (t3.length === 0) {
            return e3;
          }
          let r3 = 0;
          let n2 = e3.replace(o, (e4, n3, s2, i2) => {
            const o2 = t3[r3];
            const a2 = serializePositional(o2, i2);
            if (!n3) {
              r3++;
              return a2;
            }
            return e4;
          });
          if (r3 < t3.length) {
            n2 += ` ${t3.slice(r3).join(" ")}`;
          }
          n2 = n2.replace(/%{2,2}/g, "%");
          return n2;
        }
        var a = 2;
        function cleanErrorStack(e3) {
          if (!e3.stack) {
            return;
          }
          const t3 = e3.stack.split("\n");
          t3.splice(1, a);
          e3.stack = t3.join("\n");
        }
        var u = class extends Error {
          constructor(e3, ...t3) {
            super(e3);
            this.message = e3;
            this.name = "Invariant Violation";
            this.message = format(e3, ...t3);
            cleanErrorStack(this);
          }
        };
        var invariant = (e3, t3, ...r3) => {
          if (!e3) {
            throw new u(t3, ...r3);
          }
        };
        invariant.as = (e3, t3, r3, ...n2) => {
          if (!t3) {
            const t4 = e3.prototype.name != null;
            const s2 = t4 ? new e3(format(r3, n2)) : e3(format(r3, n2));
            throw s2;
          }
        };
      }, 162: function(e2) {
        var t2 = Object.defineProperty;
        var r2 = Object.getOwnPropertyDescriptor;
        var n = Object.getOwnPropertyNames;
        var s = Object.prototype.hasOwnProperty;
        var __export3 = (e3, r3) => {
          for (var n2 in r3)
            t2(e3, n2, { get: r3[n2], enumerable: true });
        };
        var __copyProps2 = (e3, i2, o2, a2) => {
          if (i2 && typeof i2 === "object" || typeof i2 === "function") {
            for (let u2 of n(i2))
              if (!s.call(e3, u2) && u2 !== o2)
                t2(e3, u2, { get: () => i2[u2], enumerable: !(a2 = r2(i2, u2)) || a2.enumerable });
          }
          return e3;
        };
        var __toCommonJS2 = (e3) => __copyProps2(t2({}, "__esModule", { value: true }), e3);
        var i = {};
        __export3(i, { Emitter: () => u, MemoryLeakError: () => o });
        e2.exports = __toCommonJS2(i);
        var o = class extends Error {
          constructor(e3, t3, r3) {
            super(`Possible EventEmitter memory leak detected. ${r3} ${t3.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`);
            this.emitter = e3;
            this.type = t3;
            this.count = r3;
            this.name = "MaxListenersExceededWarning";
          }
        };
        var a = class {
          static listenerCount(e3, t3) {
            return e3.listenerCount(t3);
          }
          constructor() {
            this.events = /* @__PURE__ */ new Map();
            this.maxListeners = a.defaultMaxListeners;
            this.hasWarnedAboutPotentialMemoryLeak = false;
          }
          _emitInternalEvent(e3, t3, r3) {
            this.emit(e3, ...[t3, r3]);
          }
          _getListeners(e3) {
            return this.events.get(e3) || [];
          }
          _removeListener(e3, t3) {
            const r3 = e3.indexOf(t3);
            if (r3 > -1) {
              e3.splice(r3, 1);
            }
            return [];
          }
          _wrapOnceListener(e3, t3) {
            const onceListener = (...r3) => {
              this.removeListener(e3, onceListener);
              t3.apply(this, r3);
            };
            return onceListener;
          }
          setMaxListeners(e3) {
            this.maxListeners = e3;
            return this;
          }
          getMaxListeners() {
            return this.maxListeners;
          }
          eventNames() {
            return Array.from(this.events.keys());
          }
          emit(e3, ...t3) {
            const r3 = this._getListeners(e3);
            r3.forEach((e4) => {
              e4.apply(this, t3);
            });
            return r3.length > 0;
          }
          addListener(e3, t3) {
            this._emitInternalEvent("newListener", e3, t3);
            const r3 = this._getListeners(e3).concat(t3);
            this.events.set(e3, r3);
            if (this.maxListeners > 0 && this.listenerCount(e3) > this.maxListeners && !this.hasWarnedAboutPotentialMemoryLeak) {
              this.hasWarnedAboutPotentialMemoryLeak = true;
              const t4 = new o(this, e3, this.listenerCount(e3));
              console.warn(t4);
            }
            return this;
          }
          on(e3, t3) {
            return this.addListener(e3, t3);
          }
          once(e3, t3) {
            return this.addListener(e3, this._wrapOnceListener(e3, t3));
          }
          prependListener(e3, t3) {
            const r3 = this._getListeners(e3);
            if (r3.length > 0) {
              const n2 = [t3].concat(r3);
              this.events.set(e3, n2);
            } else {
              this.events.set(e3, r3.concat(t3));
            }
            return this;
          }
          prependOnceListener(e3, t3) {
            return this.prependListener(e3, this._wrapOnceListener(e3, t3));
          }
          removeListener(e3, t3) {
            const r3 = this._getListeners(e3);
            if (r3.length > 0) {
              this._removeListener(r3, t3);
              this.events.set(e3, r3);
              this._emitInternalEvent("removeListener", e3, t3);
            }
            return this;
          }
          off(e3, t3) {
            return this.removeListener(e3, t3);
          }
          removeAllListeners(e3) {
            if (e3) {
              this.events.delete(e3);
            } else {
              this.events.clear();
            }
            return this;
          }
          listeners(e3) {
            return Array.from(this._getListeners(e3));
          }
          listenerCount(e3) {
            return this._getListeners(e3).length;
          }
          rawListeners(e3) {
            return this.listeners(e3);
          }
        };
        var u = a;
        u.defaultMaxListeners = 10;
      }, 685: function(e2) {
        "use strict";
        e2.exports = require("http");
      }, 687: function(e2) {
        "use strict";
        e2.exports = require("https");
      }, 781: function(e2) {
        "use strict";
        e2.exports = require("stream");
      } };
      var t = {};
      function __nccwpck_require__2(r2) {
        var n = t[r2];
        if (n !== void 0) {
          return n.exports;
        }
        var s = t[r2] = { exports: {} };
        var i = true;
        try {
          e[r2].call(s.exports, s, s.exports, __nccwpck_require__2);
          i = false;
        } finally {
          if (i)
            delete t[r2];
        }
        return s.exports;
      }
      if (typeof __nccwpck_require__2 !== "undefined")
        __nccwpck_require__2.ab = "/";
      var r = {};
      !function() {
        "use strict";
        var e2 = r;
        Object.defineProperty(e2, "__esModule", { value: true });
        var t2 = __nccwpck_require__2(501);
        __nccwpck_require__2(858);
        __nccwpck_require__2(331);
        e2.ClientRequestInterceptor = t2.ClientRequestInterceptor;
      }();
      module.exports = r;
    })();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/httpget.js
var require_httpget = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/httpget.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "interceptHttpGet", {
      enumerable: true,
      get: function() {
        return interceptHttpGet;
      }
    });
    var _ClientRequest = require_ClientRequest();
    var _fetch = require_fetch();
    function interceptHttpGet(originalFetch) {
      const clientRequestInterceptor = new _ClientRequest.ClientRequestInterceptor();
      clientRequestInterceptor.on("request", async ({ request }) => {
        const response = await (0, _fetch.handleFetch)(originalFetch, request);
        request.respondWith(response);
      });
      clientRequestInterceptor.apply();
      return () => {
        clientRequestInterceptor.dispose();
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/server.js
var require_server = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/experimental/testmode/server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      interceptTestApis: function() {
        return interceptTestApis;
      },
      wrapRequestHandlerNode: function() {
        return wrapRequestHandlerNode;
      },
      wrapRequestHandlerWorker: function() {
        return wrapRequestHandlerWorker;
      }
    });
    var _context = require_context();
    var _fetch = require_fetch();
    var _httpget = require_httpget();
    var reader = {
      url(req) {
        return req.url ?? "";
      },
      header(req, name) {
        const h = req.headers[name];
        if (h === void 0 || h === null) {
          return null;
        }
        if (typeof h === "string") {
          return h;
        }
        return h[0] ?? null;
      }
    };
    function interceptTestApis() {
      const originalFetch = global.fetch;
      const restoreFetch = (0, _fetch.interceptFetch)(originalFetch);
      const restoreHttpGet = (0, _httpget.interceptHttpGet)(originalFetch);
      return () => {
        restoreFetch();
        restoreHttpGet();
      };
    }
    function wrapRequestHandlerWorker(handler) {
      return (req, res) => (0, _context.withRequest)(req, reader, () => handler(req, res));
    }
    function wrapRequestHandlerNode(handler) {
      return (req, res, parsedUrl) => (0, _context.withRequest)(req, reader, () => handler(req, res, parsedUrl));
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/lib/pick.js
var require_pick = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/lib/pick.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "pick", {
      enumerable: true,
      get: function() {
        return pick;
      }
    });
    function pick(obj, keys) {
      const newObj = {};
      for (const key of keys) {
        newObj[key] = obj[key];
      }
      return newObj;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/fetch-inline-assets.js
var require_fetch_inline_assets = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/fetch-inline-assets.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "fetchInlineAsset", {
      enumerable: true,
      get: function() {
        return fetchInlineAsset;
      }
    });
    var _fs = require("fs");
    var _bodystreams = require_body_streams();
    var _path = require("path");
    async function fetchInlineAsset(options) {
      const inputString = String(options.input);
      if (!inputString.startsWith("blob:")) {
        return;
      }
      const name = inputString.replace("blob:", "");
      const asset = options.assets ? options.assets.find((x) => x.name === name) : {
        name,
        filePath: name
      };
      if (!asset) {
        return;
      }
      const filePath = (0, _path.resolve)(options.distDir, asset.filePath);
      const fileIsReadable = await _fs.promises.access(filePath).then(() => true, () => false);
      if (fileIsReadable) {
        const readStream = (0, _fs.createReadStream)(filePath);
        return new options.context.Response((0, _bodystreams.requestToBodyStream)(options.context, Uint8Array, readStream));
      }
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/resource-managers.js
var require_resource_managers = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/resource-managers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      intervalsManager: function() {
        return intervalsManager;
      },
      timeoutsManager: function() {
        return timeoutsManager;
      }
    });
    var ResourceManager = class {
      add(resourceArgs) {
        const resource = this.create(resourceArgs);
        this.resources.push(resource);
        return resource;
      }
      remove(resource) {
        this.resources = this.resources.filter((r) => r !== resource);
        this.destroy(resource);
      }
      removeAll() {
        this.resources.forEach(this.destroy);
        this.resources = [];
      }
      constructor() {
        this.resources = [];
      }
    };
    var IntervalsManager = class extends ResourceManager {
      create(args) {
        return setInterval(...args)[Symbol.toPrimitive]();
      }
      destroy(interval) {
        clearInterval(interval);
      }
    };
    var TimeoutsManager = class extends ResourceManager {
      create(args) {
        return setTimeout(...args)[Symbol.toPrimitive]();
      }
      destroy(timeout) {
        clearTimeout(timeout);
      }
    };
    var intervalsManager = new IntervalsManager();
    var timeoutsManager = new TimeoutsManager();
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/context.js
var require_context2 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/context.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      clearAllModuleContexts: function() {
        return clearAllModuleContexts;
      },
      clearModuleContext: function() {
        return clearModuleContext;
      },
      edgeSandboxNextRequestContext: function() {
        return edgeSandboxNextRequestContext;
      },
      getModuleContext: function() {
        return getModuleContext;
      },
      requestStore: function() {
        return requestStore;
      }
    });
    var _async_hooks = require("async_hooks");
    var _constants = require_constants3();
    var _edgeruntime = (init_empty(), __toCommonJS(empty_exports));
    var _fs = require("fs");
    var _utils = require_utils();
    var _pick = require_pick();
    var _fetchinlineassets = require_fetch_inline_assets();
    var _vm = require("vm");
    var _nodebuffer = /* @__PURE__ */ _interop_require_default(require("node:buffer"));
    var _nodeevents = /* @__PURE__ */ _interop_require_default(require("node:events"));
    var _nodeassert = /* @__PURE__ */ _interop_require_default(require("node:assert"));
    var _nodeutil = /* @__PURE__ */ _interop_require_default(require("node:util"));
    var _nodeasync_hooks = /* @__PURE__ */ _interop_require_default(require("node:async_hooks"));
    var _resourcemanagers = require_resource_managers();
    var _builtinrequestcontext = require_builtin_request_context();
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    var getServerError;
    var decorateServerError;
    if (false) {
      const middleware = null;
      getServerError = middleware.getServerError;
      decorateServerError = null.decorateServerError;
    } else {
      getServerError = (error, _) => error;
      decorateServerError = (_, __) => {
      };
    }
    var moduleContexts = /* @__PURE__ */ new Map();
    var pendingModuleCaches = /* @__PURE__ */ new Map();
    async function clearAllModuleContexts() {
      _resourcemanagers.intervalsManager.removeAll();
      _resourcemanagers.timeoutsManager.removeAll();
      moduleContexts.clear();
      pendingModuleCaches.clear();
    }
    async function clearModuleContext(path) {
      _resourcemanagers.intervalsManager.removeAll();
      _resourcemanagers.timeoutsManager.removeAll();
      const handleContext = (key, cache, context) => {
        if (cache == null ? void 0 : cache.paths.has(path)) {
          context.delete(key);
        }
      };
      for (const [key, cache] of moduleContexts) {
        handleContext(key, cache, moduleContexts);
      }
      for (const [key, cache] of pendingModuleCaches) {
        handleContext(key, await cache, pendingModuleCaches);
      }
    }
    async function loadWasm(wasm) {
      const modules = {};
      await Promise.all(wasm.map(async (binding) => {
        const module1 = await WebAssembly.compile(await _fs.promises.readFile(binding.filePath));
        modules[binding.name] = module1;
      }));
      return modules;
    }
    function buildEnvironmentVariablesFrom(injectedEnvironments) {
      const pairs = Object.keys(process.env).map((key) => [
        key,
        process.env[key]
      ]);
      const env = Object.fromEntries(pairs);
      for (const key of Object.keys(injectedEnvironments)) {
        env[key] = injectedEnvironments[key];
      }
      env.NEXT_RUNTIME = "edge";
      return env;
    }
    function throwUnsupportedAPIError(name) {
      const error = new Error(`A Node.js API is used (${name}) which is not supported in the Edge Runtime.
Learn more: https://nextjs.org/docs/api-reference/edge-runtime`);
      decorateServerError(error, _constants.COMPILER_NAMES.edgeServer);
      throw error;
    }
    function createProcessPolyfill(env) {
      const processPolyfill = {
        env: buildEnvironmentVariablesFrom(env)
      };
      const overriddenValue = {};
      for (const key of Object.keys(process)) {
        if (key === "env")
          continue;
        Object.defineProperty(processPolyfill, key, {
          get() {
            if (overriddenValue[key] !== void 0) {
              return overriddenValue[key];
            }
            if (typeof process[key] === "function") {
              return () => throwUnsupportedAPIError(`process.${key}`);
            }
            return void 0;
          },
          set(value) {
            overriddenValue[key] = value;
          },
          enumerable: false
        });
      }
      return processPolyfill;
    }
    function addStub(context, name) {
      Object.defineProperty(context, name, {
        get() {
          return function() {
            throwUnsupportedAPIError(name);
          };
        },
        enumerable: false
      });
    }
    function getDecorateUnhandledError(runtime) {
      const EdgeRuntimeError = runtime.evaluate(`Error`);
      return (error) => {
        if (error instanceof EdgeRuntimeError) {
          decorateServerError(error, _constants.COMPILER_NAMES.edgeServer);
        }
      };
    }
    function getDecorateUnhandledRejection(runtime) {
      const EdgeRuntimeError = runtime.evaluate(`Error`);
      return (rejected) => {
        if (rejected.reason instanceof EdgeRuntimeError) {
          decorateServerError(rejected.reason, _constants.COMPILER_NAMES.edgeServer);
        }
      };
    }
    var NativeModuleMap = (() => {
      const mods = {
        "node:buffer": (0, _pick.pick)(_nodebuffer.default, [
          "constants",
          "kMaxLength",
          "kStringMaxLength",
          "Buffer",
          "SlowBuffer"
        ]),
        "node:events": (0, _pick.pick)(_nodeevents.default, [
          "EventEmitter",
          "captureRejectionSymbol",
          "defaultMaxListeners",
          "errorMonitor",
          "listenerCount",
          "on",
          "once"
        ]),
        "node:async_hooks": (0, _pick.pick)(_nodeasync_hooks.default, [
          "AsyncLocalStorage",
          "AsyncResource"
        ]),
        "node:assert": (0, _pick.pick)(_nodeassert.default, [
          "AssertionError",
          "deepEqual",
          "deepStrictEqual",
          "doesNotMatch",
          "doesNotReject",
          "doesNotThrow",
          "equal",
          "fail",
          "ifError",
          "match",
          "notDeepEqual",
          "notDeepStrictEqual",
          "notEqual",
          "notStrictEqual",
          "ok",
          "rejects",
          "strict",
          "strictEqual",
          "throws"
        ]),
        "node:util": (0, _pick.pick)(_nodeutil.default, [
          "_extend",
          "callbackify",
          "format",
          "inherits",
          "promisify",
          "types"
        ])
      };
      return new Map(Object.entries(mods));
    })();
    var requestStore = new _async_hooks.AsyncLocalStorage();
    var edgeSandboxNextRequestContext = (0, _builtinrequestcontext.createLocalRequestContext)();
    async function createModuleContext(options) {
      const warnedEvals = /* @__PURE__ */ new Set();
      const warnedWasmCodegens = /* @__PURE__ */ new Set();
      const { edgeFunctionEntry } = options;
      const wasm = await loadWasm(edgeFunctionEntry.wasm ?? []);
      const runtime = new _edgeruntime.EdgeRuntime({
        codeGeneration: false ? {
          strings: true,
          wasm: true
        } : void 0,
        extend: (context) => {
          context.process = createProcessPolyfill(edgeFunctionEntry.env);
          Object.defineProperty(context, "require", {
            enumerable: false,
            value: (id) => {
              const value = NativeModuleMap.get(id);
              if (!value) {
                throw TypeError("Native module not found: " + id);
              }
              return value;
            }
          });
          if (false) {
            context.__next_log_error__ = function(err) {
              options.onError(err);
            };
          }
          context.__next_eval__ = function __next_eval__(fn) {
            const key = fn.toString();
            if (!warnedEvals.has(key)) {
              const warning = getServerError(new Error(`Dynamic Code Evaluation (e. g. 'eval', 'new Function') not allowed in Edge Runtime
Learn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`), _constants.COMPILER_NAMES.edgeServer);
              warning.name = "DynamicCodeEvaluationWarning";
              Error.captureStackTrace(warning, __next_eval__);
              warnedEvals.add(key);
              options.onWarning(warning);
            }
            return fn();
          };
          context.__next_webassembly_compile__ = function __next_webassembly_compile__(fn) {
            const key = fn.toString();
            if (!warnedWasmCodegens.has(key)) {
              const warning = getServerError(new Error(`Dynamic WASM code generation (e. g. 'WebAssembly.compile') not allowed in Edge Runtime.
Learn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`), _constants.COMPILER_NAMES.edgeServer);
              warning.name = "DynamicWasmCodeGenerationWarning";
              Error.captureStackTrace(warning, __next_webassembly_compile__);
              warnedWasmCodegens.add(key);
              options.onWarning(warning);
            }
            return fn();
          };
          context.__next_webassembly_instantiate__ = async function __next_webassembly_instantiate__(fn) {
            const result = await fn();
            const instantiatedFromBuffer = result.hasOwnProperty("module");
            const key = fn.toString();
            if (instantiatedFromBuffer && !warnedWasmCodegens.has(key)) {
              const warning = getServerError(new Error(`Dynamic WASM code generation ('WebAssembly.instantiate' with a buffer parameter) not allowed in Edge Runtime.
Learn More: https://nextjs.org/docs/messages/edge-dynamic-code-evaluation`), _constants.COMPILER_NAMES.edgeServer);
              warning.name = "DynamicWasmCodeGenerationWarning";
              Error.captureStackTrace(warning, __next_webassembly_instantiate__);
              warnedWasmCodegens.add(key);
              options.onWarning(warning);
            }
            return result;
          };
          const __fetch = context.fetch;
          context.fetch = async (input, init = {}) => {
            var _init_headers_get;
            const callingError = new Error("[internal]");
            const assetResponse = await (0, _fetchinlineassets.fetchInlineAsset)({
              input,
              assets: options.edgeFunctionEntry.assets,
              distDir: options.distDir,
              context
            });
            if (assetResponse) {
              return assetResponse;
            }
            init.headers = new Headers(init.headers ?? {});
            const store = requestStore.getStore();
            if ((store == null ? void 0 : store.headers.has("x-middleware-subrequest")) && !init.headers.has("x-middleware-subrequest")) {
              init.headers.set("x-middleware-subrequest", store.headers.get("x-middleware-subrequest") ?? "");
            }
            const prevs = ((_init_headers_get = init.headers.get(`x-middleware-subrequest`)) == null ? void 0 : _init_headers_get.split(":")) || [];
            const value = prevs.concat(options.moduleName).join(":");
            init.headers.set("x-middleware-subrequest", value);
            if (!init.headers.has("user-agent")) {
              init.headers.set(`user-agent`, `Next.js Middleware`);
            }
            const response = typeof input === "object" && "url" in input ? __fetch(input.url, {
              ...(0, _pick.pick)(input, [
                "method",
                "body",
                "cache",
                "credentials",
                "integrity",
                "keepalive",
                "mode",
                "redirect",
                "referrer",
                "referrerPolicy",
                "signal"
              ]),
              ...init,
              headers: {
                ...Object.fromEntries(input.headers),
                ...Object.fromEntries(init.headers)
              }
            }) : __fetch(String(input), init);
            return await response.catch((err) => {
              callingError.message = err.message;
              err.stack = callingError.stack;
              throw err;
            });
          };
          const __Request = context.Request;
          context.Request = class extends __Request {
            constructor(input, init) {
              const url = typeof input !== "string" && "url" in input ? input.url : String(input);
              (0, _utils.validateURL)(url);
              super(url, init);
              this.next = init == null ? void 0 : init.next;
            }
          };
          const __redirect = context.Response.redirect.bind(context.Response);
          context.Response.redirect = (...args) => {
            (0, _utils.validateURL)(args[0]);
            return __redirect(...args);
          };
          for (const name of _constants.EDGE_UNSUPPORTED_NODE_APIS) {
            addStub(context, name);
          }
          Object.assign(context, wasm);
          context.performance = performance;
          context.AsyncLocalStorage = _async_hooks.AsyncLocalStorage;
          context.setInterval = (...args) => _resourcemanagers.intervalsManager.add(args);
          context.clearInterval = (interval) => _resourcemanagers.intervalsManager.remove(interval);
          context.setTimeout = (...args) => _resourcemanagers.timeoutsManager.add(args);
          context.clearTimeout = (timeout) => _resourcemanagers.timeoutsManager.remove(timeout);
          const NEXT_REQUEST_CONTEXT_SYMBOL = context.Symbol.for("@next/request-context");
          Object.defineProperty(context, NEXT_REQUEST_CONTEXT_SYMBOL, {
            enumerable: false,
            value: edgeSandboxNextRequestContext
          });
          return context;
        }
      });
      const decorateUnhandledError = getDecorateUnhandledError(runtime);
      runtime.context.addEventListener("error", decorateUnhandledError);
      const decorateUnhandledRejection = getDecorateUnhandledRejection(runtime);
      runtime.context.addEventListener("unhandledrejection", decorateUnhandledRejection);
      return {
        runtime,
        paths: /* @__PURE__ */ new Map(),
        warnedEvals: /* @__PURE__ */ new Set()
      };
    }
    function getModuleContextShared(options) {
      let deferredModuleContext = pendingModuleCaches.get(options.moduleName);
      if (!deferredModuleContext) {
        deferredModuleContext = createModuleContext(options);
        pendingModuleCaches.set(options.moduleName, deferredModuleContext);
      }
      return deferredModuleContext;
    }
    async function getModuleContext(options) {
      let lazyModuleContext;
      if (options.useCache) {
        lazyModuleContext = moduleContexts.get(options.moduleName) || await getModuleContextShared(options);
      }
      if (!lazyModuleContext) {
        lazyModuleContext = await createModuleContext(options);
        moduleContexts.set(options.moduleName, lazyModuleContext);
      }
      const moduleContext = lazyModuleContext;
      const evaluateInContext = (filepath) => {
        if (!moduleContext.paths.has(filepath)) {
          const content = (0, _fs.readFileSync)(filepath, "utf-8");
          try {
            (0, _vm.runInContext)(content, moduleContext.runtime.context, {
              filename: filepath
            });
            moduleContext.paths.set(filepath, content);
          } catch (error) {
            if (options.useCache) {
              moduleContext == null ? void 0 : moduleContext.paths.delete(filepath);
            }
            throw error;
          }
        }
      };
      return {
        ...moduleContext,
        evaluateInContext
      };
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/sandbox.js
var require_sandbox = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/sandbox.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all)
        Object.defineProperty(target, name, {
          enumerable: true,
          get: all[name]
        });
    }
    _export(exports, {
      ErrorSource: function() {
        return ErrorSource;
      },
      getRuntimeContext: function() {
        return getRuntimeContext;
      },
      run: function() {
        return run;
      }
    });
    var _context = require_context2();
    var _bodystreams = require_body_streams();
    var _approuterheaders = require_app_router_headers();
    var _builtinrequestcontext = require_builtin_request_context();
    var ErrorSource = Symbol("SandboxError");
    var FORBIDDEN_HEADERS = [
      "content-length",
      "content-encoding",
      "transfer-encoding"
    ];
    function withTaggedErrors(fn) {
      if (false) {
        const { getServerError } = null;
        return (params) => fn(params).then((result) => {
          var _result_waitUntil;
          return {
            ...result,
            waitUntil: result == null ? void 0 : (_result_waitUntil = result.waitUntil) == null ? void 0 : _result_waitUntil.catch((error) => {
              throw getServerError(error, "edge-server");
            })
          };
        }).catch((error) => {
          throw getServerError(error, "edge-server");
        });
      }
      return fn;
    }
    async function getRuntimeContext(params) {
      const { runtime, evaluateInContext } = await (0, _context.getModuleContext)({
        moduleName: params.name,
        onWarning: params.onWarning ?? (() => {
        }),
        onError: params.onError ?? (() => {
        }),
        useCache: params.useCache !== false,
        edgeFunctionEntry: params.edgeFunctionEntry,
        distDir: params.distDir
      });
      if (params.incrementalCache) {
        runtime.context.globalThis.__incrementalCache = params.incrementalCache;
      }
      if (params.serverComponentsHmrCache) {
        runtime.context.globalThis.__serverComponentsHmrCache = params.serverComponentsHmrCache;
      }
      for (const paramPath of params.paths) {
        evaluateInContext(paramPath);
      }
      return runtime;
    }
    var run = withTaggedErrors(async function runWithTaggedErrors(params) {
      var _params_request_body;
      const runtime = await getRuntimeContext(params);
      const subreq = params.request.headers[`x-middleware-subrequest`];
      const subrequests = typeof subreq === "string" ? subreq.split(":") : [];
      const MAX_RECURSION_DEPTH = 5;
      const depth = subrequests.reduce((acc, curr) => curr === params.name ? acc + 1 : acc, 0);
      if (depth >= MAX_RECURSION_DEPTH) {
        return {
          waitUntil: Promise.resolve(),
          response: new runtime.context.Response(null, {
            headers: {
              "x-middleware-next": "1"
            }
          })
        };
      }
      const edgeFunction = (await runtime.context._ENTRIES[`middleware_${params.name}`]).default;
      const cloned = ![
        "HEAD",
        "GET"
      ].includes(params.request.method) ? (_params_request_body = params.request.body) == null ? void 0 : _params_request_body.cloneBodyStream() : void 0;
      const KUint8Array = runtime.evaluate("Uint8Array");
      const urlInstance = new URL(params.request.url);
      urlInstance.searchParams.delete(_approuterheaders.NEXT_RSC_UNION_QUERY);
      params.request.url = urlInstance.toString();
      const headers = new Headers();
      for (const [key, value] of Object.entries(params.request.headers)) {
        headers.set(key, (value == null ? void 0 : value.toString()) ?? "");
      }
      try {
        let result = void 0;
        const builtinRequestCtx = {
          ...(0, _builtinrequestcontext.getBuiltinRequestContext)(),
          // FIXME(after):
          // arguably, this is an abuse of "@next/request-context" --
          // it'd make more sense to simply forward its existing value into the sandbox (in `createModuleContext`)
          // but here we're using it to just pass in `waitUntil` regardless if we were running in this context or not.
          waitUntil: params.request.waitUntil
        };
        await _context.edgeSandboxNextRequestContext.run(builtinRequestCtx, () => _context.requestStore.run({
          headers
        }, async () => {
          result = await edgeFunction({
            request: {
              ...params.request,
              body: cloned && (0, _bodystreams.requestToBodyStream)(runtime.context, KUint8Array, cloned)
            }
          });
          for (const headerName of FORBIDDEN_HEADERS) {
            result.response.headers.delete(headerName);
          }
        }));
        if (!result)
          throw new Error("Edge function did not return a response");
        return result;
      } finally {
        var _params_request_body1;
        await ((_params_request_body1 = params.request.body) == null ? void 0 : _params_request_body1.finalize());
      }
    });
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/index.js
var require_sandbox2 = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/web/sandbox/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "clearModuleContext", {
      enumerable: true,
      get: function() {
        return _context.clearModuleContext;
      }
    });
    _export_star(require_sandbox(), exports);
    var _context = require_context2();
    function _export_star(from, to) {
      Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
          Object.defineProperty(to, k, {
            enumerable: true,
            get: function() {
              return from[k];
            }
          });
        }
      });
      return from;
    }
  }
});

// .worker-next/.next/standalone/node_modules/next/dist/server/next-server.js
var require_next_server = __commonJS({
  ".worker-next/.next/standalone/node_modules/next/dist/server/next-server.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return NextNodeServer;
      }
    });
    require_node_environment();
    init_empty();
    require_node_polyfill_crypto();
    var _utils = require_utils3();
    var _fs = /* @__PURE__ */ _interop_require_default(require("fs"));
    var _path = require("path");
    var _routematcher = require_route_matcher();
    var _requestmeta = require_request_meta();
    var _constants = require_constants3();
    var _findpagesdir = require_find_pages_dir();
    var _node = require_node();
    var _sendpayload = require_send_payload();
    var _parseurl = require_parse_url();
    var _log = /* @__PURE__ */ _interop_require_wildcard(require_log());
    var _baseserver = /* @__PURE__ */ _interop_require_wildcard(_export_star(require_base_server(), exports));
    var _require = require_require();
    var _denormalizepagepath = require_denormalize_page_path();
    var _normalizepagepath = require_normalize_page_path();
    var _loadcomponents = require_load_components();
    var _iserror = /* @__PURE__ */ _interop_require_wildcard(require_is_error());
    var _utils1 = require_utils();
    var _middlewareroutematcher = require_middleware_route_matcher();
    var _env = (init_env(), __toCommonJS(env_exports));
    var _querystring = require_querystring();
    var _removetrailingslash = require_remove_trailing_slash();
    var _getnextpathnameinfo = require_get_next_pathname_info();
    var _bodystreams = require_body_streams();
    var _apiutils = require_api_utils();
    var _responsecache = /* @__PURE__ */ _interop_require_wildcard(require_response_cache());
    var _incrementalcache = require_incremental_cache();
    var _apppaths = require_app_paths();
    var _setuphttpagentenv = require_setup_http_agent_env();
    var _pagesapiroutematch = require_pages_api_route_match();
    var _constants1 = require_constants();
    var _tracer = require_tracer();
    var _constants2 = require_constants2();
    var _nodefsmethods = (init_empty(), __toCommonJS(empty_exports));
    var _routeregex = require_route_regex();
    var _pipereadable = require_pipe_readable();
    var _mockrequest = require_mock_request();
    var _approuterheaders = require_app_router_headers();
    var _nextrequest = require_next_request();
    var _routemoduleloader = require_route_module_loader();
    var _loadmanifest = require_load_manifest();
    var _modulerender = require_module_render();
    var _modulerender1 = require_module_render2();
    var _interopdefault = require_interop_default();
    var _formatdynamicimportpath = require_format_dynamic_import_path();
    var _generateinterceptionroutesrewrites = require_generate_interception_routes_rewrites();
    var _routekind = require_route_kind();
    function _export_star(from, to) {
      Object.keys(from).forEach(function(k) {
        if (k !== "default" && !Object.prototype.hasOwnProperty.call(to, k)) {
          Object.defineProperty(to, k, {
            enumerable: true,
            get: function() {
              return from[k];
            }
          });
        }
      });
      return from;
    }
    function _interop_require_default(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interop_require_wildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {
        __proto__: null
      };
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var dynamicImportEsmDefault = true ? (id) => import(
      /* webpackIgnore: true */
      id
    ).then((mod) => mod.default || mod) : (id) => import(id).then((mod) => mod.default || mod);
    var dynamicRequire = true ? __require : __require;
    var MiddlewareMatcherCache = /* @__PURE__ */ new WeakMap();
    function getMiddlewareMatcher(info) {
      const stored = MiddlewareMatcherCache.get(info);
      if (stored) {
        return stored;
      }
      if (!Array.isArray(info.matchers)) {
        throw new Error(`Invariant: invalid matchers for middleware ${JSON.stringify(info)}`);
      }
      const matcher = (0, _middlewareroutematcher.getMiddlewareRouteMatcher)(info.matchers);
      MiddlewareMatcherCache.set(info, matcher);
      return matcher;
    }
    var NextNodeServer = class extends _baseserver.default {
      constructor(options) {
        super(options);
        this.registeredInstrumentation = false;
        this.handleNextImageRequest = async (req, res, parsedUrl) => {
          if (!parsedUrl.pathname || !parsedUrl.pathname.startsWith("/_next/image")) {
            return false;
          }
          if (this.minimalMode || this.nextConfig.output === "export" || true) {
            res.statusCode = 400;
            res.body("Bad Request").send();
            return true;
          } else {
            const { ImageOptimizerCache } = null;
            const imageOptimizerCache = new ImageOptimizerCache({
              distDir: this.distDir,
              nextConfig: this.nextConfig
            });
            const { sendResponse, ImageError } = null;
            if (!this.imageResponseCache) {
              throw new Error("invariant image optimizer cache was not initialized");
            }
            const imagesConfig = this.nextConfig.images;
            if (imagesConfig.loader !== "default" || imagesConfig.unoptimized) {
              await this.render404(req, res);
              return true;
            }
            const paramsResult = ImageOptimizerCache.validateParams(req.originalRequest, parsedUrl.query, this.nextConfig, !!this.renderOpts.dev);
            if ("errorMessage" in paramsResult) {
              res.statusCode = 400;
              res.body(paramsResult.errorMessage).send();
              return true;
            }
            const cacheKey = ImageOptimizerCache.getCacheKey(paramsResult);
            try {
              var _cacheEntry_value;
              const { getExtension } = null;
              const cacheEntry = await this.imageResponseCache.get(cacheKey, async ({ previousCacheEntry }) => {
                const { buffer, contentType, maxAge, upstreamEtag, etag } = await this.imageOptimizer(req, res, paramsResult, previousCacheEntry);
                return {
                  value: {
                    kind: _responsecache.CachedRouteKind.IMAGE,
                    buffer,
                    etag,
                    extension: getExtension(contentType),
                    upstreamEtag
                  },
                  isFallback: false,
                  revalidate: maxAge
                };
              }, {
                routeKind: _routekind.RouteKind.IMAGE,
                incrementalCache: imageOptimizerCache,
                isFallback: false
              });
              if ((cacheEntry == null ? void 0 : (_cacheEntry_value = cacheEntry.value) == null ? void 0 : _cacheEntry_value.kind) !== _responsecache.CachedRouteKind.IMAGE) {
                throw new Error("invariant did not get entry from image response cache");
              }
              sendResponse(req.originalRequest, res.originalResponse, paramsResult.href, cacheEntry.value.extension, cacheEntry.value.buffer, cacheEntry.value.etag, paramsResult.isStatic, cacheEntry.isMiss ? "MISS" : cacheEntry.isStale ? "STALE" : "HIT", imagesConfig, cacheEntry.revalidate || 0, Boolean(this.renderOpts.dev));
              return true;
            } catch (err) {
              if (err instanceof ImageError) {
                res.statusCode = err.statusCode;
                res.body(err.message).send();
                return true;
              }
              throw err;
            }
          }
        };
        this.handleCatchallRenderRequest = async (req, res, parsedUrl) => {
          let { pathname, query } = parsedUrl;
          if (!pathname) {
            throw new Error("Invariant: pathname is undefined");
          }
          query._nextBubbleNoFallback = undefined;
          try {
            var _this_i18nProvider;
            pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);
            const options2 = {
              i18n: (_this_i18nProvider = this.i18nProvider) == null ? void 0 : _this_i18nProvider.fromQuery(pathname, query)
            };
            const match = await this.matchers.match(pathname, options2);
            if (!match) {
              await this.render(req, res, pathname, query, parsedUrl, true);
              return true;
            }
            (0, _requestmeta.addRequestMeta)(req, "match", match);
            const edgeFunctionsPages = this.getEdgeFunctionsPages();
            for (const edgeFunctionsPage of edgeFunctionsPages) {
              if (edgeFunctionsPage !== match.definition.page)
                continue;
              if (this.nextConfig.output === "export") {
                await this.render404(req, res, parsedUrl);
                return true;
              }
              delete query._nextBubbleNoFallback;
              delete query[_approuterheaders.NEXT_RSC_UNION_QUERY];
              try {
                const handled = await this.runEdgeFunction({
                  req,
                  res,
                  query,
                  params: match.params,
                  page: match.definition.page,
                  match,
                  appPaths: null
                });
                if (handled)
                  return true;
              } catch (apiError) {
                await this.instrumentationOnRequestError(apiError, req, {
                  routePath: match.definition.page,
                  routerKind: "Pages Router",
                  routeType: "route",
                  // Edge runtime does not support ISR
                  revalidateReason: void 0
                });
                throw apiError;
              }
            }
            if ((0, _pagesapiroutematch.isPagesAPIRouteMatch)(match)) {
              if (this.nextConfig.output === "export") {
                await this.render404(req, res, parsedUrl);
                return true;
              }
              delete query._nextBubbleNoFallback;
              const handled = await this.handleApiRequest(req, res, query, match);
              if (handled)
                return true;
            }
            await this.render(req, res, pathname, query, parsedUrl, true);
            return true;
          } catch (err) {
            if (err instanceof _baseserver.NoFallbackError) {
              throw err;
            }
            try {
              if (this.renderOpts.dev) {
                const { formatServerError } = require_format_server_error();
                formatServerError(err);
                await this.logErrorWithOriginalStack(err);
              } else {
                this.logError(err);
              }
              res.statusCode = 500;
              await this.renderError(err, req, res, pathname, query);
              return true;
            } catch {
            }
            throw err;
          }
        };
        this.handleCatchallMiddlewareRequest = async (req, res, parsed) => {
          const isMiddlewareInvoke = (0, _requestmeta.getRequestMeta)(req, "middlewareInvoke");
          if (!isMiddlewareInvoke) {
            return false;
          }
          const handleFinished = () => {
            (0, _requestmeta.addRequestMeta)(req, "middlewareInvoke", true);
            res.body("").send();
            return true;
          };
          const middleware = this.getMiddleware();
          if (!middleware) {
            return handleFinished();
          }
          const initUrl = (0, _requestmeta.getRequestMeta)(req, "initURL");
          const parsedUrl = (0, _parseurl.parseUrl)(initUrl);
          const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedUrl.pathname, {
            nextConfig: this.nextConfig,
            i18nProvider: this.i18nProvider
          });
          parsedUrl.pathname = pathnameInfo.pathname;
          const normalizedPathname = (0, _removetrailingslash.removeTrailingSlash)(parsed.pathname || "");
          if (!middleware.match(normalizedPathname, req, parsedUrl.query)) {
            return handleFinished();
          }
          let result;
          let bubblingResult = false;
          try {
            await this.ensureMiddleware(req.url);
            result = await this.runMiddleware({
              request: req,
              response: res,
              parsedUrl,
              parsed
            });
            if ("response" in result) {
              if (isMiddlewareInvoke) {
                bubblingResult = true;
                throw new _tracer.BubbledError(true, result);
              }
              for (const [key, value] of Object.entries((0, _utils1.toNodeOutgoingHttpHeaders)(result.response.headers))) {
                if (key !== "content-encoding" && value !== void 0) {
                  res.setHeader(key, value);
                }
              }
              res.statusCode = result.response.status;
              const { originalResponse } = res;
              if (result.response.body) {
                await (0, _pipereadable.pipeToNodeResponse)(result.response.body, originalResponse);
              } else {
                originalResponse.end();
              }
              return true;
            }
          } catch (err) {
            if (bubblingResult) {
              throw err;
            }
            if ((0, _iserror.default)(err) && err.code === "ENOENT") {
              await this.render404(req, res, parsed);
              return true;
            }
            if (err instanceof _utils.DecodeError) {
              res.statusCode = 400;
              await this.renderError(err, req, res, parsed.pathname || "");
              return true;
            }
            const error = (0, _iserror.getProperError)(err);
            console.error(error);
            res.statusCode = 500;
            await this.renderError(error, req, res, parsed.pathname || "");
            return true;
          }
          return result.finished;
        };
        if (this.renderOpts.optimizeCss) {
          process.env.__NEXT_OPTIMIZE_CSS = JSON.stringify(true);
        }
        if (this.renderOpts.nextScriptWorkers) {
          process.env.__NEXT_SCRIPT_WORKERS = JSON.stringify(true);
        }
        process.env.NEXT_DEPLOYMENT_ID = this.nextConfig.deploymentId || "";
        if (!this.minimalMode) {
          this.imageResponseCache = new _responsecache.default(this.minimalMode);
        }
        const { appDocumentPreloading } = this.nextConfig.experimental;
        const isDefaultEnabled = typeof appDocumentPreloading === "undefined";
        if (!options.dev && (appDocumentPreloading === true || !(this.minimalMode && isDefaultEnabled))) {
          (0, _loadcomponents.loadComponents)({
            distDir: this.distDir,
            page: "/_document",
            isAppPath: false
          }).catch(() => {
          });
          (0, _loadcomponents.loadComponents)({
            distDir: this.distDir,
            page: "/_app",
            isAppPath: false
          }).catch(() => {
          });
        }
        if (!options.dev && !this.minimalMode && this.nextConfig.experimental.preloadEntriesOnStart) {
          this.unstable_preloadEntries();
        }
        if (!options.dev) {
          const { dynamicRoutes = [] } = this.getRoutesManifest() ?? {};
          this.dynamicRoutes = dynamicRoutes.map((r) => {
            const regex = (0, _routeregex.getRouteRegex)(r.page);
            const match = (0, _routematcher.getRouteMatcher)(regex);
            return {
              match,
              page: r.page,
              re: regex.re
            };
          });
        }
        (0, _setuphttpagentenv.setHttpClientAndAgentOptions)(this.nextConfig);
        if (this.serverOptions.experimentalTestProxy) {
          process.env.NEXT_PRIVATE_TEST_PROXY = "true";
          const { interceptTestApis } = require_server();
          interceptTestApis();
        }
        this.middlewareManifestPath = (0, _path.join)(this.serverDistDir, _constants.MIDDLEWARE_MANIFEST);
        if (!options.dev) {
          this.prepare().catch((err) => {
            console.error("Failed to prepare server", err);
          });
        }
      }
      async unstable_preloadEntries() {
        const appPathsManifest = this.getAppPathsManifest();
        const pagesManifest = this.getPagesManifest();
        for (const page of Object.keys(pagesManifest || {})) {
          await (0, _loadcomponents.loadComponents)({
            distDir: this.distDir,
            page,
            isAppPath: false
          }).catch(() => {
          });
        }
        for (const page of Object.keys(appPathsManifest || {})) {
          await (0, _loadcomponents.loadComponents)({
            distDir: this.distDir,
            page,
            isAppPath: true
          }).then(async ({ ComponentMod }) => {
            const webpackRequire = ComponentMod.__next_app__.require;
            if (webpackRequire == null ? void 0 : webpackRequire.m) {
              for (const id of Object.keys(webpackRequire.m)) {
                await webpackRequire(id);
              }
            }
          }).catch(() => {
          });
        }
      }
      async handleUpgrade() {
      }
      async loadInstrumentationModule() {
        if (!this.serverOptions.dev) {
          try {
            this.instrumentation = await dynamicRequire((0, _path.resolve)(this.serverOptions.dir || ".", this.serverOptions.conf.distDir, "server", _constants1.INSTRUMENTATION_HOOK_FILENAME));
          } catch (err) {
            if (err.code !== "MODULE_NOT_FOUND") {
              throw new Error("An error occurred while loading the instrumentation hook", {
                cause: err
              });
            }
          }
        }
        return this.instrumentation;
      }
      async prepareImpl() {
        await super.prepareImpl();
        await this.runInstrumentationHookIfAvailable();
      }
      async runInstrumentationHookIfAvailable() {
        var _this_instrumentation_register, _this_instrumentation;
        if (this.registeredInstrumentation)
          return;
        this.registeredInstrumentation = true;
        await ((_this_instrumentation = this.instrumentation) == null ? void 0 : (_this_instrumentation_register = _this_instrumentation.register) == null ? void 0 : _this_instrumentation_register.call(_this_instrumentation));
      }
      loadEnvConfig({ dev, forceReload, silent }) {
        (0, _env.loadEnvConfig)(this.dir, dev, silent ? {
          info: () => {
          },
          error: () => {
          }
        } : _log, forceReload);
      }
      async getIncrementalCache({ requestHeaders, requestProtocol }) {
        const dev = !!this.renderOpts.dev;
        let CacheHandler;
        const cacheHandler = null;
CacheHandler = (await import('./cache-handler.mjs')).OpenNextCacheHandler;

        if (cacheHandler) {
          CacheHandler = (0, _interopdefault.interopDefault)(await dynamicImportEsmDefault((0, _formatdynamicimportpath.formatDynamicImportPath)(this.distDir, cacheHandler)));
        }
        const { cacheHandlers } = this.nextConfig.experimental;
        if (!globalThis.__nextCacheHandlers && cacheHandlers) {
          globalThis.__nextCacheHandlers = {};
          for (const key of Object.keys(cacheHandlers)) {
            if (cacheHandlers[key]) {
              globalThis.__nextCacheHandlers[key] = (0, _interopdefault.interopDefault)(await dynamicImportEsmDefault((0, _formatdynamicimportpath.formatDynamicImportPath)(this.distDir, cacheHandlers[key])));
            }
          }
        }
        return new _incrementalcache.IncrementalCache({
          fs: this.getCacheFilesystem(),
          dev,
          requestHeaders,
          requestProtocol,
          dynamicIO: Boolean(this.nextConfig.experimental.dynamicIO),
          allowedRevalidateHeaderKeys: this.nextConfig.experimental.allowedRevalidateHeaderKeys,
          minimalMode: this.minimalMode,
          serverDistDir: this.serverDistDir,
          fetchCache: true,
          fetchCacheKeyPrefix: this.nextConfig.experimental.fetchCacheKeyPrefix,
          maxMemoryCacheSize: this.nextConfig.cacheMaxMemorySize,
          flushToDisk: !this.minimalMode && this.nextConfig.experimental.isrFlushToDisk,
          getPrerenderManifest: () => this.getPrerenderManifest(),
          CurCacheHandler: CacheHandler
        });
      }
      getResponseCache() {
        return new _responsecache.default(this.minimalMode);
      }
      getPublicDir() {
        return (0, _path.join)(this.dir, _constants.CLIENT_PUBLIC_FILES_PATH);
      }
      getHasStaticDir() {
        return _fs.default.existsSync((0, _path.join)(this.dir, "static"));
      }
      getPagesManifest() {
        return (0, _loadmanifest.loadManifest)((0, _path.join)(this.serverDistDir, _constants.PAGES_MANIFEST));
      }
      getAppPathsManifest() {
        if (!this.enabledDirectories.app)
          return void 0;
        return (0, _loadmanifest.loadManifest)((0, _path.join)(this.serverDistDir, _constants.APP_PATHS_MANIFEST));
      }
      getinterceptionRoutePatterns() {
        if (!this.enabledDirectories.app)
          return [];
        const routesManifest = this.getRoutesManifest();
        return (routesManifest == null ? void 0 : routesManifest.rewrites.beforeFiles.filter(_generateinterceptionroutesrewrites.isInterceptionRouteRewrite).map((rewrite) => new RegExp(rewrite.regex))) ?? [];
      }
      async hasPage(pathname) {
        var _this_nextConfig_i18n;
        return !!(0, _require.getMaybePagePath)(pathname, this.distDir, (_this_nextConfig_i18n = this.nextConfig.i18n) == null ? void 0 : _this_nextConfig_i18n.locales, this.enabledDirectories.app);
      }
      getBuildId() {
      return "z2fBFOvp2whhL7a5Yf29l";
    
        const buildIdFile = (0, _path.join)(this.distDir, _constants.BUILD_ID_FILE);
        try {
          return _fs.default.readFileSync(buildIdFile, "utf8").trim();
        } catch (err) {
          if (err.code === "ENOENT") {
            throw new Error(`Could not find a production build in the '${this.distDir}' directory. Try building your app with 'next build' before starting the production server. https://nextjs.org/docs/messages/production-start-no-build-id`);
          }
          throw err;
        }
      }
      getEnabledDirectories(dev) {
        const dir = dev ? this.dir : this.serverDistDir;
        return {
          app: (0, _findpagesdir.findDir)(dir, "app") ? true : false,
          pages: (0, _findpagesdir.findDir)(dir, "pages") ? true : false
        };
      }
      sendRenderResult(req, res, options) {
        return (0, _sendpayload.sendRenderResult)({
          req: req.originalRequest,
          res: res.originalResponse,
          result: options.result,
          type: options.type,
          generateEtags: options.generateEtags,
          poweredByHeader: options.poweredByHeader,
          revalidate: options.revalidate,
          expireTime: options.expireTime
        });
      }
      async runApi(req, res, query, match) {
        const edgeFunctionsPages = this.getEdgeFunctionsPages();
        for (const edgeFunctionsPage of edgeFunctionsPages) {
          if (edgeFunctionsPage === match.definition.pathname) {
            const handledAsEdgeFunction = await this.runEdgeFunction({
              req,
              res,
              query,
              params: match.params,
              page: match.definition.pathname,
              appPaths: null
            });
            if (handledAsEdgeFunction) {
              return true;
            }
          }
        }
        const module2 = await _routemoduleloader.RouteModuleLoader.load(match.definition.filename);
        query = {
          ...query,
          ...match.params
        };
        delete query.__nextLocale;
        delete query.__nextDefaultLocale;
        delete query.__nextInferredLocaleFromDefault;
        await module2.render(req.originalRequest, res.originalResponse, {
          previewProps: this.renderOpts.previewProps,
          revalidate: this.revalidate.bind(this),
          trustHostHeader: this.nextConfig.experimental.trustHostHeader,
          allowedRevalidateHeaderKeys: this.nextConfig.experimental.allowedRevalidateHeaderKeys,
          hostname: this.fetchHostname,
          minimalMode: this.minimalMode,
          dev: this.renderOpts.dev === true,
          query,
          params: match.params,
          page: match.definition.pathname,
          onError: this.instrumentationOnRequestError.bind(this),
          multiZoneDraftMode: this.nextConfig.experimental.multiZoneDraftMode
        });
        return true;
      }
      async renderHTML(req, res, pathname, query, renderOpts) {
        return (0, _tracer.getTracer)().trace(_constants2.NextNodeServerSpan.renderHTML, async () => this.renderHTMLImpl(req, res, pathname, query, renderOpts));
      }
      async renderHTMLImpl(req, res, pathname, query, renderOpts) {
        if (true) {
          throw new Error("Invariant: renderHTML should not be called in minimal mode");
        } else {
          renderOpts.nextFontManifest = this.nextFontManifest;
          if (this.enabledDirectories.app && renderOpts.isAppPath) {
            return (0, _modulerender.lazyRenderAppPage)(
              req,
              res,
              pathname,
              query,
              // This code path does not service revalidations for unknown param
              // shells. As a result, we don't need to pass in the unknown params.
              null,
              renderOpts
            );
          }
          return (0, _modulerender1.lazyRenderPagesPage)(req.originalRequest, res.originalResponse, pathname, query, renderOpts);
        }
      }
      async imageOptimizer(req, res, paramsResult, previousCacheEntry) {
        if (true) {
          throw new Error("invariant: imageOptimizer should not be called in minimal mode");
        } else {
          const { imageOptimizer, fetchExternalImage, fetchInternalImage } = null;
          const handleInternalReq = async (newReq, newRes) => {
            if (newReq.url === req.url) {
              throw new Error(`Invariant attempted to optimize _next/image itself`);
            }
            if (!this.routerServerHandler) {
              throw new Error(`Invariant missing routerServerHandler`);
            }
            await this.routerServerHandler(newReq, newRes);
            return;
          };
          const { isAbsolute, href } = paramsResult;
          const imageUpstream = isAbsolute ? await fetchExternalImage(href) : await fetchInternalImage(href, req.originalRequest, res.originalResponse, handleInternalReq);
          return imageOptimizer(imageUpstream, paramsResult, this.nextConfig, this.renderOpts.dev, previousCacheEntry);
        }
      }
      getPagePath(pathname, locales) {
        return (0, _require.getPagePath)(pathname, this.distDir, locales, this.enabledDirectories.app);
      }
      async renderPageComponent(ctx, bubbleNoFallback) {
        const edgeFunctionsPages = this.getEdgeFunctionsPages() || [];
        if (edgeFunctionsPages.length) {
          const appPaths = this.getOriginalAppPaths(ctx.pathname);
          const isAppPath = Array.isArray(appPaths);
          let page = ctx.pathname;
          if (isAppPath) {
            page = appPaths[0];
          }
          for (const edgeFunctionsPage of edgeFunctionsPages) {
            if (edgeFunctionsPage === page) {
              await this.runEdgeFunction({
                req: ctx.req,
                res: ctx.res,
                query: ctx.query,
                params: ctx.renderOpts.params,
                page,
                appPaths
              });
              return null;
            }
          }
        }
        return super.renderPageComponent(ctx, bubbleNoFallback);
      }
      async findPageComponents({ page, query, params, isAppPath, url }) {
        return (0, _tracer.getTracer)().trace(_constants2.NextNodeServerSpan.findPageComponents, {
          spanName: "resolve page components",
          attributes: {
            "next.route": isAppPath ? (0, _apppaths.normalizeAppPath)(page) : page
          }
        }, () => this.findPageComponentsImpl({
          page,
          query,
          params,
          isAppPath,
          url
        }));
      }
      async findPageComponentsImpl({ page, query, params, isAppPath, url: _url }) {
        const pagePaths = [
          page
        ];
        if (query.amp) {
          pagePaths.unshift((isAppPath ? (0, _apppaths.normalizeAppPath)(page) : (0, _normalizepagepath.normalizePagePath)(page)) + ".amp");
        }
        if (query.__nextLocale) {
          pagePaths.unshift(...pagePaths.map((path) => `/${query.__nextLocale}${path === "/" ? "" : path}`));
        }
        for (const pagePath of pagePaths) {
          try {
            const components = await (0, _loadcomponents.loadComponents)({
              distDir: this.distDir,
              page: pagePath,
              isAppPath
            });
            if (query.__nextLocale && typeof components.Component === "string" && !pagePath.startsWith(`/${query.__nextLocale}`)) {
              continue;
            }
            return {
              components,
              query: {
                ...!this.renderOpts.isExperimentalCompile && components.getStaticProps ? {
                  amp: query.amp,
                  __nextDataReq: query.__nextDataReq,
                  __nextLocale: query.__nextLocale,
                  __nextDefaultLocale: query.__nextDefaultLocale
                } : query,
                // For appDir params is excluded.
                ...(isAppPath ? {} : params) || {}
              }
            };
          } catch (err) {
            if (!(err instanceof _utils.PageNotFoundError)) {
              throw err;
            }
          }
        }
        return null;
      }
      getNextFontManifest() {
        return (0, _loadmanifest.loadManifest)((0, _path.join)(this.distDir, "server", _constants.NEXT_FONT_MANIFEST + ".json"));
      }
      // Used in development only, overloaded in next-dev-server
      async logErrorWithOriginalStack(_err, _type) {
        throw new Error("Invariant: logErrorWithOriginalStack can only be called on the development server");
      }
      // Used in development only, overloaded in next-dev-server
      async ensurePage(_opts) {
        throw new Error("Invariant: ensurePage can only be called on the development server");
      }
      /**
      * Resolves `API` request, in development builds on demand
      * @param req http request
      * @param res http response
      * @param pathname path of request
      */
      async handleApiRequest(req, res, query, match) {
        return this.runApi(req, res, query, match);
      }
      getCacheFilesystem() {
        return _nodefsmethods.nodeFs;
      }
      normalizeReq(req) {
        return !(req instanceof _node.NodeNextRequest) ? new _node.NodeNextRequest(req) : req;
      }
      normalizeRes(res) {
        return !(res instanceof _node.NodeNextResponse) ? new _node.NodeNextResponse(res) : res;
      }
      getRequestHandler() {
        const handler = this.makeRequestHandler();
        if (this.serverOptions.experimentalTestProxy) {
          const { wrapRequestHandlerNode } = require_server();
          return wrapRequestHandlerNode(handler);
        }
        return handler;
      }
      makeRequestHandler() {
        this.prepare().catch((err) => {
          console.error("Failed to prepare server", err);
        });
        const handler = super.getRequestHandler();
        return (req, res, parsedUrl) => handler(this.normalizeReq(req), this.normalizeRes(res), parsedUrl);
      }
      async revalidate({ urlPath, revalidateHeaders, opts }) {
        const mocked = (0, _mockrequest.createRequestResponseMocks)({
          url: urlPath,
          headers: revalidateHeaders
        });
        const handler = this.getRequestHandler();
        await handler(new _node.NodeNextRequest(mocked.req), new _node.NodeNextResponse(mocked.res));
        await mocked.res.hasStreamed;
        if (mocked.res.getHeader("x-nextjs-cache") !== "REVALIDATED" && !(mocked.res.statusCode === 404 && opts.unstable_onlyGenerated)) {
          throw new Error(`Invalid response ${mocked.res.statusCode}`);
        }
      }
      async render(req, res, pathname, query, parsedUrl, internal = false) {
        return super.render(this.normalizeReq(req), this.normalizeRes(res), pathname, query, parsedUrl, internal);
      }
      async renderToHTML(req, res, pathname, query) {
        return super.renderToHTML(this.normalizeReq(req), this.normalizeRes(res), pathname, query);
      }
      async renderErrorToResponseImpl(ctx, err) {
        const { req, res, query } = ctx;
        const is404 = res.statusCode === 404;
        if (is404 && this.enabledDirectories.app) {
          if (this.renderOpts.dev) {
            await this.ensurePage({
              page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,
              clientOnly: false,
              url: req.url
            }).catch(() => {
            });
          }
          if (this.getEdgeFunctionsPages().includes(_constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY)) {
            await this.runEdgeFunction({
              req,
              res,
              query: query || {},
              params: {},
              page: _constants.UNDERSCORE_NOT_FOUND_ROUTE_ENTRY,
              appPaths: null
            });
            return null;
          }
        }
        return super.renderErrorToResponseImpl(ctx, err);
      }
      async renderError(err, req, res, pathname, query, setHeaders) {
        return super.renderError(err, this.normalizeReq(req), this.normalizeRes(res), pathname, query, setHeaders);
      }
      async renderErrorToHTML(err, req, res, pathname, query) {
        return super.renderErrorToHTML(err, this.normalizeReq(req), this.normalizeRes(res), pathname, query);
      }
      async render404(req, res, parsedUrl, setHeaders) {
        return super.render404(this.normalizeReq(req), this.normalizeRes(res), parsedUrl, setHeaders);
      }
      getMiddlewareManifest() {
        if (this.minimalMode)
          return null;
        const manifest = {"version":3,"middleware":{},"functions":{},"sortedMiddleware":[]};
        return manifest;
      }
      /** Returns the middleware routing item if there is one. */
      getMiddleware() {
        var _manifest_middleware;
        const manifest = this.getMiddlewareManifest();
        const middleware = manifest == null ? void 0 : (_manifest_middleware = manifest.middleware) == null ? void 0 : _manifest_middleware["/"];
        if (!middleware) {
          return;
        }
        return {
          match: getMiddlewareMatcher(middleware),
          page: "/"
        };
      }
      getEdgeFunctionsPages() {
        const manifest = this.getMiddlewareManifest();
        if (!manifest) {
          return [];
        }
        return Object.keys(manifest.functions);
      }
      /**
      * Get information for the edge function located in the provided page
      * folder. If the edge function info can't be found it will throw
      * an error.
      */
      getEdgeFunctionInfo(params) {
        const manifest = this.getMiddlewareManifest();
        if (!manifest) {
          return null;
        }
        let foundPage;
        try {
          foundPage = (0, _denormalizepagepath.denormalizePagePath)((0, _normalizepagepath.normalizePagePath)(params.page));
        } catch (err) {
          return null;
        }
        let pageInfo = params.middleware ? manifest.middleware[foundPage] : manifest.functions[foundPage];
        if (!pageInfo) {
          if (!params.middleware) {
            throw new _utils.PageNotFoundError(foundPage);
          }
          return null;
        }
        return {
          name: pageInfo.name,
          paths: pageInfo.files.map((file) => (0, _path.join)(this.distDir, file)),
          wasm: (pageInfo.wasm ?? []).map((binding) => ({
            ...binding,
            filePath: (0, _path.join)(this.distDir, binding.filePath)
          })),
          assets: pageInfo.assets && pageInfo.assets.map((binding) => {
            return {
              ...binding,
              filePath: (0, _path.join)(this.distDir, binding.filePath)
            };
          }),
          env: pageInfo.env
        };
      }
      /**
      * Checks if a middleware exists. This method is useful for the development
      * server where we need to check the filesystem. Here we just check the
      * middleware manifest.
      */
      async hasMiddleware(pathname) {
        const info = this.getEdgeFunctionInfo({
          page: pathname,
          middleware: true
        });
        return Boolean(info && info.paths.length > 0);
      }
      /**
      * A placeholder for a function to be defined in the development server.
      * It will make sure that the root middleware or an edge function has been compiled
      * so that we can run it.
      */
      async ensureMiddleware(_url) {
      }
      async ensureEdgeFunction(_params) {
      }
      /**
      * This method gets all middleware matchers and execute them when the request
      * matches. It will make sure that each middleware exists and is compiled and
      * ready to be invoked. The development server will decorate it to add warns
      * and errors with rich traces.
      */
      async runMiddleware(params) {
        if (true) {
          throw new Error("invariant: runMiddleware should not be called in minimal mode");
        }
        if ((0, _apiutils.checkIsOnDemandRevalidate)(params.request, this.renderOpts.previewProps).isOnDemandRevalidate) {
          return {
            response: new Response(null, {
              headers: {
                "x-middleware-next": "1"
              }
            })
          };
        }
        let url;
        if (this.nextConfig.skipMiddlewareUrlNormalize) {
          url = (0, _requestmeta.getRequestMeta)(params.request, "initURL");
        } else {
          const query = (0, _querystring.urlQueryToSearchParams)(params.parsed.query).toString();
          const locale = params.parsed.query.__nextLocale;
          url = `${(0, _requestmeta.getRequestMeta)(params.request, "initProtocol")}://${this.fetchHostname || "localhost"}:${this.port}${locale ? `/${locale}` : ""}${params.parsed.pathname}${query ? `?${query}` : ""}`;
        }
        if (!url.startsWith("http")) {
          throw new Error("To use middleware you must provide a `hostname` and `port` to the Next.js Server");
        }
        const page = {};
        const middleware = this.getMiddleware();
        if (!middleware) {
          return {
            finished: false
          };
        }
        if (!await this.hasMiddleware(middleware.page)) {
          return {
            finished: false
          };
        }
        await this.ensureMiddleware(params.request.url);
        const middlewareInfo = this.getEdgeFunctionInfo({
          page: middleware.page,
          middleware: true
        });
        if (!middlewareInfo) {
          throw new _utils.MiddlewareNotFoundError();
        }
        const method = (params.request.method || "GET").toUpperCase();
        const { run } = require_sandbox2();
        const result = await run({
          distDir: this.distDir,
          name: middlewareInfo.name,
          paths: middlewareInfo.paths,
          edgeFunctionEntry: middlewareInfo,
          request: {
            headers: params.request.headers,
            method,
            nextConfig: {
              basePath: this.nextConfig.basePath,
              i18n: this.nextConfig.i18n,
              trailingSlash: this.nextConfig.trailingSlash,
              experimental: this.nextConfig.experimental
            },
            url,
            page,
            body: (0, _requestmeta.getRequestMeta)(params.request, "clonableBody"),
            signal: (0, _nextrequest.signalFromNodeResponse)(params.response.originalResponse),
            waitUntil: this.getWaitUntil()
          },
          useCache: true,
          onWarning: params.onWarning
        });
        if (!this.renderOpts.dev) {
          result.waitUntil.catch((error) => {
            console.error(`Uncaught: middleware waitUntil errored`, error);
          });
        }
        if (!result) {
          this.render404(params.request, params.response, params.parsed);
          return {
            finished: true
          };
        }
        if (result.response.headers.has("set-cookie")) {
          const cookies = result.response.headers.getSetCookie().flatMap((maybeCompoundCookie) => (0, _utils1.splitCookiesString)(maybeCompoundCookie));
          result.response.headers.delete("set-cookie");
          for (const cookie of cookies) {
            result.response.headers.append("set-cookie", cookie);
          }
          (0, _requestmeta.addRequestMeta)(params.request, "middlewareCookie", cookies);
        }
        return result;
      }
      getPrerenderManifest() {
        var _this_renderOpts, _this_serverOptions;
        if (this._cachedPreviewManifest) {
          return this._cachedPreviewManifest;
        }
        if (((_this_renderOpts = this.renderOpts) == null ? void 0 : _this_renderOpts.dev) || ((_this_serverOptions = this.serverOptions) == null ? void 0 : _this_serverOptions.dev) || false || process.env.NEXT_PHASE === _constants.PHASE_PRODUCTION_BUILD) {
          this._cachedPreviewManifest = {
            version: 4,
            routes: {},
            dynamicRoutes: {},
            notFoundRoutes: [],
            preview: {
              previewModeId: require("crypto").randomBytes(16).toString("hex"),
              previewModeSigningKey: require("crypto").randomBytes(32).toString("hex"),
              previewModeEncryptionKey: require("crypto").randomBytes(32).toString("hex")
            }
          };
          return this._cachedPreviewManifest;
        }
        this._cachedPreviewManifest = (0, _loadmanifest.loadManifest)((0, _path.join)(this.distDir, _constants.PRERENDER_MANIFEST));
        return this._cachedPreviewManifest;
      }
      getRoutesManifest() {
        return (0, _tracer.getTracer)().trace(_constants2.NextNodeServerSpan.getRoutesManifest, () => {
          const manifest = (0, _loadmanifest.loadManifest)((0, _path.join)(this.distDir, _constants.ROUTES_MANIFEST));
          let rewrites = manifest.rewrites ?? {
            beforeFiles: [],
            afterFiles: [],
            fallback: []
          };
          if (Array.isArray(rewrites)) {
            rewrites = {
              beforeFiles: [],
              afterFiles: rewrites,
              fallback: []
            };
          }
          return {
            ...manifest,
            rewrites
          };
        });
      }
      attachRequestMeta(req, parsedUrl, isUpgradeReq) {
        var _req_headers_xforwardedproto;
        const protocol = ((_req_headers_xforwardedproto = req.headers["x-forwarded-proto"]) == null ? void 0 : _req_headers_xforwardedproto.includes("https")) ? "https" : "http";
        const initUrl = this.fetchHostname && this.port ? `${protocol}://${this.fetchHostname}:${this.port}${req.url}` : this.nextConfig.experimental.trustHostHeader ? `https://${req.headers.host || "localhost"}${req.url}` : req.url;
        (0, _requestmeta.addRequestMeta)(req, "initURL", initUrl);
        (0, _requestmeta.addRequestMeta)(req, "initQuery", {
          ...parsedUrl.query
        });
        (0, _requestmeta.addRequestMeta)(req, "initProtocol", protocol);
        if (!isUpgradeReq) {
          (0, _requestmeta.addRequestMeta)(req, "clonableBody", (0, _bodystreams.getCloneableBody)(req.originalRequest));
        }
      }
      async runEdgeFunction(params) {
        if (true) {
          throw new Error("Middleware is not supported in minimal mode. Please remove the `NEXT_MINIMAL` environment variable.");
        }
        let edgeInfo;
        const { query, page, match } = params;
        if (!match)
          await this.ensureEdgeFunction({
            page,
            appPaths: params.appPaths,
            url: params.req.url
          });
        edgeInfo = this.getEdgeFunctionInfo({
          page,
          middleware: false
        });
        if (!edgeInfo) {
          return null;
        }
        const isNextDataRequest = !!query.__nextDataReq;
        const initialUrl = new URL((0, _requestmeta.getRequestMeta)(params.req, "initURL") || "/", "http://n");
        const queryString = (0, _querystring.urlQueryToSearchParams)({
          ...Object.fromEntries(initialUrl.searchParams),
          ...query,
          ...params.params
        }).toString();
        if (isNextDataRequest) {
          params.req.headers["x-nextjs-data"] = "1";
        }
        initialUrl.search = queryString;
        const url = initialUrl.toString();
        if (!url.startsWith("http")) {
          throw new Error("To use middleware you must provide a `hostname` and `port` to the Next.js Server");
        }
        const { run } = require_sandbox2();
        const result = await run({
          distDir: this.distDir,
          name: edgeInfo.name,
          paths: edgeInfo.paths,
          edgeFunctionEntry: edgeInfo,
          request: {
            headers: params.req.headers,
            method: params.req.method,
            nextConfig: {
              basePath: this.nextConfig.basePath,
              i18n: this.nextConfig.i18n,
              trailingSlash: this.nextConfig.trailingSlash
            },
            url,
            page: {
              name: params.page,
              ...params.params && {
                params: params.params
              }
            },
            body: (0, _requestmeta.getRequestMeta)(params.req, "clonableBody"),
            signal: (0, _nextrequest.signalFromNodeResponse)(params.res.originalResponse),
            waitUntil: this.getWaitUntil()
          },
          useCache: true,
          onError: params.onError,
          onWarning: params.onWarning,
          incrementalCache: globalThis.__incrementalCache || (0, _requestmeta.getRequestMeta)(params.req, "incrementalCache"),
          serverComponentsHmrCache: (0, _requestmeta.getRequestMeta)(params.req, "serverComponentsHmrCache")
        });
        if (result.fetchMetrics) {
          params.req.fetchMetrics = result.fetchMetrics;
        }
        if (!params.res.statusCode || params.res.statusCode < 400) {
          params.res.statusCode = result.response.status;
          params.res.statusMessage = result.response.statusText;
        }
        result.response.headers.forEach((value, key) => {
          if (key.toLowerCase() === "set-cookie") {
            for (const cookie of (0, _utils1.splitCookiesString)(value)) {
              params.res.appendHeader(key, cookie);
            }
          } else {
            params.res.appendHeader(key, value);
          }
        });
        const { originalResponse } = params.res;
        if (result.response.body) {
          await (0, _pipereadable.pipeToNodeResponse)(result.response.body, originalResponse);
        } else {
          originalResponse.end();
        }
        return result;
      }
      get serverDistDir() {
        if (this._serverDistDir) {
          return this._serverDistDir;
        }
        const serverDistDir = (0, _path.join)(this.distDir, _constants.SERVER_DIRECTORY);
        this._serverDistDir = serverDistDir;
        return serverDistDir;
      }
      async getFallbackErrorComponents(_url) {
        return null;
      }
      async instrumentationOnRequestError(...args) {
        await super.instrumentationOnRequestError(...args);
        if (!this.renderOpts.dev) {
          this.logError(args[0]);
        }
      }
    };
  }
});

// .worker-next/.next/standalone/node_modules/@opennextjs/cloudflare/cli/templates/worker.ts
var import_node = __toESM(require_node());
var import_mock_request = __toESM(require_mock_request());
import { AsyncLocalStorage } from "node:async_hooks";
import Stream from "node:stream";
var NON_BODY_RESPONSES = /* @__PURE__ */ new Set([101, 204, 205, 304]);
var cloudflareContextALS = new AsyncLocalStorage();
globalThis[Symbol.for("__cloudflare-context__")] = new Proxy(
  {},
  {
    ownKeys: () => Reflect.ownKeys(cloudflareContextALS.getStore()),
    getOwnPropertyDescriptor: (_, ...args) => Reflect.getOwnPropertyDescriptor(cloudflareContextALS.getStore(), ...args),
    get: (_, property) => Reflect.get(cloudflareContextALS.getStore(), property),
    set: (_, property, value) => Reflect.set(cloudflareContextALS.getStore(), property, value)
  }
);
var nextConfig = JSON.parse(`{"env":{},"webpack":null,"eslint":{"ignoreDuringBuilds":false},"typescript":{"ignoreBuildErrors":false,"tsconfigPath":"tsconfig.json"},"distDir":"./.next","cleanDistDir":true,"assetPrefix":"","cacheMaxMemorySize":52428800,"configOrigin":"next.config.mjs","useFileSystemPublicRoutes":true,"generateEtags":true,"pageExtensions":["tsx","ts","jsx","js"],"poweredByHeader":true,"compress":true,"images":{"deviceSizes":[640,750,828,1080,1200,1920,2048,3840],"imageSizes":[16,32,48,64,96,128,256,384],"path":"/_next/image","loader":"default","loaderFile":"","domains":[],"disableStaticImages":false,"minimumCacheTTL":60,"formats":["image/webp"],"dangerouslyAllowSVG":false,"contentSecurityPolicy":"script-src 'none'; frame-src 'none'; sandbox;","contentDispositionType":"attachment","remotePatterns":[],"unoptimized":false},"devIndicators":{"appIsrStatus":true,"buildActivity":true,"buildActivityPosition":"bottom-right"},"onDemandEntries":{"maxInactiveAge":60000,"pagesBufferLength":5},"amp":{"canonicalBase":""},"basePath":"","sassOptions":{},"trailingSlash":false,"i18n":null,"productionBrowserSourceMaps":false,"excludeDefaultMomentLocales":true,"serverRuntimeConfig":{},"publicRuntimeConfig":{},"reactProductionProfiling":false,"reactStrictMode":null,"reactMaxHeadersLength":6000,"httpAgentOptions":{"keepAlive":true},"logging":{},"expireTime":31536000,"staticPageGenerationTimeout":60,"output":"standalone","modularizeImports":{"@mui/icons-material":{"transform":"@mui/icons-material/{{member}}"},"lodash":{"transform":"lodash/{{member}}"}},"outputFileTracingRoot":"/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf","experimental":{"cacheLife":{"default":{"stale":300,"revalidate":900,"expire":4294967294},"seconds":{"stale":0,"revalidate":1,"expire":1},"minutes":{"stale":300,"revalidate":60,"expire":3600},"hours":{"stale":300,"revalidate":3600,"expire":86400},"days":{"stale":300,"revalidate":86400,"expire":604800},"weeks":{"stale":300,"revalidate":604800,"expire":2592000},"max":{"stale":300,"revalidate":2592000,"expire":4294967294}},"cacheHandlers":{},"multiZoneDraftMode":false,"appNavFailHandling":false,"prerenderEarlyExit":true,"serverMinification":true,"serverSourceMaps":false,"linkNoTouchStart":false,"caseSensitiveRoutes":false,"preloadEntriesOnStart":true,"clientRouterFilter":true,"clientRouterFilterRedirects":false,"fetchCacheKeyPrefix":"","middlewarePrefetch":"flexible","optimisticClientCache":true,"manualClientBasePath":false,"cpus":11,"memoryBasedWorkersCount":false,"isrFlushToDisk":true,"workerThreads":false,"optimizeCss":false,"nextScriptWorkers":false,"scrollRestoration":false,"externalDir":false,"disableOptimizedLoading":false,"gzipSize":true,"craCompat":false,"esmExternals":true,"fullySpecified":false,"swcTraceProfiling":false,"forceSwcTransforms":false,"largePageDataBytes":128000,"turbo":{"root":"/Users/767878/workspace/reactnextjslearning/reactnextjslearning/globomantics-nots-cf"},"typedRoutes":false,"typedEnv":false,"parallelServerCompiles":false,"parallelServerBuildTraces":false,"ppr":false,"webpackMemoryOptimizations":false,"optimizeServerReact":true,"useEarlyImport":false,"staleTimes":{"dynamic":0,"static":300},"after":false,"serverComponentsHmrCache":true,"staticGenerationMaxConcurrency":8,"staticGenerationMinPagesPerWorker":25,"dynamicIO":false,"optimizePackageImports":["lucide-react","date-fns","lodash-es","ramda","antd","react-bootstrap","ahooks","@ant-design/icons","@headlessui/react","@headlessui-float/react","@heroicons/react/20/solid","@heroicons/react/24/solid","@heroicons/react/24/outline","@visx/visx","@tremor/react","rxjs","@mui/material","@mui/icons-material","recharts","react-use","effect","@effect/schema","@effect/platform","@effect/platform-node","@effect/platform-browser","@effect/platform-bun","@effect/sql","@effect/sql-mssql","@effect/sql-mysql2","@effect/sql-pg","@effect/sql-squlite-node","@effect/sql-squlite-bun","@effect/sql-squlite-wasm","@effect/sql-squlite-react-native","@effect/rpc","@effect/rpc-http","@effect/typeclass","@effect/experimental","@effect/opentelemetry","@material-ui/core","@material-ui/icons","@tabler/icons-react","mui-core","react-icons/ai","react-icons/bi","react-icons/bs","react-icons/cg","react-icons/ci","react-icons/di","react-icons/fa","react-icons/fa6","react-icons/fc","react-icons/fi","react-icons/gi","react-icons/go","react-icons/gr","react-icons/hi","react-icons/hi2","react-icons/im","react-icons/io","react-icons/io5","react-icons/lia","react-icons/lib","react-icons/lu","react-icons/md","react-icons/pi","react-icons/ri","react-icons/rx","react-icons/si","react-icons/sl","react-icons/tb","react-icons/tfi","react-icons/ti","react-icons/vsc","react-icons/wi"],"trustHostHeader":false,"isExperimentalCompile":false},"bundlePagesRouterDependencies":false,"configFileName":"next.config.mjs"}`);
var requestHandler = null;
var worker_default = {
  async fetch(request, env, ctx) {
    return cloudflareContextALS.run({ env, ctx, cf: request.cf }, async () => {
      if (requestHandler == null) {
        globalThis.process.env = { ...globalThis.process.env, ...env };
        const NextNodeServer = require_next_server().default;
        requestHandler = new NextNodeServer({
          conf: nextConfig,
          customServer: false,
          dev: false,
          dir: "",
          minimalMode: false
        }).getRequestHandler();
      }
      const url = new URL(request.url);
      if (url.pathname === "/_next/image") {
        const imageUrl = url.searchParams.get("url") ?? "https://developers.cloudflare.com/_astro/logo.BU9hiExz.svg";
        if (imageUrl.startsWith("/")) {
          return env.ASSETS.fetch(new URL(imageUrl, request.url));
        }
        return fetch(imageUrl, { cf: { cacheEverything: true } });
      }
      const { req, res, webResponse } = getWrappedStreams(request, ctx);
      ctx.waitUntil(Promise.resolve(requestHandler(new import_node.NodeNextRequest(req), new import_node.NodeNextResponse(res))));
      return await webResponse();
    });
  }
};
function getWrappedStreams(request, ctx) {
  const url = new URL(request.url);
  const reqBody = request.body && Stream.Readable.fromWeb(request.body);
  const req = reqBody ?? Stream.Readable.from([]);
  req.httpVersion = "1.0";
  req.httpVersionMajor = 1;
  req.httpVersionMinor = 0;
  req.url = url.href.slice(url.origin.length);
  req.headers = Object.fromEntries([...request.headers]);
  req.method = request.method;
  Object.defineProperty(req, "__node_stream__", {
    value: true,
    writable: false
  });
  Object.defineProperty(req, "headersDistinct", {
    get() {
      const headers = {};
      for (const [key, value] of Object.entries(req.headers)) {
        if (!value)
          continue;
        headers[key] = Array.isArray(value) ? value : [value];
      }
      return headers;
    }
  });
  const { readable, writable } = new IdentityTransformStream();
  const resBodyWriter = writable.getWriter();
  const res = new import_mock_request.MockedResponse({
    resWriter: (chunk) => {
      resBodyWriter.write(typeof chunk === "string" ? Buffer.from(chunk) : chunk).catch((err) => {
        if (err.message.includes("WritableStream has been closed") || err.message.includes("Network connection lost")) {
          return;
        }
        console.error("Error in resBodyWriter.write");
        console.error(err);
      });
      return true;
    }
  });
  res.flushHeaders = () => res.headPromiseResolve();
  let { statusCode } = res;
  Object.defineProperty(res, "statusCode", {
    get: function() {
      return statusCode;
    },
    set: function(val) {
      if (this.finished || this.headersSent) {
        return;
      }
      statusCode = val;
    }
  });
  ctx.waitUntil(res.hasStreamed.finally(() => resBodyWriter.close().catch(() => {
  })));
  return {
    res,
    req,
    webResponse: async () => {
      await res.headPromise;
      res.setHeader("content-encoding", "identity");
      return new Response(NON_BODY_RESPONSES.has(res.statusCode) ? null : readable, {
        status: res.statusCode,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        headers: res.headers
      });
    }
  };
}
export {
  worker_default as default
};
/*! Bundled license information:

next/dist/compiled/cookie/index.js:
  (*!
   * cookie
   * Copyright(c) 2012-2014 Roman Shtylman
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)

react/cjs/react.production.js:
  (**
   * @license React
   * react.production.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

next/dist/compiled/fresh/index.js:
  (*!
   * fresh
   * Copyright(c) 2012 TJ Holowaychuk
   * Copyright(c) 2016-2017 Douglas Christopher Wilson
   * MIT Licensed
   *)

next/dist/compiled/jsonwebtoken/index.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
